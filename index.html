<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>藤塚太鼓 出欠・予定</title>
  
<!-- ===== 設定（共通） v1：ページ先頭に固定 ===== -->
<script>
  // 以後、このブロックだけを更新してください
  /* ===== 設定 ===== */
  const FRONT_VERSION = "v1.2.3";  // stable ver→v1.2.2
  const LIFF_ID = "2008270687-9qV1G3yq";
  const API_ENDPOINT = "https://script.google.com/macros/s/AKfycbxKxpI2o-ySG6LId__qtpA8hPiESMczrQn-KO46ln7wU7D51yPrB4lNdTUyoEBi-C-l/exec";     // GAS v1.1.0
  const D1_API_BASE_URL = "https://taiko-worker-plain.fujizukadaiko.workers.dev";
             
              // D1 のベースURL
              const D1_BASE = (typeof D1_API_BASE_URL === "string"
                  ? D1_API_BASE_URL
                  : ""
              ).replace(/\/+$/, "");
  
              const D1_ORIGIN = D1_BASE || window.location.origin;
  
  // === 更新履歴（アプリ内「変更履歴」表示用） ===
            window.__CHANGELOG_ENTRIES__ = [
                {
                    date: "2026-01-04",
                    title: "システムの読み込みを高速化",
                    tags: ["改善", "内部"],
                    body: "トップ画面の「今後の予定」「会員情報」などの読み込み処理を変更し、表示速度と安定性を改善しました。"
                },
                {
                    date: "2026-01-04",
                    title: "出欠入力フォームに締切後のイベントの回答内容を表示",
                    tags: ["改善", "UI"],
                    body: "回答締切後もそのイベントへの回答内容を確認できるように改善しました。"
                },
                {
                    date: "2026-01-04",
                    title: "保存中のモーダル表示を追加",
                    tags: ["改善", "UI"],
                    body: "編集画面で保存ボタンを押した際に、「保存中…」などのモーダルを表示するようにしました。処理中かどうかが一目で分かります。"
                },
                {
                date: "2025-11-15",
                title: "ご意見BOX（右下ボタン）を追加",
                tags: ["機能追加","UI"],
                body: "気づいた点や改善要望を送信できるフォームを追加しました。右下の吹き出しボタンから利用できます。"
                },
                {
                date: "2025-11-15",
                title: "今後の予定に演奏開始時間を表示",
                tags: ["改善","UI"],
                body: "イベント一覧に演奏開始時間を表示するようにしました。"
                },
                {
                date: "2025-11-15",
                title: "更新履歴ページを追加",
                tags: ["機能追加","UI"],
                body: "アプリ内の変更点を確認できるようになりました。右上「vX.X.X」から開けます。未読マークも表示されます。"
                }
            ];

            // === キャッシュ名前空間（環境ごとに localStorage を分離） ===
            const ENV_NS = (() => {
                const raw = [location.origin, LIFF_ID, API_ENDPOINT].join("|");
                // ざっくりハッシュ（djbx33a）
                let h = 5381;
                for (const c of raw) h = ((h << 5) + h) ^ c.charCodeAt(0);
                return "env:" + (h >>> 0).toString(36);
            })();

            // 環境変更検知：LIFF_ID or API_ENDPOINT が変わったら liff: 系キャッシュを全クリア
            (function rememberEnvAndPurge(){
                const K   = "liff:env:current";
                const cur = `${LIFF_ID}|${API_ENDPOINT}`;
                const prev = localStorage.getItem(K);
                if (prev && prev !== cur) {
                Object.keys(localStorage).forEach(k => {
                    if (k.startsWith("liff:")) localStorage.removeItem(k);
                });
                }
                localStorage.setItem(K, cur);
            })();

            // === 設定チェック（開発者向けコンソール警告） ===
            (function checkConfig(){
                if (!FRONT_VERSION || !LIFF_ID || !API_ENDPOINT) {
                console.warn(
                    "[config] 設定が未入力の項目があります。",
                    "FRONT_VERSION / LIFF_ID / API_ENDPOINT を確認してください。"
                );
                }
                // 他スクリプトから参照しやすいよう window にまとめて公開
                window.__APP_CONFIG__ = { FRONT_VERSION, LIFF_ID, API_ENDPOINT, D1_BASE, ENV_NS };
            })();
        </script>

    <!-- ===== フォント / UI スタイル系 ===== -->
        <!-- Google Fonts（本文=ゴシック / 見出し=明朝） -->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link
        rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;600;700&amp;family=Noto+Serif+JP:wght@500;600;700&amp;family=Shippori+Mincho:wght@500;700&amp;display=swap"
        />

        <!-- Tailwind 設定（preflight 無効・テーマ拡張） -->
        <script>
        window.tailwind = window.tailwind || {};
        tailwind.config = {
            corePlugins: { preflight: false },
            theme: {
            extend: {
                colors: {
                primary: '#7f6aa5',
                },
                boxShadow: {
                card: '0 2px 10px rgba(0,0,0,0.04)',
                },
            },
            },
        };
        </script>
        <script src="https://cdn.tailwindcss.com?plugins=forms,typography"></script>
    <!-- ===== /フォント / UI スタイル系 ===== -->

    <!-- ===== Base CSS ===== -->
    <style>
    /* ===== Base / Layout / Typography ===== */
        :root{
        --c-bg:#f7f5fa; --c-panel:#fff; --c-border:#e8e2f0;
        --c-text:#202022; --c-muted:#6b6b6b;
        --c-primary:#7f6aa5; --c-primary-2:#6d5a93; --c-accent:#a678b0;
        --c-acc1:#d2e5b1; --c-acc2:#9ce78f; --c-acc2-dark:#6aa96a;
        --c-ok:#0a7; --c-err:#c33;
        --seg-child-border:#f59e9e;
        --seg-adult-border:#93c5fd;
        --seg-both-border:#e8e2f0;
        }
        body{
        margin:0; color:var(--c-text);
        font-family:"Noto Sans JP",system-ui,-apple-system,Segoe UI,"Hiragino Sans","Yu Gothic","Meiryo",sans-serif;
        letter-spacing:.02em;
        background:
            radial-gradient(1200px 600px at 20% 10%, rgba(127,106,165,.05), transparent 40%),
            radial-gradient(900px 500px  at 80% 60%, rgba(127,106,165,.04), transparent 35%),
            var(--c-bg);
        }
        h1,h2,h3{
        font-family: "Shippori Mincho", "Noto Serif JP", "Yu Mincho", "Hiragino Mincho ProN", "MS PMincho", serif;
        letter-spacing: 0.03em;
        }
        .sectionTitle{
        font-family: "Noto Sans JP","Hiragino Sans","Yu Gothic","Meiryo",sans-serif;
        font-weight: 700;
        letter-spacing: 0.02em;
        }
        .siteTitle{
        font-family: "Shippori Mincho","Noto Serif JP","Yu Mincho","Hiragino Mincho ProN","MS PMincho",serif !important;
        font-weight: 600; letter-spacing: 0.03em;
        }

        header{
        padding:14px 16px; font-size:18px;
        background:#fff; border-bottom:1px solid var(--c-border);
        display:flex; justify-content:space-between; align-items:center;
        }
        main{ padding:14px 16px; }
        .ver{ font-size:12px; color:#888; font-weight:500; }

        .card{ background:#fff; border:1px solid var(--c-border); border-radius:12px; padding:12px; margin:10px 0; }
        .muted{ color:var(--c-muted); font-size:13px; }
        .row{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
        .row-space{ display:flex; justify-content:space-between; align-items:center; gap:8px; }
        .right{ text-align:right; }
        .badge{ display:inline-block; font-size:12px; padding:2px 6px; background:var(--c-accent); color:#fff; border-radius:999px; margin-left:8px; }
        .small{ font-size:12px; color:var(--c-muted); }

        [data-view]{ display:none; }
        [data-view].show{ display:block; }

        .spinner{ width:18px; height:18px; border:2px solid #ddd; border-top-color:var(--c-primary); border-radius:50%; animation:spin 1s linear infinite; display:inline-block; vertical-align:middle; }
        @keyframes spin{ to{ transform:rotate(360deg); } }

        label{ display:block; font-size:14px; margin:6px 0 4px; }
        input[type="text"], input[type="date"], input[type="time"], select, textarea{
        width:100%; border:1px solid var(--c-border); border-radius:8px; padding:8px; font-size:15px; background:#fff;
        }
        .listEmpty{ color:#888; font-size:14px; }

        .pill{ display:inline-flex; align-items:center; gap:6px; padding:5px 8px; border-radius:999px; background:#f5f5f5; border:1px solid var(--c-border); }
        .pill.sm{ font-size:11px; padding:2px 6px; }

        .stat-ok{ background:#e8f8f3; border:1px solid #cdeee4; color:#0a7; }
        .stat-ng{
        background:#eef2f7 !important;
        border:1px solid #d2d9e3 !important;
        color:#334155 !important;
        }
        .stat-pd{ background:#fff7d6; border:1px solid #f3d27a; color:#7a5b00; }
        .stat-na{ background:#f5f5f5; border:1px solid var(--c-border); color:#666; }

        .adminGrid{ display:grid; grid-template-columns:1fr 1fr; gap:12px; }
        @media (max-width:700px){ .adminGrid{ grid-template-columns:1fr; } }
        .hint{ font-size:12px; color:#777; }

        .tag{ display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid var(--c-border); background:#f7f7f7; color:#444; }
        .tag.open{ background:#e8f8f3; border-color:#cdeee4; color:#0a7; }
        .tag.closed{ background:#fdeaea; border-color:#f6cccc; color:#c33; }

        header.is-sticky{ position:sticky; top:0; backdrop-filter:blur(6px); background:rgba(255,255,255,.9); z-index:50; }

        .warnBox{ background:#fff7d6; border:1px solid #f3d27a; padding:10px; border-radius:10px; color:#7a5b00; }
        
        /* レイアウト：フッターを最下部に固定（中身が少ないページでも） */
            html, body { height: 100%; }
            body { min-height: 100svh; display: flex; flex-direction: column; }
            main { flex: 1 0 auto; }
            
            /* フッターの見た目 */
            .siteFooter{
            text-align:center; font-size:12px; color:#777;
            padding: 10px 16px; border-top:1px solid var(--c-border);
            }
            .siteFooter a{ color: var(--c-primary-2); text-decoration:none; }
            .siteFooter .dot{ color:#bbb; margin:0 6px; }
        
        a.btn, button.btn{
        display:inline-flex; align-items:center; justify-content:center;
        min-height:40px; padding:10px 14px; border-radius:12px;
        border:1px solid var(--c-border); background:#fff; color:var(--c-text);
        text-decoration:none; font-size:15px; font-weight:600; letter-spacing:.01em; line-height:1;
        box-shadow:0 2px 8px rgba(0,0,0,.06);
        transition:transform .08s ease, filter .12s ease, box-shadow .12s ease;
        cursor:pointer;
        }
        .btn-primary{
        color:#fff !important;
        border-color:color-mix(in srgb, var(--c-primary-2), #000 6%) !important;
        background-image:linear-gradient(to bottom right, var(--c-primary), var(--c-primary-2)) !important;
        background-color:var(--c-primary) !important;
        }
        .btn-outline{ background:#fff !important; color:var(--c-primary-2) !important; border-color:var(--c-primary-2) !important; }
        .btn-sm{ padding:8px 12px; min-height:36px; font-size:14px; border-radius:10px; }
        .btn-lg{ padding:12px 16px; min-height:44px; font-size:16px; border-radius:14px; }
        .btnRow{ display:flex; flex-wrap:wrap; gap:8px; align-items:stretch; margin:8px 0; }
        .btnRow .btn{ flex:1 1 100%; }
        @media (min-width:600px){
        .btnRow{ display:grid; grid-template-columns:repeat(3,minmax(0,1fr)); gap:10px; }
        .btnRow .btn{ width:100%; }
        }

        /* Base: セレクトをボタン風にする共通スタイル */
            .selectBtn{
            border: 1.5px solid var(--c-primary-2);
            background: #fff;
            color: var(--c-primary-2);
            border-radius: 10px;
            box-shadow: 0 1px 4px rgba(127,106,165,0.14);

            height: 36px;
            min-height: 36px;
            padding: 6px 12px;
            font-size: 14px;

            -webkit-appearance: none;
            appearance: none;
            }
            .selectBtn:focus{
            outline: none;
            box-shadow: 0 0 0 3px rgba(127,106,165,.18);
            }

            /* === disabledテキスト入力の見た目をselectと統一（iOS/Safari対応） === */
            .selectBtn:disabled,
            input[type="text"]:disabled,
            input[type="date"]:disabled,
            input[type="time"]:disabled,
            textarea:disabled {
            color: #888 !important;                     /* テキスト色 */
            -webkit-text-fill-color: #888 !important;   /* iOS/Safariで薄くなるのを防ぐ */
            opacity: 1 !important;                      /* iOSの透明度低下を打ち消す */
            background: #f7f5ff !important;             /* 既存ルールと統一 */
            border-color: #e6e0f0 !important;
            box-shadow: none;
            cursor: not-allowed;
            }
            
            /* placeholderも濃さを統一する */
            input[type="text"]:disabled::placeholder,
            input[type="date"]:disabled::placeholder,
            input[type="time"]:disabled::placeholder,
            textarea:disabled::placeholder {
            color: #888 !important;
            opacity: 1 !important;
            }
            
            /* Safari旧挙動の保険 */
            input[type="text"]:disabled::-webkit-input-placeholder,
            input[type="date"]:disabled::-webkit-input-placeholder,
            input[type="time"]:disabled::-webkit-input-placeholder,
            textarea:disabled::-webkit-input-placeholder {
            color: #888 !important;
            opacity: 1 !important;
            }

            /* 区切り線（Tailwindの .line 相当） */
            .line{
            height: 1px;
            margin: 12px 0;
            background: var(--c-border);
            }

            /* 入力のフォーカス時にうっすら紫リングを付けたい場合 */
            input[type="text"],
            input[type="date"],
            input[type="time"],
            select,
            textarea{
            outline: none;
            }

            input[type="text"]:focus,
            input[type="date"]:focus,
            input[type="time"]:focus,
            select:focus,
            textarea:focus{
            box-shadow: 0 0 0 2px color-mix(in srgb, var(--c-primary) 25%, transparent);
            border-color: color-mix(in srgb, var(--c-primary-2) 40%, var(--c-border));
            }

            /* ---- 軽い削除ボタン（見た目を他ボタンと差別化） ---- */
            .btn-remove{
            background:#fff !important;
            color:#222 !important;                         /* 黒系文字 */
            border:1px solid #dcd2ef !important;           /* ごく薄い紫の枠 */
            box-shadow:
                0 2px 10px rgba(127,106,165,0.10),           /* 薄い紫のソフトシャドウ */
                0 1px 0 rgba(0,0,0,0.02) inset;
            transition: transform .08s ease, filter .12s ease, box-shadow .12s ease;
            }
            .btn-remove:hover{
            filter: brightness(0.98);
            box-shadow:
                0 3px 12px rgba(127,106,165,0.16),
                0 1px 0 rgba(0,0,0,0.03) inset;
            }
            .btn-remove:active{
            transform: translateY(1px);
            }
            .btn-remove:focus-visible{
            outline: none;
            box-shadow:
                0 0 0 3px rgba(127,106,165,0.12),            /* フォーカス時に薄いリング */
                0 2px 10px rgba(127,106,165,0.10);
            }
            /* 無効時の視覚（全体ルールに準拠） */
            .btn-remove[disabled]{
            opacity: .55;
            pointer-events: none;
            cursor: not-allowed;
            filter: saturate(.6);
            }

            /* 汎用：コンパクトボタン */
            .btn-compact{
                min-height:30px;
                padding:6px 10px;
                font-size:13px;
                border-radius:9px;
            }     
        
        /* プレースホルダ行（value=""）の色 */
            .selectBtn option[value=""]{
                color: #9aa;
            }
        
        /* ===== Seg Badge（区分バッジ共通） ===== */
        .seg-badge{
        display:inline-flex; align-items:center; justify-content:center;
        height:20px; padding:0 8px; border-radius:999px;
        font-size:11px; font-weight:700; white-space:nowrap;
        border:1.5px solid; margin-right:8px;
        }
        .seg-adult { 
        color:#1d4ed8; background:#e6f0ff; border-color:#60a5fa; /* 青系(水色背景) */
        }
        .seg-child {
        color:#b91c1c; background:#ffecec; border-color:#f59e9e; /* 落ち着いた赤 */
        }
        .seg-both  {
        color:#6d5a93; background:#f1eaff; border-color:#bda8ea; /* 紫系 */
        }

        /* 「区分」セレクトを全幅 */
        #view-register .selectBtn{
        width: 100%;
        min-width: 0;
        }

        /* バッジの色設計 */
        .badge-att{
            display:inline-flex;
            align-items:center;
            justify-content:center;
            height:22px;
            padding:0 8px;
            border-radius:999px;
            font-size:12px;
            font-weight:700;
            border:1.5px solid;
        }
        .badge-att.yes   { color:#047857; background:#ecfdf5; border-color:#a7f3d0; }
        .badge-att.no    { color:#b91c1c; background:#fef2f2; border-color:#fecaca; }
        .badge-att.maybe { color:#92400e; background:#fffbeb; border-color:#fde68a; }
        .badge-att.na    { color:#475569; background:#f1f5f9; border-color:#cbd5e1; }

        /* 区分バッジ：やや小さめ */
        .seg-badge.sm{
            height:20px;
            padding:0 8px;
            font-size:11px;
        }

        /* 種別バッジ：右端＆四角 */
        .kind-badge{
            display:inline-flex;
            align-items:center;
            justify-content:center;
            height:20px;
            padding:0 10px;
            border-radius:6px;
            font-size:11px;
            border:1.5px solid var(--c-border);
            background:#f7f7f7;
            color:#444;
            line-height:1;
            white-space:nowrap;
        }
        
        /* 種別バッジの配色（発表 / 練習 / その他） */
        .kind-badge,
        .scKind{
        border-color: transparent;
        }

        /* 発表：黄系 */
        .kind-badge.badge--announce,
        .scKind.badge--announce{
        background:#FEF3C7;
        border-color:#F59E0B;
        color:#92400E;
        }

        /* 練習：緑系 */
        .kind-badge.badge--practice,
        .scKind.badge--practice{
        background:#ECFDF5;
        border-color:#10B981;
        color:#065F46;
        }

        /* その他：紫系 */
        .kind-badge.badge--other,
        .scKind.badge--other{
        background:#F5F3FF;
        border-color:#8B5CF6;
        color:#5B21B6;
        }

        /* 出欠カード全体を配置の基準にする */
        .fEvent{
            position: relative;
        }

        /* 出欠フォーム内の区分バッジだけ右上固定 */
        .fEvent .seg-badge{
            position: absolute;
            top: 10px;
            right: 16px;
            margin-right: 0;
        }

        /* バッジの幅＋余白ぶん。必要に応じて調整 */
        .fEvent .fRow1{
            padding-right: 80px; /* 必要なら調整 */
        }

        /* ===== 保存中オーバーレイ ===== */
        .saving-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.35);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 9999;
        }

        .saving-overlay.show {
        display: flex;
        }

        .saving-dialog {
        background: #fff;
        border-radius: 12px;
        padding: 16px 20px;
        min-width: 220px;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.25);
        text-align: center;
        font-size: 14px;
        }

        .saving-dialog .spinner {
        display: inline-block;
        margin-bottom: 8px;
        }

        .saving-message {
        white-space: nowrap;
        }
    /* ===== Attendance Form（出欠フォーム） ===== */
        .fEvent{ border:1px solid var(--c-border); border-radius:12px; background:#fff; margin:10px 0; }
        .fHead{ padding:10px 12px; cursor:pointer; }
        .fBody{ display:none; padding:0 12px 12px; }
        .fEvent.open .fBody{ display:block; }
        .fTitleRow{ display:flex; align-items:baseline; gap:6px; }
        .fTitleRow .t-date{ white-space:nowrap; }
        .fTitleRow .t-place{ white-space:nowrap; overflow:hidden; text-overflow:ellipsis; min-width:0; flex:1 1 auto; }
        .fStatusRow{ margin-top:6px; display:flex; flex-wrap:wrap; gap:6px; }
        .fSub{ margin-top:4px; font-size:12px; color:var(--c-muted); }
        .badge-unsaved{
            display:inline-flex; align-items:center; justify-content:center;
            padding:2px 8px; height:22px; border-radius:999px;
            font-size:11px; font-weight:600;
            color:#b45309; border:1.5px solid #f59e0b; background:#fff8e6; white-space:nowrap;
        }
        
        /* ===== 出欠フォーム：開いた時のヘッダー色を区分別に ===== */
        .fEvent[data-seg="child"].open .fHead { background:#ffecec; } /* 子ども=淡赤 */
        .fEvent[data-seg="adult"].open .fHead { background:#e6f0ff; } /* 大人=淡青 */
        .fEvent[data-seg="both"].open  .fHead { background:#efe7ff; } /* 両方=既存(紫) */
        /* ===== ① アコーディオン色：閉じた時/ホバー時/開いた時を区分別に統一 ===== */
        /* デフォルト（閉じている時）は透明にして枠色だけ見せる */
        .fEvent[data-seg] .fHead{ background: transparent; }
        
        /* ホバー時 */
        .fEvent[data-seg="child"] .fHead:hover { background:#fff5f5; } /* 淡い赤 */
        .fEvent[data-seg="adult"] .fHead:hover { background:#f2f7ff; } /* 淡い青 */
        .fEvent[data-seg="both"]  .fHead:hover { background:#f5efff; } /* 既存の淡紫 */
        
        /* 開いた時（既に設定済みでもOK。ここで最終上書き） */
        .fEvent[data-seg="child"].open .fHead { background:#ffecec; }
        .fEvent[data-seg="adult"].open .fHead { background:#e6f0ff; }
        .fEvent[data-seg="both"].open  .fHead { background:#efe7ff; }
        
        /* ===== ② 角のはみ出し対策（背景を枠内で丸めてクリップ） ===== */
        .fEvent{
        overflow: hidden;                 /* 子要素の背景が枠外へ出ないように */
        }
        .fEvent .fHead{
        border-top-left-radius:  inherit; /* コンテナの角丸に合わせる */
        border-top-right-radius: inherit;
        background-clip: padding-box;     /* Safari等のにじみ対策 */
        }

        /* イベントカード類（トップ/フォーム/予定/管理一覧） */
        .card[data-seg="child"], .fEvent[data-seg="child"], .eventRow[data-seg="child"]{
        border-color: var(--seg-child-border) !important;
        }
        .card[data-seg="adult"], .fEvent[data-seg="adult"], .eventRow[data-seg="adult"]{
        border-color: var(--seg-adult-border) !important;
        }
        .card[data-seg="both"], .fEvent[data-seg="both"], .eventRow[data-seg="both"]{
        border-color: var(--seg-both-border) !important;
        }
        
        /* ===== 出欠フォーム 見た目調整 ===== */
        /* ① 日付・時間・@場所 を太字に */
        .fTitleRow .t-date,
        .fTitleRow .t-place{
            font-weight: 700;
        }

        /* ② ガイド文（枠なし・背景なし・文字のみ） */
        #view-form #formEventsBox.guidePlain{
            background: transparent;
            border: 0;
            padding: 0;
            margin: 4px 0 8px;
        }

        /* ③ アコーディオン：選択中の色を少し濃い紫に */
        .fHead{ transition: background-color .12s ease; }
        .fHead:hover{ background: #f5efff; }
        .fEvent.open .fHead{ background: #efe7ff; } /* ←濃いめに */
    
        /* ④ 名前の丸い枠を廃止してシンプルに */
            .nameLabel{
                font-weight: 600;
                color: #444;
                /* 枠・背景なし */
                padding: 0;
                border: 0;
                background: transparent;
            }

            /* ⑤ 名前と小さめプルダウンを同一行に配置 */
            .row-att{
                display: flex;
                justify-content: space-between;
                align-items: center;
                gap: 10px;
            }
            .attSel{
                min-width: 120px;
                width: auto;
                height: 34px;
                font-size: 14px;
                padding: 6px 10px;
            }

            /* 出欠フォーム：「名前 + セレクト」行で右側だけ固定幅にしたい */
            .row-att .selectBtn{
            width: 120px;
            min-width: 120px;
            }

            /* === 出欠フォーム ヘッダー2行化 === */
            .fRow1, .fRow2{ display:flex; align-items:baseline; gap:6px; }

            /* 1行目：左=日付時刻 / 右=区分バッジ */
            .fRow1 .t-date{ white-space:nowrap; }
            .fRow1 .seg-badge{ margin-left:auto; }    /* 右端寄せ */

            /* 2行目：左=タイトル（省略可） / 右= @場所（1行固定） */
            .fRow2 .t-title{
                min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
            }
            .fRow2 .t-place{ white-space:nowrap; }

            /* 既存の太字指定を新レイアウトにも適用（サイズ変更なし） */
            .fRow1 .t-date{ font-weight:700; }

            /* ===== 出欠：セグメントを独立行にしたときの余白 ===== */
            .fHead .seg-badge{
                margin: 0 0 4px 0;
            }
            
            /* ===== ガイドの赤強調 ===== */
            .em-red{
                color: var(--c-err);
                font-weight: 700;
            }

            /* ===== 送信ボタン：送信中は薄い紫＆操作不可 ===== */
            .btn-primary[disabled],
            .btn-primary:disabled{
                background: #ede7ff !important;          /* 薄い紫 */
                border-color: #d6ccff !important;
                color: var(--c-primary-2) !important;
                cursor: not-allowed !important;
                pointer-events: none !important;          /* タップ無効（多重送信防止） */
                box-shadow: none !important;
                filter: saturate(.85);
            }
            /* すべてのボタンの disabled 視覚 */
            button[disabled],
            .btn[disabled],
            button:disabled,
            .btn:disabled{
                opacity: .55;
                pointer-events: none;
                cursor: not-allowed;
                filter: saturate(.6);
            }

            /* =========================================================
            ゴーストボタン（#btnFetchSchedules など）を紫ボーダーに統一
            既存 .btn, .btn-sm を活かして「色味」だけを合わせます
            ========================================================= */
            .btn.btn-ghost{
                background: #fff !important;
                color: var(--c-primary-2) !important;
                border: 1px solid color-mix(in srgb, var(--c-primary-2), #000 10%) !important;
                box-shadow: 0 1px 4px rgba(127,106,165, 0.08); /* ごく薄い影 */
                transition: background-color .12s ease, border-color .12s ease, color .12s ease, box-shadow .12s ease;
            }
            .btn.btn-ghost:hover{
                background: color-mix(in srgb, var(--c-primary), #fff 90%) !important; /* わずかに紫が乗る */
                border-color: var(--c-primary) !important;
                color: var(--c-primary-2) !important;
                box-shadow: 0 2px 8px rgba(127,106,165, 0.12);
            }
            .btn.btn-ghost:focus-visible{
                outline: 2px solid color-mix(in srgb, var(--c-primary), #000 0%) !important;
                box-shadow: 0 0 0 3px color-mix(in srgb, var(--c-primary), #fff 80%) !important;
            }

            /* === 出欠フォーム見出し（2行目）：タイトルと @場所の調整 === */
                .fRow2 .t-title{
                /* タイトルを少し小さく＋太字 */
                font-size: 15px ;   /* お好みで 14〜16px に調整OK */
                font-weight: 700 ;  /* 太字 */
                }
                
                .fRow2 .t-place{
                /* @場所は少し小さく */
                font-size: 14px ;   /* お好みで 13〜15px に調整OK */
                font-weight: 400 ;  
                margin-left: .5em;            /* タイトルとの間を少し空ける（任意） */
                }

                .fEvent.readonly {
                opacity: 0.9;
                background: #f7f7f7;
                }

                .row-att-readonly .attLabel {
                margin-left: 8px;
                font-weight: 600;
                }

                .commentReadOnly .commentText {
                font-weight: 500;
                }

                .fEvent.readonly .selectBtn,
                .fEvent.readonly input.evComment {
                pointer-events: none;
                }
                /* 展開後の「＠場所」(締切済みカード内) を小さく・控えめに */
                .fPlaceDetail {
                font-size: 12px;          /* ← ここで小さくする。11〜13あたりお好みで */
                color: var(--c-muted);    /* 既存の muted とトーンを合わせる */
                margin-bottom: 4px;       /* 下にちょっと余白 */
                }
    /* ===== Schedules（今後の予定） ===== */   
        /* 2行のラベル プルダウン配置 */
        /* ラベル｜セレクト の2列グリッド。要素は [label, select, label, select, span2...] の順 */
        .schedControls{
        display: grid;
        grid-template-columns: auto max-content; /* 左=ラベル、右=プルダウン */
        gap: 10px 14px;
        align-items: center;
        justify-content: start;
        }    

        .schedControls .field{
        display: flex;
        flex-direction: column;
        min-width: 0;
        }
        .schedControls .span2{
        grid-column: 1 / -1; /* 2列ぶち抜きで下段にボタン */
        }
        
        /* プルダウンを短め幅に（内容量に応じて調整可） */
        .schedSel{
        width: 160px;          /* コンパクト幅（ご希望に応じて 140〜200pxで微調整可） */
        max-width: 100%;
        }
        
        /* モバイルで列落ちしても綺麗に見せる */
        @media (max-width: 420px){
        .schedControls{
            grid-template-columns: 1fr 1fr; /* 2列のままでもOK。1列にしたければ 1fr に */
        }
        .schedSel{
            width: 100%; /* 極端に狭い端末では全幅にして文字切れを防止 */
        }
        }
        
        /* ラベル側のスタイル（任意） */
        .scLabel{
        font-size: 14px;
        color: var(--c-text);
        white-space: nowrap;
        }
        
        /* プルダウンを短め幅に（前回より“半分”寄りのサイズ） */
        .schedSel.short{
        width: 120px;                  /* 目安：前回160px → 120px。さらに短くしたければ 96〜110pxなどに */
        max-width: 100%;
        }
        
        /* 端末幅が狭い時の保険：文字が見切れないように */
        @media (max-width: 420px){
        .schedSel.short{
            width: clamp(100px, 40vw, 128px); /* 端末に応じて少し伸縮 */
        }
        }
    
    /* ===== Schedules: カードレイアウト（ホーム） ===== */
        /* === 今後の予定：新カードレイアウト === */
        .scheduleCard{ position:relative; cursor:pointer; }

        .scheduleCard .row1{
            display:flex;
            align-items:center;
            gap:8px;
            margin-bottom:4px;
        }
        .scheduleCard .row2{
            font-weight:700;
            margin:2px 0 0;
            display:flex;
            gap:8px;
            flex-wrap:wrap;
        }
        .scheduleCard .row2 .date{ white-space:nowrap; }
        .scheduleCard .row2 .title{ min-width:0; }

        .scheduleCard .row3{
            font-size:12px;
            color:#444;
            margin-top:4px;
            display:flex;
            align-items:baseline;
            gap:8px;
            flex-wrap:nowrap;
        }
        .scheduleCard .row3 .place{
            flex:1 1 auto;
            min-width:0;
            overflow:hidden;
            text-overflow:ellipsis;
            white-space:nowrap;
        }
        .scheduleCard .row3 .meet{
            flex:0 0 auto;
            white-space:nowrap;
            margin-left:auto;
        }

        .scheduleCard .row1 .kind-badge{
            margin-left:auto;
        }
        
        /* 折りたたみ付きカード */
        .scTop{
            display:flex;
            align-items:center;
            gap:8px;
            margin-bottom:6px;
        }
        .scKind{
            margin-left:auto;
            display:inline-flex;
            align-items:center;
            height:22px;
            padding:0 10px;
            font-size:12px;
            font-weight:700;
            background:#f7f7fb;
            border:1px solid var(--c-border);
            border-radius:8px;
            color:#444;
        }

        .scTitleBtn{
            all:unset;
            display:flex;
            align-items:baseline;
            gap:8px;
            width:100%;
            cursor:pointer;
        }
        .scTitleBtn .scDate{
            flex:0 0 auto;
            font-weight:700;
            white-space:nowrap;
        }
        .scTitleBtn .scTitle{
            flex:1 1 auto;
            min-width:0;
            white-space:nowrap;
            overflow:hidden;
            text-overflow:ellipsis;
        }
        .scTitleBtn[aria-expanded="true"] .scTitle{
            white-space:normal;
            overflow:hidden;
            text-overflow:clip;
            display:-webkit-box;
            -webkit-box-orient:vertical;
            -webkit-line-clamp:2;
        }
        .scTitleBtn .scTime{
            margin-left:.6rem;
            font-weight:600;
            white-space:nowrap;
            opacity:.9;
        }
        .scTitleBtn .scCaret{
            flex:0 0 auto;
            margin-left:8px;
            font-size:16px;
            line-height:1;
            transition:transform .12s ease;
        }
        .scTitleBtn[aria-expanded="true"] .scCaret{
            transform:rotate(180deg);
        }

        .scPanel{ margin-top:8px; }
        .scFullTitle{ font-weight:700; margin-bottom:6px; }
        .scMemo{
            margin:6px 0 2px;
            padding:0;
            border:0;
            background:transparent;
            border-radius:0;
            font-size:13px;
            color:#444;
        }
        .scMeta{
            font-size:13px;
            color:var(--c-text);
            margin-top:6px;
            display:flex;
            flex-direction:column;
            gap:4px;
        }
        .scMeta .scLine{
            display:flex;
            align-items:baseline;
            gap:.5em;
            min-width:0;
        }
        .scMeta .lbl{
            font-weight:700;
            margin-right:6px;
            white-space:nowrap;
        }

    /* ===== Admin（管理画面） ===== */
        /* 管理アコーディオン：ラベル｜プルダウンの2列グリッド */
        .adminControls{
            display:grid;
            grid-template-columns: auto max-content;
            gap:10px 14px;
            align-items:center;
            justify-content:start;
        }
        .adminControls .span2{
            grid-column:1 / -1;
            display:flex;
            justify-content:flex-start;
            margin-top:4px;
        }
        .admLabel{
            font-size:14px;
            color:var(--c-text);
            white-space:nowrap;
        }

        @media (max-width: 420px){
            .adminControls{
            grid-template-columns:1fr 1fr;
            }
            .adminControls select{
            width:100%;
            }
        }

        /* 管理アコーディオン：プルダウン幅をさらに半分くらいに */
        #adminListAcc .adminControls .schedSel.short{
            width:100px !important;
            min-width:100px !important;
            max-width:100%;
        }
        @media (max-width: 420px){
            #adminListAcc .adminControls .schedSel.short{
            width:100px !important;
            min-width:100px !important;
            }
        }

        /* 上部アコーディオンのヘッダーを常時うす紫、open時は少し濃く */
        #adminListAcc .fHead{
            background:#f5efff !important;
            border-radius:10px;
        }
        #adminListAcc.open .fHead{
            background:#efe7ff !important;
        }

        /* アコーディオン内の編集ボタンを小さめ＆薄めトーンに */
        #adminListAcc .btn-edit{
            min-height: 32px;
            padding: 6px 10px;
            font-size: 13px;
            border-radius: 9px;
            background:#fff !important;
            color: color-mix(in srgb, var(--c-primary-2), #000 0%) !important;
            border: 1px solid color-mix(in srgb, var(--c-primary-2), #000 12%) !important;
            box-shadow: 0 1px 3px rgba(127,106,165,0.08);
        }
        #adminListAcc .btn-edit:hover{
            background:#f8f6ff !important;
            border-color: color-mix(in srgb, var(--c-primary-2), #000 20%) !important;
        }
        
        /* 管理アコーディオン：開閉をIDで強制表示 */
        #adminListAcc .fBody{ display:none; }
        #adminListAcc.open .fBody{ display:block; }

        /* 管理アコーディオン：再取得ボタンもコンパクトに */
        #adminListAcc #btnAdminFetch{
            min-height:30px;
            padding:6px 10px;
            font-size:13px;
            border-radius:9px;
        }

        /* 管理アコーディオン：中身の余白 */    
        #adminListAcc .fBody{ padding-top:12px !important; }
        #adminListAcc .adminControls{ margin-top:4px; }
        
        /* トップの未定/未回答のみ表示：シンプル表示 */
        #homeOnlyNALabel{
            display:inline-flex;
            align-items:center;
            gap:6px;
            background:#fff !important;
            border:0 !important;
            padding:0 !important;
            box-shadow:none !important;
            font-size:13px;
            color:var(--c-text);
        }
        #homeOnlyNALabel input{
            width:16px;
            height:16px;
        }

        /* 管理用カードの3ボタンを編集ボタンと同サイズに */
        #adminMenu a.btn,
        #adminMenu button.btn{
            min-height:30px !important;
            padding:6px 10px !important;
            font-size:13px !important;
            border-radius:9px !important;
            box-shadow:0 1px 3px rgba(127,106,165,0.08);
        }

        /* 管理フォームのみ：注釈の文字をさらに小さく（10px） */
        #view-admin .hint{
            font-size: 10px !important;
            line-height: 1.55;
        }

    /* ===== Register（氏名編集） ===== */
        .regAddRow { 
        margin-top: 12px;               /* 上と詰まらないように余白を追加 */
        }
        #regNote {
        margin: 6px 0 8px;               /* タイトル直下の注意書きの行間 */
        font-size: 12px;
        color: var(--c-muted);
        }

        /* ===== 演奏者行（ラベルは1行、下段で入力と削除を2列に並べる） ===== */
        /* ===== 演奏者行：名前 7 / 右カラム 3（区分+削除） ===== */
        .perfRow{
        display: grid;
        grid-template-columns: 7fr 3fr;     /* ← 7:3 */
        grid-auto-rows: auto;
        column-gap: 12px;
        row-gap: 8px;
        margin: 10px 0;
        align-items: center;
        }
        .perfRow .perfLabel{
        grid-column: 1 / -1;               /* ラベルは2列ぶち抜き */
        font-size: 12px;
        color: var(--c-muted);
        }
        .perfRow .regPerf{
        grid-column: 1 / 2;                /* 左：名前 */
        width: 100%;
        height: 44px;
        }
        .perfRow .regPerfSeg{
        grid-column: 2 / 3;                /* 右（上段）：区分セレクト */
        width: 100%;
        height: 44px;
        }
        .perfRow .btn-remove{
        grid-column: 2 / 3;                /* 右（下段）：削除ボタン */
        width: 100%;
        min-height: 40px;
        height: 44px;
        padding: 0 12px;
        border-radius: 12px;
        justify-self: stretch;
        align-self: end;
        }
        /* 狭い端末でも維持（必要なら 1列化にもできます） */
        @media (max-width: 420px){
        .perfRow{ column-gap: 10px; }
        }
    
    /* ===== Admin Report（出欠レポート） ===== */
        /* ===== 出欠結果一覧：プルダウンの行（ラベル右にセレクト） ===== */
        .repControls{
            display: grid;
            grid-template-columns: auto minmax(0, 1fr); 
            gap: 10px 14px;
            align-items: center;
            justify-content: start;
        }
        .repControls .span2{
            grid-column: 1 / -1;
            display: flex;
            justify-content: flex-start;
            margin-top: 4px;
        }
        .repLabel{
            font-size: 14px;
            color: var(--c-text);
            white-space: nowrap;
        }

        /* ===== 出欠結果バッジ（管理レポート・旧レイアウト） ===== */
        .repCard{
            background:#fff;
            border:1px solid var(--c-border);
            border-radius:12px;
            padding:12px;
        }
        .repHead{
            display:flex;
            flex-wrap:wrap;
            gap:8px;
            align-items:center;
            margin-bottom:8px;
        }
        .repTitle{ font-weight:700; }
        .repSub  { font-size:12px; color:var(--c-muted); }

        .repRow{
            display:flex;
            align-items:baseline;
            gap:8px;
            padding:6px 0;
            border-top:1px dashed #eee;
        }
        .repRow:first-child{ border-top:0; }

        .repName{ font-weight:600; min-width:9em; }
        .repAt  { font-size:12px; color:var(--c-muted); }

        
        .repNA{
            margin-top:10px;
            padding-top:8px;
            border-top:1px solid var(--c-border);
            font-size:13px;
            color:#475569;
        }

        /* 管理レポート：名前⇔コメントの間を固定ギャップで */
        #view-admin-report .repPersonRow{
            display:flex;
            align-items:flex-start;
            gap:10px;
        }
        #view-admin-report .repPersonRow .repName{
            flex:0 0 auto;
        }
        #view-admin-report .repPersonRow .repAt{
            flex:1 1 auto;
            min-width:0;
            display:flex;
            align-items:baseline;
            overflow-wrap:anywhere;
            word-break:break-word;
        }
        #view-admin-report .repComment{
            display:block;
            flex:1 1 auto;
            min-width:0;
            white-space:normal !important;
            overflow-wrap:anywhere;
            word-break:break-word;
        }
        #view-admin-report .repPersonRow .repAt:empty{
            display:none;
        }
        #view-admin-report .repComment::before{
            content:"｜";
            color:var(--c-muted);
            margin-right:.5em;
            opacity:.7;
            flex:0 0 auto;
        }

       /* 管理レポート内のセレクトをカード内いっぱいに */
        #view-admin-report .repControls select{
            display:block;
            width:100%;
            max-width:100%;
            box-sizing:border-box;
        }
        /* 各ステータスグループの間に点線を入れる */
        #view-admin-report .repGroup + .repGroup{
        margin-top: 14px;              /* グループ同士の間隔 */
        padding-top: 12px;
        border-top: 1px dashed var(--c-border);
        }

        /* 「参加 / 未定 / 欠席 / 未回答」見出しまわりの余白 */
        #view-admin-report .repGroupHead{
        display: flex;
        align-items: center;
        gap: 6px;
        margin-bottom: 6px;
        }

        /* 1人分の行の上下に少し余白をつけて行間を広げる */
        #view-admin-report .repPersonRow{
        padding: 2px 0;
        }

        /* 名前とコメントの行間を気持ち広めに */
        #view-admin-report .repName,
        #view-admin-report .repComment{
        line-height: 1.5;
        }

        /* グループ末尾と次の点線の間が詰まりすぎないように */
        #view-admin-report .repGroup:last-child{
        margin-bottom: 4px;
        }
        /* ===== Admin Report：ヘッダーのレイアウト ===== */
        #view-admin-report .repHeader{
        margin-bottom: 12px;
        padding-bottom: 10px;
        border-bottom: 1px dashed var(--c-border); /* ← イベント情報の下に点線 */
        }

        #view-admin-report .repLine{
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        }

        #view-admin-report .repLeft{
        flex: 1 1 auto;
        min-width: 0;
        }

        #view-admin-report .repRight{
        flex: 0 0 auto;
        }

        #view-admin-report .repTitle{
        font-weight: 700;
        font-size: 16px;
        margin-bottom: 2px;
        }

        #view-admin-report .repMeta{
        font-size: 13px;
        color: var(--c-muted);
        }

        #view-admin-report .repPlace{
        margin-left: .25em;
        }

        /* ===== Admin Report：受付中 / 締切 バッジ ===== */
        #view-admin-report .badge-status{
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-width: 64px;
        height: 24px;
        padding: 0 10px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 700;
        border: 1px solid transparent;
        box-sizing: border-box;
        }

        #view-admin-report .badge-status.open{
        color: #047857;
        background: #ecfdf5;
        border-color: #a7f3d0;
        }

        #view-admin-report .badge-status.closed{
        color: #b91c1c;
        background: #fef2f2;
        border-color: #fecaca;
        }

        .submitting-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.35);
        display: none;          /* JS で切り替え */
        align-items: center;
        justify-content: center;
        z-index: 9999;
        }

        .submitting-overlay .overlay-inner {
        background: #fff;
        padding: 16px 24px;
        border-radius: 12px;
        min-width: 220px;
        text-align: center;
        box-shadow: 0 8px 24px rgba(0,0,0,0.2);
        font-size: 14px;
        }

        .submitting-overlay .overlay-text {
        margin-top: 8px;
        }
    /* ===== Custom Push ===== */ 
        #view-custom-push .card{
        max-width: 720px;
        margin: 12px auto;
        padding: 16px;
        border-radius: 16px;
        box-shadow: 0 4px 16px rgba(0,0,0,.06);
        }
        #view-custom-push .sectionTitle{ margin-bottom: 8px; }

         #view-custom-push .cp-checks{
            display:flex;
            flex-wrap:wrap;
            gap:12px;
            justify-content:flex-end;
        }
        #view-custom-push .cp-field{
            margin:12px 0;
            display:flex;
            flex-direction:column;
            gap:8px;
        }
        #view-custom-push .cp-textarea{
            width:100%;
            border:1.5px solid var(--c-primary-2);
            background:#fff;
            border-radius:10px;
            padding:10px 12px;
            font-size:16px;
            box-sizing:border-box;
        }
        #view-custom-push .hint{
            color:var(--c-muted);
            font-size:12px;
        }

        #view-custom-push .cp-stat-row{
            display:flex;
            flex-wrap:wrap;
            gap:12px;
            justify-content:flex-start;
            margin-bottom:10px;
        }

        #view-custom-push .cp-pill{
            border:1.5px dashed var(--c-primary-2);
            background:#f7f5ff;
            border-radius:10px;
            padding:12px;
            margin:10px 0;
        }
        #view-custom-push .cp-pill-title{
            font-weight:700;
            margin-bottom:4px;
            color:var(--c-text);
        }
        #view-custom-push .cp-pill-body{
            color:var(--c-muted);
        }

        #cp_extra{
            font-size:14px;
            line-height:1.4;
            border-radius:10px !important;
        }

        #view-custom-push .cp-space-1line{
            height:14px;
        }

        #view-custom-push .statWrap.is-disabled{
            background:#f5efff !important;
            border:1.5px dashed #d8cef1 !important;
            border-radius:12px !important;
            padding:10px !important;
            opacity:.95 !important;
        }
        #view-custom-push .statWrap.is-disabled label{
            color:#7a6fa6 !important;
        }
        #view-custom-push .statWrap .lockTag{
            display:inline-flex !important;
            align-items:center;
            gap:6px;
            font-size:12px;
            color:#7f6aa5;
            background:#efe7ff;
            border:1px solid #e6e0f0;
            border-radius:999px;
            padding:2px 8px;
            margin-left:8px;
        }
        #view-custom-push .statWrap .lockTag[hidden]{
            display:none !important;
        }

        #view-custom-push #cp_event{
            font-size:13px;
        }
        .loadingHint{
            font-size:12px;
            color:var(--c-muted);
        }

        /* タイトル周りの余白を他ページと合わせる */
        #view-custom-push{
            padding:0 !important;
        }
        #view-custom-push > .row-space{
            margin:8px 0 8px !important;
        }
        #view-custom-push .card:first-of-type{
            margin-top:8px !important;
        }

        /* cp_extra_row：固定幅に変更 */
        #cp_extra_row{
            display:grid;
            grid-template-columns: 1fr 180px;
            gap:8px;
        }
        #cp_extra_row .row-att-note{
            grid-column:1 / -1;
            margin-top:4px;
        }

        #cp_auto_targets, #cp_auto,
        #cp_manual_targets, #cp_manual{
            white-space:pre-line;
            font-size:0.9rem;
            line-height:1.6;
        }

        #view-custom-push #cp_stat_wrap label,
        #view-custom-push #cp_stat_wrap .repLabel{
            color:var(--c-text) !important;
        }

        #cp_body.cp-textarea{
            font-size:13px !important;
            line-height:1.7;
        }

        /* ===== カスタム通知：送信プレビューモーダル ===== */
        .cpModalOverlay {
        position: fixed;
        inset: 0;                        /* top:0; right:0; bottom:0; left:0 と同じ */
        background: rgba(0, 0, 0, 0.35); /* 背景の黒半透明 */
        z-index: 9999;                   /* ほぼ最前面に */
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 16px;
        box-sizing: border-box;
        }

        .cpModal {
        max-width: 480px;
        width: 100%;
        max-height: 80vh;
        background: #fff;
        border-radius: 16px;
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.18);
        padding: 16px 18px 14px;
        box-sizing: border-box;
        overflow: auto;
        font-size: 14px;
        line-height: 1.6;
        }

        .cpModal h3 {
        margin: 0 0 6px;
        font-size: 16px;
        font-weight: 600;
        }

        .cpModal .meta {
        font-size: 13px;
        color: #666;
        margin-bottom: 8px;
        }

        .cpModal pre {
        margin: 4px 0 0;
        padding: 8px 10px;
        border-radius: 10px;
        background: #f7f5ff;
        font-family: inherit;
        font-size: 14px;
        line-height: 1.6;
        white-space: pre-wrap;  /* 折り返し */
        }

        .cpModal .muted {
        font-size: 12px;
        color: #777;
        }

        .cpModal .pill.sm {
        font-size: 11px;
        }

        .cpModal .actions {
        margin-top: 14px;
        display: flex;
        justify-content: flex-end;
        gap: 8px;
        }
    
    /* ===== Summary ===== */
        #summaryFreeQuotaBox .kv { display: grid; gap: 6px; }
        #summaryFreeQuotaBox .kvRow { display:flex; justify-content:space-between; padding:6px 8px; border:1px solid #ddd; border-radius:8px; }
        #summaryFreeQuotaBox .kvKey { color:#666; font-size:13px; }
        #summaryFreeQuotaBox .kvVal { font-weight:600; }

        .summaryCard .kpi { display:inline-block; min-width:120px; padding:8px 10px; margin:4px; border:1px solid #eee; border-radius:8px; }
        .summaryCard .kpiLabel { font-size:12px; color:#666; }
        .summaryCard .kpiValue { font-size:20px; font-weight:700; }
        .summaryCard .num { text-align:right; font-variant-numeric: tabular-nums; }
        .summaryCard .ok { color:#0a7; }
        .summaryCard .ng { color:#c33; }
        .summaryCard .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; }
        .summaryCard .summaryHeader { font-weight:700; margin:6px 0 8px; }
        .summaryCard .summarySubHeader { font-weight:700; margin:10px 0 6px; }
        .table.compact th, .table.compact td { padding:4px 6px; }

        /* サマリ見出し行：右端へボタン寄せ */
        #view-summary .card .row.header {
        display:flex; align-items:center; gap:8px; margin-bottom:8px;
        }
        #view-summary .card .row.header .sectionTitle { flex:1; } /* ← これでボタンが右端へ */
        
        /* サマリカードのグリッド */
        .metricsGrid {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px;
        }
        @media (min-width: 480px){
        .metricsGrid { grid-template-columns: repeat(3, minmax(0, 1fr)); }
        }
        @media (min-width: 720px){
        .metricsGrid { grid-template-columns: repeat(4, minmax(0, 1fr)); }
        }
        .metricCard {
        border: 1px solid #e6e6e6;
        border-radius: 12px;
        padding: 14px 12px;
        background: #fff;
        }
        .metricTitle { font-size: 12px; color:#666; margin-bottom: 6px; }
        .metricValue { font-size: 22px; font-weight: 700; }
        .tableSm { width:100%; border-collapse: collapse; }
        .tableSm th, .tableSm td { padding: 8px 6px; border-bottom: 1px solid #eee; }
        .sectionSub { font-weight:700; font-size:16px; margin:14px 0 6px; }
        .badgeMuted { font-size:12px; padding:2px 8px; border-radius:9999px; background:#f0f0f7; color:#555; }
        .ok { color:#14a44d; } .ng { color:#d62d20; }

        /* KPI：横4並び（スマホでも崩れないよう少し小さめ） */
        /* ── ① 4列を“常に”固定 ─────────────────────────── */
        .summaryKpis{
        display:grid;
        grid-template-columns:repeat(4, minmax(0,1fr)); /* ← 常に4列 */
        gap:6px;                                        /* 余白を少し詰める */
        margin-top:8px;
        }
        
        /* ── ② 子要素はグリッド前提のコンパクト化 ───────────── */
        .summaryKpis .kpi{
        display:block;
        width:100%;
        min-width:0;
        margin:0;                 /* gap 管理 */
        padding:8px 6px;          /* 余白を縮める */
        min-height:52px;          /* ボックス高さ控えめ */
        border:1px solid #e6e6e6;
        border-radius:10px;
        background:#fff;
        }
        .summaryKpis .kpi .kpiLabel{
        font-size:10px;           /* ラベルを小さく */
        line-height:1.1;
        letter-spacing:.01em;
        }
        .summaryKpis .kpi .kpiValue{
        font-size:16px;           /* 数字も少し小さく */
        line-height:1.05;
        font-weight:700;
        font-variant-numeric: tabular-nums;
        }
        
        /* ── ③ 極小端末(幅≤360px)はさらに詰める保険 ──────── */
        @media (max-width:360px){
        .summaryKpis{ gap:4px; }
        .summaryKpis .kpi{ padding:6px 4px; min-height:48px; }
        .summaryKpis .kpi .kpiLabel{ font-size:9px; }
        .summaryKpis .kpi .kpiValue{ font-size:15px; }
        }
        .table.compact.smalltext { font-size: 13px; }
        .table.compact.smalltext th, 
        .table.compact.smalltext td { padding: 6px 8px; }
        .table.compact.history td, .table.compact.history th{
        font-size: 0.9rem; line-height:1.2;
        }
        .table.compact.history .nowrap { white-space: nowrap; }
        #view-summary table.table.compact.history.verysmall td,
        #view-summary table.table.compact.history.verysmall th {
        font-size: 11px !important;
        line-height: 1.1 !important;
        padding: 3px 5px !important;
        }

        /* ヘッダーのタイトル */
        .pageTitle{ font-weight:700; font-size:18px; }

            .kpi{ border:1px solid #e6e6e6; border-radius:12px; padding:12px; background:#fff; }
            .kpiLabel{ font-size:12px; color:#666; margin-bottom:6px; }
            .kpiValue{ font-size:22px; font-weight:700; }
        /* タブボタンの下に余白を追加 */
        #view-summary .card .tabsRow { margin-bottom: 12px; }  /* ← クラス名を付ける（下でJSから設定） */
        
        /* ===== サマリ（当月配信）ブロック ===== */
        .summaryBlock {
        border: 1px solid #e5e5f0;
        border-radius: 12px;
        padding: 12px 12px 10px;
        background: #fff;
        margin-bottom: 14px;
        }
        
        /* 履歴ブロック */
        .summaryBlock.historyBlock {
        border: 1px solid #e5e5f0;
        border-radius: 12px;
        padding: 12px 12px 10px;
        background: #fff;
        margin-bottom: 12px;
        }
        
        /* テーブルと再取得ボタンの間に余白 */
        #btnSummaryReload {
        margin-top: 10px;
        }

        /* サマリ本体を薄い枠で囲む */
        .summaryCard .summaryBody {
        border: 1px solid #e9e9f2;
        border-radius: 12px;
        padding: 12px;
        background: #fff;
        margin-top: 8px;
        }
    
    /* ===== Feedback FAB ===== */
        #feedbackFab.fab{
        position: fixed;
        right: 16px;
        bottom: calc(16px + env(safe-area-inset-bottom, 0px));
        width: 56px;
        height: 56px;
        border: none;
        border-radius: 9999px;
        padding: 0;
        background: linear-gradient(180deg, #7c6ae6 0%, #6f5dbd 100%);
        color: #fff;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 10px 24px rgba(0,0,0,.22);
        cursor: pointer;
        z-index: 1200;
        -webkit-tap-highlight-color: transparent;
        transition: transform .12s ease, box-shadow .12s ease, opacity .12s ease;
        }
        #feedbackFab.fab img{
        width: 26px;
        height: 26px;
        display: block;
        pointer-events: none;
        filter: invert(1) brightness(100%);
        }
        @media (hover:hover){
        #feedbackFab.fab:hover{
            box-shadow: 0 12px 28px rgba(0,0,0,.28);
            transform: translateY(-1px);
        }
        }
        #feedbackFab.fab:active{ transform: translateY(1px); }
        #feedbackFab.fab:focus-visible{
        outline: 3px solid rgba(255,255,255,.9);
        outline-offset: 2px;
        }
        @media (prefers-reduced-motion: reduce){
        #feedbackFab.fab{ transition: none; }
        }

        /* 視覚的に非表示（スクリーンリーダー用） */
        .sr-only{
        position: absolute !important;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0,0,0,0);
        white-space: nowrap;
        border: 0;
        }

        /* ===== ご意見モーダル ===== */
        #feedbackModal .modal-backdrop{
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,.42);
        z-index: 1300;
        }
        #feedbackModal .modal-card{
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: min(90vw, 420px);
        max-height: 80vh;
        overflow: auto;
        background:#fff;
        border-radius: 14px;
        box-shadow: 0 16px 48px rgba(0,0,0,.25);
        padding: 12px 12px 10px;
        z-index: 1310;
        }
        #feedbackModal .modal-header{
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:8px;
        }
        #feedbackModal .modal-title{
        font-weight:700;
        font-size:16px;
        }
        #feedbackModal .icon-btn{
        border:none;
        background:transparent;
        font-size:20px;
        }
        #feedbackModal .label{
        font-size:13px;
        color:#555;
        display:block;
        margin-bottom:4px;
        }
        #feedbackModal .select,
        #feedbackModal .textarea{
        width:100%;
        border:1px solid #ddd;
        border-radius:8px;
        padding:6px 10px;
        font-size:16px;
        background:#fff;
        }
        #feedbackModal .counter{
        font-size:12px;
        color:#666;
        text-align:right;
        margin-top:4px;
        }
        #feedbackModal .modal-footer{
        margin-top:10px;
        display:flex;
        justify-content:flex-end;
        gap:8px;
        }
        #feedbackModal .btn{
        padding:6px 12px;
        border-radius:8px;
        }
        #feedbackModal .btn-outline{
        background:#fff;
        border:1px solid #bbb;
        }
        #feedbackModal .btn-primary{
        background:#6f5dbd;
        color:#fff;
        border:1px solid #6f5dbd;
        }

        /* ===== スナックバー ===== */
        #snackbar.snackbar{
        position: fixed;
        left: 50%;
        bottom: 18px;
        transform: translateX(-50%);
        background: rgba(35,35,35,.95);
        color:#fff;
        padding:10px 14px;
        border-radius:10px;
        font-size:14px;
        opacity:0;
        pointer-events:none;
        transition: opacity .2s ease, transform .2s ease;
        z-index: 1400;
        max-width: 90vw;
        box-sizing: border-box;
        text-align: center;
        }

        /* 表示中 */
        #snackbar.show{
        opacity:1;
        pointer-events:auto;
        transform:translateX(-50%) translateY(-4px);
        }

        /* 種別ごとの色（お好みで） */
        #snackbar.snackbar-info{
        background: rgba(35,35,35,.95);
        }
        #snackbar.snackbar-success{
        background: rgba(22,163,74,.96);   /* 緑っぽい */
        }
        #snackbar.snackbar-error{
        background: rgba(220,38,38,.96);   /* 赤っぽい */
        }
        /* 保存中（loading）のとき左に小さいスピナーを出す */
        #snackbar.loading::before {
        content: "";
        display: inline-block;
        width: 14px;
        height: 14px;
        margin-right: 6px;
        border-radius: 999px;
        border: 2px solid rgba(255,255,255,.5);
        border-top-color: #fff;
        animation: fbsp 0.8s linear infinite;
        vertical-align: -2px;
        }

        /* お好みで成功/エラーの色だけ変えてもOK（任意） */
        #snackbar.success {
        background: rgba(22,163,74,.95);  /* 緑っぽい */
        }
        #snackbar.error {
        background: rgba(220,38,38,.95);  /* 赤っぽい */
        }
        /* ===== ご意見BOX（管理画面） ===== */
        .fb-cat{
        font-weight:700;
        margin:12px 0 6px;
        }
        .fb-acc{
        border:1px solid #eee;
        border-radius:10px;
        padding:8px 10px;
        margin:8px 0;
        background:#fff;
        }
        .fb-row{
        display:flex;
        align-items:center;
        gap:10px;
        flex-wrap:wrap;
        }
        .fb-meta{
        font-size:13px;
        color:#666;
        }
        .badge-st{
        font-size:11px;
        padding:2px 8px;
        border-radius:999px;
        background:#f0f0f7;
        color:#555;
        }
        .select-mini{
        font-size:13px;
        padding:6px 8px;
        border:1px solid #ddd;
        border-radius:8px;
        }
        .fb-msg{
        font-size:14px;
        line-height:1.6;
        flex:1 1 auto;
        white-space:pre-wrap;
        word-break:break-word;
        color:#333;
        }
        details.fb-acc > summary{
        cursor:pointer;
        list-style:none;
        }
        details.fb-acc > summary::-webkit-details-marker{ display:none; }

        /* 個別行レイアウト */
        .fb-item{
        border:1px solid #eee;
        border-radius:10px;
        padding:8px 10px;
        margin:8px 0;
        background:#fff;
        }
        .fb-sum{
        display:flex;
        align-items:center;
        gap:10px;
        }
        .fb-sum .mono{
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        font-weight:600;
        }
        .fb-sum .name{ font-weight:600; }
        .fb-sum .date{
        margin-left:auto;
        color:#666;
        font-size:12px;
        }

        /* 本文＋ステータス 2カラム */
        .fb-body-row{
        display:flex;
        align-items:flex-start;
        gap:10px;
        }
        .fb-status-wrap{
        flex:0 0 auto;
        margin-left:auto;
        display:flex;
        align-items:center;
        }

        /* ステータスのプルダウン */
        .fb-status{
        font-size:13px;
        padding:6px 8px;
        border:1px solid #ddd;
        border-radius:8px;
        background:#fff;
        color:#333;
        }
        #view-feedback .fb-status{
        min-width:112px;
        background:#f7f7f9;
        color:#444;
        }

        /* ステータス色（select 自体に色を付ける） */
        #view-feedback .fb-status.is-未対応{ background:#f3f4f6; color:#374151; }
        #view-feedback .fb-status.is-対応中{ background:#fef9c3; color:#92400e; }
        #view-feedback .fb-status.is-保留  { background:#e0f2fe; color:#1e3a8a; }
        #view-feedback .fb-status.is-完了  { background:#ecfdf5; color:#065f46; }
        #view-feedback .fb-status.is-却下  { background:#fee2e2; color:#991b1b; }

        /* ご意見BOX ヘッダー行：タイトル左／ボタン右 */
        #view-feedback .row.header{
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:8px;
        margin-bottom:8px;
        }
        #view-feedback .row.header .sectionTitle{
        flex:1 1 auto;
        }
        #btnFeedbackBack{
        margin-left:auto !important;
        }

        /* 行の境界線 */
        #view-feedback .fb-row{
        border-bottom:1px solid #eee;
        padding:8px 4px;
        }
        #view-feedback .fb-row:last-child{
        border-bottom:0;
        }

        /* 1行目：#No / 名前 / 日時 */
        #view-feedback .fb-row-head{
        display:flex;
        align-items:center;
        gap:8px;
        margin-bottom:4px;
        }
        #view-feedback .fb-row-head .mono{
        font-variant-numeric: tabular-nums;
        color:#666;
        }
        #view-feedback .fb-row-head .name{ font-weight:600; }
        #view-feedback .fb-row-head .date{
        margin-left:auto;
        color:#666;
        }

        /* 2行目：コメント + ステータス */
        #view-feedback .fb-row-body{
        display:flex;
        align-items:flex-start;
        gap:8px;
        width:100%;
        }
        #view-feedback .fb-row-body .fb-msg{
        flex:1 1 auto;
        white-space:pre-wrap;
        word-break:break-word;
        line-height:1.5;
        }
        #view-feedback .fb-status-wrap{
        flex:0 0 auto;
        margin-left:auto;
        display:flex;
        align-items:center;
        }

        /* カテゴリ summary 見た目 */
        #view-feedback .fb-cat-head{
        display:flex;
        align-items:center;
        gap:8px;
        padding:4px 2px;
        cursor:pointer;
        }
        #view-feedback .fb-cat-head .sectionTitle{
        font-size:17px;
        font-weight:700;
        color:#2b2346;
        }
        #view-feedback .fb-cat-head .fb-count{
        margin-left:auto;
        font-size:13px;
        color:#777;
        background:#f1f1f6;
        border-radius:999px;
        padding:2px 8px;
        }

        /* カテゴリタイトル右上の「新規あり」ドット */
        #view-feedback .fb-cat.has-unread > .fb-cat-head::after{
        content:"";
        display:inline-block;
        width:8px;
        height:8px;
        margin-left:6px;
        border-radius:9999px;
        background:#e11d48;
        }

        /* ご意見BOX用スピナー */
        #view-feedback .spinner{
        display:inline-block;
        width:14px;
        height:14px;
        border-radius:50%;
        border:2px solid #ccc;
        border-top-color:#6f5dbd;
        animation: fbsp 0.8s linear infinite;
        vertical-align:-2px;
        margin-left:6px;
        }
        @keyframes fbsp{
        to{ transform: rotate(360deg); }
        }

        .fb-row.is-dirty {
        border-left: 4px solid #f0a000;
        }
        .fb-status.is-dirty {
        outline: 2px solid #f0a000;
        }
    /* ===== Changelog modal ===== */
        /* 初期は非表示 */
        #changelogModal[hidden]{
        display: none;
        }

        /* 背景（クリックで閉じる） */
        #changelogModal .modal-backdrop{
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,.42);
        z-index: 1300;
        }

        /* 本体：中央固定＋見た目 */
        #changelogModal .modal-card{
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: min(92vw, 560px);
        z-index: 1310;
        background: #fff;
        border-radius: 14px;
        box-shadow: 0 8px 28px rgba(0,0,0,.15);
        padding: 18px 16px;
        font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "Segoe UI", sans-serif;
        max-height: 80vh;              /* 画面の8割までの高さに制限 */
        overflow-y: auto;              /* 中身が増えたらカード内スクロール */
        -webkit-overflow-scrolling: touch; /* iOSでぬるっとスクロール */
        }
        /* リスト */
        .cg-item{
        border: 1px solid #e5e5ef;
        border-radius: 10px;
        padding: 10px 12px;
        margin-bottom: 10px;
        background: #fafafa;
        }
        .cg-head{
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 4px;
        }
        .cg-title{
        font-size: 15px;
        font-weight: 600;
        color: #333;
        }
        .cg-tags{
        display: flex;
        gap: 6px;
        }
        .cg-tag{
        font-size: 11px;
        color: #666;
        background: #f1f1f6;
        padding: 2px 6px;
        border-radius: 6px;
        }
        .cg-date{
        font-size: 12px;
        color: #999;
        margin-bottom: 6px;
        }
        .cg-body{
        font-size: 13px;
        line-height: 1.5;
        color: #444;
        }

        /* フッター＆ボタン */
        #changelogModal .modal-footer{
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        margin-top: 12px;
        }
        #changelogModal .btn{
        border-radius: 8px;
        padding: 6px 14px;
        font-size: 13px;
        }
        #changelogModal .btn-outline{
        background: #fff;
        border: 1px solid #ccc;
        color: #444;
        }
        #changelogModal .btn-primary{
        background: #6f5dbd;
        border: 1px solid #6f5dbd;
        color: #fff;
        }

        /* タイトル控えめ */
        #changelogModal .modal-title{
        font-size: 16px;
        font-weight: 600;
        color: #222;
        }

        /* バージョン表示の未読ドット（1か所だけ） */
        #ver{
        position: relative;
        display: inline-block;
        }
        #ver.has-unread::after{
        content: "";
        position: absolute;
        top: -3px;
        right: -6px;
        width: 8px;
        height: 8px;
        background: #e11d48;
        border-radius: 9999px;
        }
        /* リスト部分だけスクロールさせる */
        #changelogList{
        margin-top: 8px;        /* タイトルとの余白が欲しければ */
        }
    /* ===== 回答受付中の公演リスト 専用 ===== */
        const css = document.createElement('style');
        css.textContent = `
        .evList { margin-top: 6px; }
        .eventRow{
            display:block;border:1px solid var(--c-border);border-radius:12px;background:#fff;
            padding:10px 12px;margin:8px 0;
        }
        .eventHead{
            display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:6px;
        }
        .eventHead-left{ display:flex; align-items:center; gap:6px; }
        .eventHead-right{ display:flex; align-items:center; gap:6px; margin-left:auto; }
        .badge-new{
            display:inline-flex;align-items:center;justify-content:center;padding:2px 8px;height:22px;
            border-radius:999px;font-size:11px;font-weight:600;color: var(--c-primary-2);
            border:1.5px solid var(--c-primary-2);background:#fff;white-space:nowrap;
        }
        .eventTitle{ display:flex; align-items:baseline; gap:4px; font-weight:700; font-size:15px; line-height:1.45; }
        .eventTitle .title-date{ white-space:nowrap; flex:0 0 auto; }
        .eventTitle .title-place{ white-space:nowrap; overflow:hidden; text-overflow:ellipsis; min-width:0; flex:1 1 auto; }
        .eventSub{ font-size:12px; color:var(--c-muted); margin-top:2px; }
        .deadline{ color:#666; } .deadline-soon{ color:#c33; font-weight:600; }
        /* 区分バッジは既存 .seg-badge / .seg-adult / .seg-child / .seg-both を利用 */
        `;
        document.head.appendChild(css);
    </style>
    <!-- ===== Custom Overrides（最後に評価されるCSS） ===== -->
        <style id="custom-overrides">
        /* 本番用スタイルはすべて Base CSS に移管済み。
        ここは一時的なホットフィックス・検証用に空で残しておく。 */
        </style>
  
    <!-- LIFF SDK -->
    <script src="https://static.line-scdn.net/liff/edge/2/sdk.js"></script>
</head>

<body>
  <header class="is-sticky">
  <div class="siteTitle">藤塚太鼓 出欠・予定</div>
  <div class="ver" id="ver"></div>
</header>

<main>
    <!-- 友だち未追加アラート -->
        <div
        id="friendAlert"
        class="card warnBox"
        style="display:none;"
        role="alert"
        aria-live="assertive"
        >
        このLIFFのBotが「友だち追加」されていません。通知を受け取るには公式アカウントを友だち追加してください。
        </div>

    <!-- ===== View: ホーム（メンバー用トップ画面） ===== -->
        <section id="view-home" data-view class="show">
            <div id="hello" class="muted"></div>
            <!-- 管理メニュー（管理者のみ表示） -->
                <div id="adminMenu" class="card" style="display:none;">
                <div class="sectionTitle">管理用</div>
                <div class="row" style="gap:8px;">
                    <button id="btnAdminMenuSchedules" class="btn btn-outline btn-sm btn-compact" data-view-target="view-admin">
                        予定登録/編集
                    </button>
                    <button id="btnAdminMenuReport" class="btn btn-outline btn-sm btn-compact" data-view-target="view-admin-report">
                        出欠結果一覧
                    </button>
                    <button id="btnAdminCustomPush" class="btn btn-outline btn-sm btn-compact" data-view-target="view-custom-push">
                        カスタム通知
                    </button>
                    <button id="btnSummary" class="btn btn-outline btn-sm btn-compact" data-view-target="view-summary">
                        サマリ
                    </button>
                    <button id="btnFeedback" class="btn btn-outline btn-sm btn-compact" data-view-target="view-feedback">
                        ご意見BOX
                    </button>
                </div>
                <div class="small muted" style="margin-top:6px;">※ 管理者のみ表示されます</div>
            </div>

            <!-- ★ トップ操作ボタン -->
                <div class="btnRow" aria-label="主操作">
                    <button id="btnPrimary" class="btn btn-primary btn-lg" data-view-target="view-form" disabled>
                    読み込み中…
                    </button>
                    <button id="btnSchedules" class="btn btn-outline btn-lg" data-view-target="view-schedules">
                    今後の予定
                    </button>
                    <button id="btnEditNames" class="btn btn-outline btn-lg" data-view-target="view-register" style="display:none;">
                    登録氏名編集
                    </button>
                </div>

            <!-- 互換性維持のためのダミー -->
                <button id="btnReload" type="button" style="display:none;"></button>

            <!-- 回答受付中の公演（密リスト＋バッジ） -->
                <div class="card" id="cardEventsActive">
                    <div class="row-space">
                        <div class="sectionTitle">回答受付中の公演</div>
                        <label id="homeOnlyNALabel" style="margin-left:auto;">
                            <input type="checkbox" id="homeOnlyNA" checked>
                            未定/未回答のみ表示
                        </label>
                        </div>
                    <div id="eventsBox">
                        <div class="muted">
                            読み込み中… <span class="spinner"></span>
                        </div>
                    </div>
                </div>

            <!-- あなたの登録状況（トップでは非表示） -->
                <div class="card" style="display:none;">
                    <div class="sectionTitle">あなたの登録状況</div>
                    <div id="answersBox" class="muted">
                    会員情報照会中… <span class="spinner"></span>
                    </div>
                </div>

            <!-- ★ 閲覧者用：今後の予定（直近5件） -->
            <div class="card" id="cardViewerUpcoming" style="display:none;">
            <div class="row-space">
                <div class="sectionTitle">今後の予定（直近5件）</div>
            </div>
            <div id="viewerEventsBox">
                <div class="muted">
                読み込み中… <span class="spinner"></span>
                </div>
            </div>
            </div>

            <div id="homeLog" class="muted" style="margin-top:8px;"></div>
        </section>

    <!-- ===== View: 出欠フォーム ===== -->
        <section id="view-form" data-view>
            <div class="row-space">
                <div class="sectionTitle">出欠入力フォーム</div>
                <button
                id="btnBackFromForm"
                class="btn btn-ghost btn-sm"
                data-view-target="view-home"
                type="button"
                >
                トップに戻る
                </button>
            </div>

            <div id="formEventsBox" class="muted guidePlain">
                公演読み込み中… <span class="spinner"></span>
            </div>

            <div id="formFields"></div>

            <div class="line"></div>

            <div class="row right">
                <button id="btnSubmit" class="btn btn-primary" disabled>
                まとめて送信
                </button>
            </div>

            <div id="formLog" class="muted" style="margin-top:8px;"></div>
            <div id="submitOverlay" class="overlay submitting-overlay" style="display:none;">
                <div class="overlay-inner">
                    <div class="spinner"></div>
                    <div class="overlay-text">送信中です…</div>
                </div>
            </div>
        </section>

    <!-- ===== View: 氏名登録・編集 ===== -->
        <section id="view-register" data-view>
            <div class="row-space">
                <div class="sectionTitle" id="regTitle">初回登録（入力者 &amp; 演奏者）</div>
                <button
                id="btnBackFromReg"
                class="btn btn-ghost btn-sm"
                data-view-target="view-home"
                type="button"
                >
                トップに戻る
                </button>
            </div>

            <div class="card">
                <label for="regInputName">入力者氏名（あなたの名前）</label>
                <input
                type="text"
                id="regInputName"
                placeholder="例：山田 太郎"
                />

                <label
                class="row"
                style="gap:6px; align-items:center; margin-top:6px;"
                >
                    <input type="checkbox" id="regNotify" />
                    <span class="small">
                        このアカウント宛てに通知（配信・リマインド）を送る
                    </span>
                </label>

                <div class="small muted" style="margin:2px 0 8px 24px;">
                ※通知をオフにすると、配信・リマインドは届きません（予定の閲覧は可能です）
                </div>

                <div class="line"></div>

                <!-- タイトル + 追加ボタン（余白をとるため regAddRow を付与） -->
                <div class="row-space regAddRow">
                    <div class="sectionTitle" style="margin:0;">
                        演奏者（家族も追加可）
                    </div>
                    <button
                        id="btnAddPerf"
                        class="btn btn-ghost btn-sm"
                        type="button"
                    >
                        ＋ 演奏者を追加
                    </button>
                </div>

                <!-- ※注意書き：タイトル直下へ移動 -->
                <div id="regNote" class="small muted">
                ※ あなた自身が演奏する場合は、演奏者としてあなたの名前も追加してください。
                </div>

                <!-- 演奏者入力リスト -->
                <div id="perfList"></div>
            </div>

            <div class="row right">
                <button id="btnRegister" class="btn btn-primary">
                登録する
                </button>
            </div>

            <div id="regLog" class="muted" style="margin-top:8px;"></div>

            <div id="regOverlay" class="overlay submitting-overlay" style="display:none;">
                <div class="overlay-inner">
                <div class="spinner"></div>
                <div class="overlay-text">保存中です…</div>
                </div>
            </div>
        </section>

    <!-- ===== View: 今後の予定一覧 ===== -->
        <section id="view-schedules" data-view>
            <div class="row-space">
                <div class="sectionTitle">今後の予定</div>
                <button
                id="btnBackFromSchedules"
                class="btn btn-ghost btn-sm"
                data-view-target="view-home"
                type="button"
                >
                トップに戻る
                </button>
            </div>

            <div class="card">
                <div class="schedControls">
                    <!-- 1行目：表示期間（日数） | プルダウン -->
                    <label for="selDays" class="scLabel">表示期間（日数）</label>
                    <select id="selDays" class="selectBtn schedSel short">
                        <option value="30">30日</option>
                        <option value="60" selected>60日</option>
                        <option value="90">90日</option>
                    </select>

                    <!-- 2行目：種別フィルタ | プルダウン -->
                    <label for="selKind" class="scLabel">種別フィルタ</label>
                    <select id="selKind" class="selectBtn schedSel short">
                        <option value="">（すべて）</option>
                        <option value="発表">発表</option>
                        <option value="練習">練習</option>
                        <option value="その他">その他</option>
                    </select>

                    <!-- 3行目：区分フィルタ（両方所属ユーザーのみ表示） -->
                    <label
                        for="selSeg"
                        class="scLabel"
                        id="labSeg"
                        style="display:none;"
                    >
                        区分フィルタ
                    </label>
                    <select
                        id="selSeg"
                        class="selectBtn schedSel short"
                        style="display:none;"
                    >
                        <option value="">（すべて）</option>
                        <option value="adult">大人の部</option>
                        <option value="child">子どもの部</option>
                    </select>

                    <!-- 下段：再取得ボタン（2列ぶち抜き） -->
                    <div class="span2">
                        <button
                        id="btnFetchSchedules"
                        class="btn btn-ghost btn-sm"
                        type="button"
                        >
                        更新
                        </button>
                    </div>
                </div>

                <div
                id="schedulesBox"
                class="muted"
                style="margin-top:8px;"
                >
                読み込み待機中
                </div>
            </div>
        </section>

    <!-- ===== View: 予定登録（管理者） ===== -->
        <section id="view-admin" data-view>
            <div class="row-space">
                <div class="sectionTitle">予定登録（管理者）</div>
                <button
                id="btnAdminBack"
                class="btn btn-ghost btn-sm"
                data-view-target="view-home"
                type="button"
                >
                トップに戻る
                </button>
            </div>

            <!-- 上段アコーディオン：現在登録中のイベント一覧 -->
            <div class="card fEvent" id="adminListAcc">
                <div
                class="fHead"
                style="display:flex; align-items:center; justify-content:space-between;"
                >
                <div class="sectionTitle" style="margin:0;">現在登録中のイベント一覧</div>
                <span class="small muted">タップで開閉</span>
                </div>

                <div class="fBody">
                    <!-- コントロール：ラベル｜プルダウン ×2（下段に再取得） -->
                    <div class="adminControls">
                        <label for="ad_days" class="admLabel">一覧の表示期間（日数）</label>
                        <select id="ad_days" class="selectBtn schedSel short">
                        <option value="30">30日</option>
                        <option value="60" selected>60日</option>
                        <option value="90">90日</option>
                        </select>

                        <label for="ad_seg_filter" class="admLabel">対象区分フィルタ</label>
                        <select id="ad_seg_filter" class="selectBtn schedSel short">
                        <option value="">（すべて）</option>
                        <option value="adult">大人</option>
                        <option value="child">子ども</option>
                        <option value="both">両方</option>
                        </select>

                        <!-- 下段：2列ぶち抜き -->
                        <div class="span2">
                        <button
                            id="btnAdminFetch"
                            class="btn btn-ghost btn-sm btn-compact"
                            type="button"
                        >
                            再取得
                        </button>
                    </div>
                </div>

                <!-- 一覧の描画先（アコーディオン内部） -->
                <div
                    id="adminListBoxTop"
                    class="muted"
                    style="margin-top:8px;"
                >
                    読み込み待機中
                </div>
            </div>
        </div>
        <!-- /上段アコーディオン -->

        <!-- 登録フォーム本体 -->
        <div class="card">
            <div class="row-space">
                <div class="sectionTitle" id="adminFormTitle">新規登録</div>
                <div class="small muted">
                    <span id="adminEditingId" style="display:none;"></span>
                </div>
            </div>

            <div class="adminGrid">
                <div>
                    <label for="ad_title">タイトル *</label>
                    <input
                    id="ad_title"
                    type="text"
                    placeholder="例：秋祭り演奏会"
                    />
                </div>

                <!-- 種別 *：placeholder + selectBtn -->
                <div>
                    <label for="ad_type">種別 *</label>
                    <select id="ad_type" class="selectBtn" required>
                        <option value="" disabled hidden selected>（選択）</option>
                        <option value="発表">発表</option>
                        <option value="練習">練習</option>
                        <option value="その他">その他</option>
                    </select>
                </div>

                <div>
                    <label for="ad_ymd">日付 *</label>
                    <input id="ad_ymd" type="date" />
                </div>

                <div>
                    <label for="ad_hm">時間（開始）</label>
                    <input
                    id="ad_hm"
                    type="time"
                    placeholder="HH:mm"
                    />
                </div>

                <div>
                    <label for="ad_place">場所</label>
                    <input
                    id="ad_place"
                    type="text"
                    placeholder="例：藤塚小体育館"
                    />
                </div>

                <div>
                    <label for="ad_meetAt">集合時間（発表・その他のみ）</label>
                    <input
                    id="ad_meetAt"
                    type="time"
                    placeholder="HH:mm"
                    />
                </div>

                <div>
                    <label for="ad_meetPlace">集合場所</label>
                    <input
                    id="ad_meetPlace"
                    type="text"
                    placeholder="例：藤塚小学校"
                    />
                </div>

                <!-- 対象区分 -->
                <div>
                    <label for="ad_segment">対象区分 *</label>
                    <select id="ad_segment" class="selectBtn" required>
                    <option value="子ども" selected>子ども</option>
                    <option value="大人">大人</option>
                    <option value="両方">両方</option>
                    </select>
                </div>

                <div>
                    <label for="ad_attendTarget">出欠対象（発表のみ）</label>
                    <select id="ad_attendTarget" class="selectBtn">
                    <option value="Y">Y</option>
                    <option value="N">N</option>
                    </select>
                </div>

                <div>
                    <label for="ad_deadline">締切日</label>
                    <input id="ad_deadline" type="date" />
                </div>

                <div>
                    <label for="ad_publish">公開</label>
                    <select id="ad_publish" class="selectBtn">
                    <option value="Yes">Yes</option>
                    <option value="No">No</option>
                    </select>
                </div>

                <div>
                    <label for="ad_status">ステータス</label>
                    <select id="ad_status" class="selectBtn">
                    <option value="active" selected>active</option>
                    <option value="archived">archived</option>
                    </select>
                </div>

                <div>
                    <label for="ad_flag">配信フラグ（必須：発表のみ）</label>
                    <select id="ad_flag" class="selectBtn">
                    <!-- 動的に差し替え -->
                    </select>
                </div>
            </div>

            <div class="hint" style="margin-top:6px;">
                * 必須。IDは自動採番です。<br />
                種別が「練習」の場合は集合時間/集合場所/締切日/配信フラグ無効化。<br />
                種別が「発表」以外では「出欠対象」は自動で N 固定になります。<br />
                「発表」の配信フラグは <b>新規登録時は Y/N のみ</b>、
                <b>編集時は Y/S/D/N</b> が選択可能です。
            </div>

            <div class="row right" style="margin-top:10px;">
                <button
                    id="btnAdminReset"
                    class="btn btn-ghost btn-sm"
                    type="button"
                >
                    新規モードに戻す
                </button>
                <button
                    id="btnAdminSubmit"
                    class="btn btn-primary"
                    type="button"
                >
                    新規登録
                </button>
            </div>

            <div
                id="adminFormLog"
                class="muted"
                style="margin-top:8px;"
            ></div>
        </div>

        <!-- 保存中オーバーレイ -->
        <div id="savingOverlay" class="saving-overlay" aria-hidden="true">
        <div class="saving-dialog">
            <div class="spinner"></div>
            <div id="savingOverlayMsg" class="saving-message">保存中…</div>
        </div>
        </div>
        </section>

    <!-- ===== View: 出欠結果一覧（管理者） ===== -->
        <section id="view-admin-report" data-view>
            <div class="row-space">
                <div class="sectionTitle">出欠結果一覧（管理者）</div>
                <button
                id="btnReportBack"
                class="btn btn-ghost btn-sm"
                data-view-target="view-home"
                type="button"
                >
                トップに戻る
                </button>
            </div>

            <div class="card">
                <!-- コントロール：ラベル右にプルダウン -->
                <div class="repControls">
                <label for="repEvent" class="repLabel">公演を選択</label>
                <select id="repEvent" class="selectBtn schedSel short">
                    <option value="">（選択してください）</option>
                </select>

                <label for="repAttend" class="repLabel">出欠フィルタ</label>
                <select id="repAttend" class="selectBtn schedSel short">
                    <option value="">（すべて）</option>
                    <option value="参加">参加</option>
                    <option value="欠席">欠席</option>
                    <option value="未定">未定</option>
                    <option value="未回答">未回答</option>
                </select>

                <!-- 下段：再取得ボタン（2列ぶち抜き） -->
                <div class="span2">
                    <button
                    id="btnReportReload"
                    class="btn btn-ghost btn-sm"
                    type="button"
                    >
                    更新
                    </button>
                </div>
            </div>
        </div>

            <div
                id="repBox"
                class="muted"
                aria-live="polite"
            >
                公演を選択してください
            </div>
        </section>
    <!-- ===== View: カスタム通知（管理者） ===== -->
        <section id="view-custom-push" data-view>

            <!-- 見出し行：左=タイトル / 右=トップに戻る -->
            <div class="row-space" style="align-items:center;">
                <div class="sectionTitle">カスタム通知</div>
                <button
                id="btnCustomBack"
                type="button"
                class="btn btn-ghost btn-sm"
                data-view-target="view-home"
                >
                トップに戻る
                </button>
            </div>

            <!-- カード本体：イベント選択〜本文入力まで -->
            <div class="card">

                <!-- 宛先の選び方（ラベル左／セレクト右） -->
                <div class="row-att" style="margin:6px 0 12px;">
                    <label for="cp_event" class="repLabel">宛先の選び方</label>
                    <select id="cp_event" class="selectBtn schedSel">
                        <option value="manual">手動のみで宛先を選ぶ</option>
                        <optgroup id="opt-events" label="イベントから選ぶ"></optgroup>
                    </select>
                </div>

                <!-- 対象ステータス（見出し＋チェック群） -->
                <div id="cp_stat_wrap" class="statWrap">
                    <div class="repLabel">
                        対象ステータス
                        <span id="cp_stat_lock" class="lockTag" hidden>手動モード（選択不可）</span>
                    </div>

                    <div class="row" style="gap:10px; margin-top:6px;">
                        <label><input type="checkbox" class="cp_stat" value="参加"> 参加</label>
                        <label><input type="checkbox" class="cp_stat" value="未定"> 未定</label>
                        <label><input type="checkbox" class="cp_stat" value="未回答"> 未回答</label>
                        <label><input type="checkbox" class="cp_stat" value="欠席"> 欠席</label>
                    </div>
                </div>

                <!-- 宛先追加（手動） ラベル左 / セレクト右 -->
                <div class="row-att" id="cp_extra_row" style="margin:12px 0;">
                    <label for="cp_extra" class="repLabel">宛先追加（手動）</label>
                    <select id="cp_extra" class="selectBtn" multiple>
                        <option value="">選択してください</option>
                    </select>
                    <!-- 下段フル幅で表示 -->
                    <div class="row-att-note">
                        <span id="cp_extra_hint" class="loadingHint" hidden>（読み込み中…）</span>
                    </div>
                </div>

                <!-- 自動選択 / 手動追加（表示のみ・薄紫） -->
                <div class="cp-pill">
                    <div class="cp-pill-title">宛先（自動選択）</div>
                    <div class="cp-pill-body" id="cp_auto" aria-live="polite">（該当なし）</div>
                </div>
                <div class="cp-pill" id="cp_manual_wrap">
                    <div class="cp-pill-title">宛先（手動選択）</div>
                    <div class="cp-pill-body" id="cp_manual" aria-live="polite">（未選択）</div>
                </div>

                <!-- 手動追加とテンプレの間に1行分の空白 -->
                <div class="cp-space-1line"></div>

                <!-- テンプレート -->
                <div class="row-att" style="margin:6px 0 12px;">
                    <label for="cp_tpl" class="repLabel">テンプレート</label>
                    <select id="cp_tpl" class="selectBtn">
                        <option value="">なし</option>
                        <option value="雨天中止">雨天中止時</option>
                        <option value="時間変更">時間変更時</option>
                    </select>
                </div>

                <!-- 本文 -->
                <div class="cp-field">
                    <label for="cp_body" class="repLabel">本文（2000文字まで）</label>
                    <textarea
                        id="cp_body"
                        rows="7"
                        maxlength="2000"
                        class="cp-textarea"
                    ></textarea>
                    <div class="hint" id="cp_count">0 / 2000</div>
                </div>

                <!-- アクション -->
                <div class="row" style="gap:10px; justify-content:flex-end;">
                    <button id="cp_reset" class="btn btn-ghost" type="button">リセット</button>
                    <button id="cp_send"  class="btn btn-primary" type="button">送信する</button>
                </div>
            </div><!-- /card -->
        </section>



    <!-- ===== View: サマリ（管理者）===== -->
        <section id="view-summary" data-view>
            <!-- 見出し行：左=タイトル / 右=トップに戻る -->
            <div
                class="summaryHeaderRow"
                style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;"
            >
                <div class="pageTitle" style="margin:0;">サマリ</div>
                <button
                id="btnSummaryToTop"
                class="btn btn-outline btn-sm btn-compact"
                type="button"
                data-view-target="view-home"
                >
                トップに戻る
                </button>
            </div>

            <!-- タブ風ボタン + コンテンツ -->
            <div class="card">
                <!-- タブ風ボタン -->
                <div class="row" style="gap:8px;margin-bottom:8px;">
                <button
                    id="btnSummaryFreeQuota"
                    class="btn btn-primary btn-sm btn-compact"
                    type="button"
                >
                    無料枠確認
                </button>
                <button
                    id="btnSummaryPushStats"
                    class="btn btn-outline btn-sm btn-compact"
                    type="button"
                >
                    配信履歴
                </button>
            </div>

            <!-- 無料枠 -->
            <div id="summaryFreeQuotaBox" class="summaryCard">
                <div class="small muted">読み込み待機中…</div>
            </div>

            <!-- 配信履歴 -->
            <div id="summaryPushStatsBox" class="summaryCard" style="display:none;">
                <div class="small muted">読み込み待機中…</div>
            </div>

            <!-- 再取得ボタン -->
            <div class="row" style="gap:8px;margin-top:10px;">
                <button
                    id="btnSummaryReload"
                    class="btn btn-outline btn-sm btn-compact"
                    type="button"
                >
                    再取得
                </button>
            </div>

            <!-- 説明文 -->
            <div class="small muted" style="margin-top:6px;">
                ※ 「無料枠確認」は<strong>このシステム（Messaging API経由）</strong>で送信した今月の利用状況を表示します。<br>
                ※ Official Accountアプリからの手動配信や、あいさつ／自動応答メッセージは<strong>含まれません</strong>。<br>
                ※ 「配信履歴」は Pushlog / PushDetail をもとに当月の集計を表示します。
            </div>
        </div>
        </section>

    <!-- ===== View: ご意見BOX（管理者）===== -->
        <section id="view-feedback" data-view>
            <div
                class="fbHeaderRow"
                style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;"
            >
                <div class="pageTitle" style="margin:0;">ご意見BOX</div>
                <button
                id="btnFeedbackBack"
                class="btn btn-outline btn-sm btn-compact"
                type="button"
                data-view-target="view-home"
                >
                トップに戻る
                </button>
            </div>

            <div class="card">
                <div class="row header">
                <div class="sectionTitle">受信一覧（カテゴリ別）</div>
                <button
                    id="fbReload"
                    class="btn btn-ghost btn-sm"
                    type="button"
                >
                    再読込
                </button>
                </div>

                <div id="feedbackListBox">読み込み中…</div>
            </div>

            <div class="toolbar">
                <button id="fbSave" class="btn btn-primary btn-sm">変更を保存</button>
            </div>
        </section>
</main>

<!-- ===== Global: フッター（法的リンク） ===== -->
  <footer
        id="legalFooter"
        class="siteFooter legal-footer"
        aria-label="法的情報へのリンク"
    >
        <a
            href="https://fujizukadaiko.github.io/taiko-liff-form-prod/privacy.html"
            target="_blank"
            rel="noopener"
        >
            プライバシーポリシー
        </a>
        <span class="dot">・</span>
        <a
            href="https://fujizukadaiko.github.io/taiko-liff-form-prod/terms.html"
            target="_blank"
            rel="noopener"
        >
            利用規約
        </a>
    </footer>

<!-- ===== Global: ご意見ボタン（FAB） ===== -->
    <button
        id="feedbackFab"
        class="fab"
        type="button"
        aria-label="ご意見BOX"
        aria-haspopup="dialog"
        aria-controls="feedbackModal"
    >
        <img src="./assets/feedback.svg" alt="" />
        <span class="sr-only">ご意見BOX</span>
    </button>
    
<!-- ===== Global Modal: ご意見BOX ===== -->
    <div
        id="feedbackModal"
        class="modal"
        hidden
    >
        <div class="modal-backdrop" data-close="1"></div>

        <div
            class="modal-card"
            role="dialog"
            aria-modal="true"
            aria-labelledby="fbTitle"
        >
            <div class="modal-header">
                <div id="fbTitle" class="modal-title">ご意見BOX</div>
                <button
                    class="icon-btn"
                    data-close="1"
                    type="button"
                    aria-label="閉じる"
                >
                    ×
                </button>
            </div>

            <div class="modal-body">
                <label class="label">カテゴリ（任意）</label>
                <select id="fbCategory" class="select">
                    <option value="その他" selected>その他</option>
                    <option value="要望">要望</option>
                    <option value="不具合">不具合</option>
                    <option value="デザイン">デザイン</option>
                </select>

                <label class="label" style="margin-top:10px;">メッセージ（必須）</label>
                <textarea
                    id="fbMessage"
                    class="textarea"
                    rows="5"
                    maxlength="300"
                    placeholder="ご意見・ご要望をお聞かせください"
                ></textarea>

                <div class="counter">
                    <span id="fbCount">0</span> / 300
                </div>
            </div>

            <div class="modal-footer">
                <button
                    class="btn btn-outline"
                    data-close="1"
                    type="button"
                >
                    キャンセル
                </button>
                <button
                    id="fbSendBtn"
                    class="btn btn-primary"
                    type="button"
                >
                    送信
                </button>
            </div>
        </div>
    </div>
    
<!-- ===== Global: スナックバー ===== -->
    <div
        id="snackbar"
        class="snackbar"
        role="status"
        aria-live="polite"
    ></div>
  
<!-- ===== Global Modal: 更新履歴 ===== -->
    <div
        id="changelogModal"
        class="modal"
        hidden
    >
        <div class="modal-backdrop" data-close="1"></div>

        <div
            class="modal-card"
            role="dialog"
            aria-modal="true"
            aria-labelledby="cgTitle"
        >
            <div class="modal-header">
                <div id="cgTitle" class="modal-title">更新履歴</div>
            </div>

            <div class="modal-body">
                <div id="changelogList" class="cg-list"></div>
            </div>

            <div class="modal-footer">
                <button
                    class="btn btn-outline"
                    data-close="1"
                    type="button"
                >
                    閉じる
                </button>
            </div>
        </div>
    </div>



<!-- ===== 回答受付中の公演リスト設定 v7 ===== -->
<script>
    (function(){
        if (window.HomeEventsUI && window.HomeEventsUI.__v === 7) return;
    
        /* 状態 */
        const S = {
            events: [],          // [{id, ymd, hm, place, deadline, isNew, segment}]
            ansMap: {},          // { eventId: [{name, answer}] }
            names : [],          // 登録演奏者
            onlyNA: true,
            nameSegMap: {},      // { [name]: 'adult'|'child' }
            isViewer: false,     // ★ 閲覧者フラグ
            membersRaw: [],      // ★ 追加：生のメンバーデータを保持
            allEvents: [],       // ★ 追加：今後の予定（発表+練習など全部）
        };
                
        /* 参照 */
        const E = {
        box : () => document.getElementById('eventsBox'),
        ckN : () => document.getElementById('homeOnlyNA'),
        viewerBox  : () => document.getElementById('viewerEventsBox'),
        cardActive : () => document.getElementById('cardEventsActive'),
        cardViewer : () => document.getElementById('cardViewerUpcoming'),
        };
    
        /* Util */
        function parseYmd(s){
        const str = String(s || "").trim();
        if (!str) return null;
        
        let y, m, d;
        
        // ① 8桁（20260111）
        const m8 = str.match(/^(\d{4})(\d{2})(\d{2})$/);
        if (m8) {
            y = +m8[1]; m = +m8[2]; d = +m8[3];
        } else {
            // ② 2026-01-11 / 2026/01/11
            const m2 = str.match(/^(\d{4})[\/\-](\d{2})[\/\-](\d{2})$/);
            if (!m2) return null;
            y = +m2[1]; m = +m2[2]; d = +m2[3];
        }
        
        const dt = new Date(y, m - 1, d);
        if (isNaN(dt)) return null;
        dt.setHours(0,0,0,0);
        return dt;
        }

        function isPastDeadline(ev){
            // ev.deadline / ev.limit / ev.deadlineYmd のどれかに締切が入っている想定
            const raw = ev.deadline || ev.limit || ev.deadlineYmd || "";
            const d = parseYmd(raw);
            if (!d) return false;  // 締切未設定 → 「受付中」とみなして表示する

            const today = new Date();
            today.setHours(0,0,0,0);     // 今日 0:00
            return d < today;            // 締切日が「今日より前」なら締切済み
        }

        function deadlineClass(deadlineStr){
        const d = parseYmd(deadlineStr); if (!d) return '';
        const today = new Date(); today.setHours(0,0,0,0);
        const diff = Math.floor((d - today)/86400000);
        return (diff <= 3) ? 'deadline-soon' : '';
        }

        function ansClass(v){
        if (!v || v === '未回答') return 'stat-na';
        if (v === '未定')        return 'stat-pd';
        if (v === '参加')        return 'stat-ok';
        if (v === '欠席')        return 'stat-ng';
        return 'stat-na';
        }
    
        function summarizeForEvent(ev){
        const evSeg = normSeg(ev.segment || ev.targetSegment || ev.attendSegment || '');
        const answers = Array.isArray(S.ansMap[ev.id]) ? S.ansMap[ev.id] : [];
        const byName = new Map(answers.map(a => [String(a?.name || a?.member || ''), a]));

        const eligible = S.names.filter(n => matchSeg(S.nameSegMap[n], evSeg));

        const total = eligible.length;
        if (total === 0) return { label:'未回答', cls:'stat-na', key:'na' }; // 念のため

        let missing = 0, hasPending = false, decidedCnt = 0;
        for (const n of eligible){
        const rec = byName.get(n);
        if (!rec){ missing++; continue; }
        const v = (rec.answer || '').trim();
        if (v === '未定') hasPending = true;
        if (v === '参加' || v === '欠席') decidedCnt++;
            }

            if (missing > 0)        return { label:'一部未回答', cls:'stat-pd', key:'partial' };
                if (hasPending)         return { label:'未定あり',   cls:'stat-pd', key:'pending' };
                if (decidedCnt === 0)   return { label:'未回答',     cls:'stat-na', key:'na' };
                if (decidedCnt === total) return { label:'回答済',   cls:'stat-ok', key:'done' };
                return { label:'一部未回答', cls:'stat-pd', key:'partial' };
        }
    
        function rowHtml(ev, sum){
        // 元データ（D1/GAS 両対応）
        const rawYmd = ev.ymd || ev.date || "";
        const rawHm  = ev.hm || ev.time || ev.performAt || ev["時間"] || "";
        const place  = ev.place || ev.venue || "";
        
        // 表示用フォーマット
        const ymdDisp = fmtYmd(rawYmd);          // "2026/01/11（日）"
        const hmDisp  = fmtTime(rawHm);          // "14:00"
        const atMark  = place ? " @" : "";
        
        // タイトル行に出す文字列
        const titleText = hmDisp
            ? `${ymdDisp} ${hmDisp}${atMark} ${place}`
            : `${ymdDisp}${atMark} ${place}`;
        
        const dateLineHtml = hmDisp
            ? `${ymdDisp} <small>${hmDisp}</small>${atMark}`
            : `${ymdDisp}${atMark}`;
        
        const newBadge = (ev.isNew || ev.is_new)
            ? '<span class="badge-new">NEW</span>'
            : "";
        
        // 締切
        const rawDl = ev.deadline || ev.limit || ev.deadlineYmd || "";
        const dlDisp = fmtYmdNoWeekday(rawDl);   // "2026/01/11"
        const dlCls  = `deadline ${deadlineClass(rawDl)}`;
        
        // 区分（左）バッジ
        const segNorm  = normSeg(ev.segment || "");
        const segLbl   = dispSeg(segNorm);
        const segCls   = segNorm === "adult" ? "seg-adult"
                        : segNorm === "child" ? "seg-child"
                        : "seg-both";
        const segBadge = segLbl
            ? `<span class="seg-badge ${segCls}">${segLbl}</span>`
            : "";
        
        return `
            <div class="eventRow" data-evt="${ev.id}" data-seg="${segNorm || "both"}">
            <div class="eventMeta">
                <!-- 1行目：左=区分 / 右=回答ステータス + NEW -->
                <div class="eventHead">
                <div class="eventHead-left">${segBadge}</div>
                <div class="eventHead-right">
                    <span class="pill sm ${sum.cls}">${sum.label}</span>
                    ${newBadge}
                </div>
                </div>
        
                <!-- 2行目：日付 時刻 @ 場所 -->
                <div class="eventTitle" title="${titleText}">
                <span class="title-date">${dateLineHtml}</span>
                <span class="title-place">${place}</span>
                </div>
        
                <!-- 3行目：締切 -->
                <div class="eventSub">
                締切：<span class="${dlCls}">${dlDisp || "—"}</span>
                </div>
            </div>
            </div>
            <div class="eventDetail" data-detail="${ev.id}"></div>
        `;
        }
    
        function render(){
            const box = E.box(); 
            if (!box) return;

            console.log("[home] render: S.isViewer =", S.isViewer);

            const cardActive = E.cardActive();
            const cardViewer = E.cardViewer();

            if (S.isViewer) {
                // 閲覧者：回答受付中カードは非表示、代わりに今後の予定カードを描画
                if (cardActive) cardActive.style.display = "none";
                if (cardViewer) cardViewer.style.display = "";
                renderViewerUpcoming();
                return;  // ここで終わり
            } else {
                // 演者・管理者：閲覧者用カードは隠し、従来のリストを描画
                if (cardActive) cardActive.style.display = "";
                if (cardViewer) cardViewer.style.display = "none";
            }

            // ==== ここから下は今まで通りの「回答受付中の公演」描画 ====
            // ★ ここで「締切を過ぎた公演」は除外する
            const activeEvents = (S.events || []).filter(ev => !isPastDeadline(ev));

            const list = activeEvents.slice().sort((a,b) => {
                const da = parseYmd(a.ymd || a.date) || new Date(8640000000000000);
                const db = parseYmd(b.ymd || b.date) || new Date(8640000000000000);
                return da - db;
            });

            const rows = [];
            for (const ev of list){
                const sum = summarizeForEvent(ev);
                if (S.onlyNA && !(sum.key === 'na' || sum.key === 'partial' || sum.key === 'pending')) continue;
                rows.push(rowHtml(ev, sum));
            }
            box.innerHTML = rows.length
                ? `<div class="evList">${rows.join('')}</div>`
                : '<div class="listEmpty">該当する公演はありません</div>';
    
        // 詳細: 家族別チップ
        box.querySelectorAll('.eventRow').forEach(row => {
            row.addEventListener('click', (e) => {
            if (e.target.closest('.pill, .badge-new, .seg-badge')) return;
            const id  = row.getAttribute('data-evt');
            const det = box.querySelector(`.eventDetail[data-detail="${id}"]`);
            if (!det) return;
            if (det.dataset.loaded !== '1'){
                const arr = S.ansMap[id] || [];
                det.innerHTML = `
                    <div class="row" style="gap:6px; flex-wrap:wrap; padding:4px 2px 0 2px;">
                        ${arr.map(m => {
                            const nameRaw = m?.name || m?.member || '';
                            const name    = (nameRaw || '').trim();
                            const vRaw    = (m?.answer ?? '').trim();
                            const v       = vRaw || '未回答';              // 空なら「未回答」に統一
                            const label   = name ? `${name}:${v}` : v;     // 「名前:結果」 or 結果だけ

                            return `<span class="pill sm ${ansClass(v)}" title="${v}">${label}</span>`;
                        }).join('')}
                    </div>`;
                det.dataset.loaded = '1';
            }
            row.classList.toggle('open');
            det.style.display = (det.style.display === 'block') ? 'none' : 'block';
            });
        });
        }
    
        // 未回答のみチェック
        document.addEventListener('DOMContentLoaded', () => {
        const n = E.ckN();
        if (n){
            n.checked = true;
            S.onlyNA  = true;
            n.addEventListener('change', () => { S.onlyNA = !!n.checked; render(); });
        }
        });
    
        /* 公開API */
            const API = {
            __v: 7,
            mount({
                events = [],
                allEvents = [],      // ★ 追加
                myAnswersMap = {},
                performers = [],
                nameSegMap = {},
                isViewer,
                members,            // ★ 追加済み
            } = {}){
                console.log("[home] API.mount called:", {
                isViewerArg: isViewer,
                membersLen: Array.isArray(window.state?.members) ? window.state.members.length : 0,
                membersArgLen: Array.isArray(members) ? members.length : 0,
                });

                S.events     = Array.isArray(events) ? events : [];
                S.allEvents  = Array.isArray(allEvents) && allEvents.length
                     ? allEvents
                     : S.events;  // ★ allEvents が無ければ events を流用
                S.ansMap     = myAnswersMap || {};
                S.names      = Array.isArray(performers) ? performers : [];
                S.nameSegMap = nameSegMap || {};
                if (Array.isArray(members)) {
                S.membersRaw = members;
                }

                // ★ 閲覧者フラグの決定
                if (typeof isViewer === "boolean") {
                // ① 引数で明示的に渡された場合
                S.isViewer = isViewer;
                } else {
                // ② members / state.members から判定を試みる
                const srcMembers =
                    Array.isArray(members) ? members :
                    (window.state && Array.isArray(window.state.members) ? window.state.members :
                    S.membersRaw);

                if (Array.isArray(srcMembers) && srcMembers.length) {
                    console.log("[home] mount members sample:", srcMembers[0]);
                    S.isViewer = srcMembers.some(m => {
                    const v = String(m.viewer || m.閲覧者 || "").trim().toUpperCase();
                    return v === "Y";
                    });
                } else {
                    // ③ members 情報が一切無いときのフォールバック
                    //    → 演奏者リストが 0 人 かつ 管理者ではないなら「閲覧者扱い」
                    const isAdmin = !!(window.state && window.state.isAdmin);
                    if (!isAdmin && Array.isArray(S.names) && S.names.length === 0) {
                    S.isViewer = true;
                    } else {
                    S.isViewer = false;
                    }
                    console.log("[home] mount fallback by performers:", {
                    isAdmin,
                    performersLen: Array.isArray(S.names) ? S.names.length : -1,
                    decidedViewer: S.isViewer,
                    });
                }
                }

                console.log("[home] mount: S.isViewer decided =", S.isViewer);

                const n = E.ckN();
                if (n) S.onlyNA = !!n.checked;
                render();
            },
            setEvents(e){ S.events = e || []; render(); },
            setAnswers(a){ S.ansMap = a || {}; render(); },
            setPerformers(arr){ S.names = Array.isArray(arr) ? arr : []; render(); },
            render,
            };
        window.HomeEventsUI = API;
        window.renderEventsDense = API.mount;
    
        // 自動ブート（既存互換はそのまま）
        function tryMountFromGlobals(){
        const ev = window.__HOME_EVENTS__;
        const mp = window.__HOME_ANSWERS__;
        const nm = window.__HOME_MEMBERS__ || [];
        if (Array.isArray(ev) && mp && typeof mp === 'object'){
            API.mount({ events: ev, myAnswersMap: mp, performers: nm });
            return true;
        }
        return false;
        }

        window.addEventListener('home:data', (e)=>{
            const d = e.detail || {};

            console.log("[home] home:data keys =", Object.keys(d || {}));
            console.log("[home] home:data sample schedules[0] =", d.schedules && d.schedules[0]);
            console.log("[home] home:data sample allEvents[0] =", d.allEvents && d.allEvents[0]);

            // members が detail に乗ってくる場合はこちらから、
            // 無ければ state.members から
            const members =
                d.members ||
                (window.state && Array.isArray(window.state.members) ? window.state.members : []);

            let isViewer = false;
            if (Array.isArray(members)) {
                console.log("[home] home:data members sample:", members[0]);
                isViewer = members.some(m => {
                const v = String(m.viewer || m.閲覧者 || "").trim().toUpperCase();
                return v === "Y";
                });
            }

            console.log("[home] home:data computed isViewer =", isViewer);

            API.mount({
                events      : d.events || [],
                allEvents   : d.allEvents                   // ★ ここを実データに合わせて
                  || d.schedules                // 例えばこんな候補…
                  || d.upcomingEvents
                  || [],
                myAnswersMap: d.myAnswersMap || {},
                performers  : d.performers || [],
                nameSegMap  : d.nameSegMap || {},
                members,          // ★ 追加
                isViewer,         // ★ 追加
            });
            });

        // if (!tryMountFromGlobals()){
        // let waited = 0;
        // const iv = setInterval(()=>{
        //    if (tryMountFromGlobals()) { clearInterval(iv); }
        //    else if ((waited += 300) > 5000) { clearInterval(iv); }
        // }, 300);
        // }
    
        // ブリッジ関数（互換）
        window.renderHomeFromRaw = function(openList, myFamilyAnswers, membersArray){
            try {
                const events = (openList || []).map(x => ({
                id      : x.id ?? x.eventId ?? x.eid ?? '',
                ymd     : x.ymd ?? x.date ?? '',
                hm      : x.hm ?? x.time ?? x['時間'] ?? '',
                place   : x.place ?? x.venue ?? x.location ?? '',
                deadline: x.deadline ?? x.limit ?? x.deadlineYmd ?? '',
                isNew   : (x.isNew === true) || (x.is_new === 'Y') || (x.new === true),
                segment : x.segment || x.targetSegment || x.attendSegment || x.segmentCode || ""
                }));

                const map = {};
                for (const a of (myFamilyAnswers || [])){
                const eid = a.eventId ?? a.id ?? a.eid ?? '';
                if (!eid) continue;
                if (!map[eid]) map[eid] = [];
                map[eid].push({ name: a.name ?? a.member ?? '', answer: (a.answer ?? '').trim() || '未回答' });
                }

                const members =
                membersArray ||
                (window.state && Array.isArray(window.state.members) ? window.state.members : []);

                console.log("[home] renderHomeFromRaw members sample:", members[0]);

                const performers = Array.from(new Set(members.map(m => m.performerName).filter(Boolean)));
                const nameSegMap = {};
                members.forEach(m => {
                const n = (m.performerName||'').trim();
                const s = normSeg(m.segment || m.区分 || '');
                if (n && s) nameSegMap[n] = s;
                });

                const isViewer = Array.isArray(members) && members.some(m => {
                const v = String(m.viewer || m.閲覧者 || "").trim().toUpperCase();
                return v === "Y";
                });

                console.log("[home] renderHomeFromRaw isViewer =", isViewer);

                window.__HOME_EVENTS__   = events;
                window.__HOME_ANSWERS__  = map;
                window.__HOME_MEMBERS__  = performers;

                window.renderEventsDense({
                events,
                myAnswersMap: map,
                performers,
                nameSegMap,
                members,    // ★ 追加
                isViewer,   // ★ 追加
                });
            } catch (err){
                console.error('renderHomeFromRaw failed:', err);
            }
            };

        function renderViewerUpcoming(){
            const card = E.cardViewer();
            const box  = E.viewerBox();
            if (!card || !box) return;

            card.style.display = "";

            const today = new Date();
            today.setHours(0,0,0,0);

            // ★ どの配列をベースにするか決める（優先順位を変更）
            const hasGlobal = Array.isArray(window.__ALL_SCHEDULES__) && window.__ALL_SCHEDULES__.length > 0;
            const hasAll    = Array.isArray(S.allEvents) && S.allEvents.length > 0;
            const hasEvents = Array.isArray(S.events) && S.events.length > 0;

            const base =
                hasGlobal ? window.__ALL_SCHEDULES__ :
                hasAll    ? S.allEvents :
                hasEvents ? S.events :
                            [];

            console.log("[home] viewerUpcoming: lengths", {
                S_allEvents: hasAll ? S.allEvents.length : null,
                globalSchedules: hasGlobal ? window.__ALL_SCHEDULES__.length : null,
                S_events: hasEvents ? S.events.length : null,
            });
            console.log("[home] viewerUpcoming: using base =",
                hasGlobal ? "__ALL_SCHEDULES__" :
                hasAll    ? "S.allEvents" :
                hasEvents ? "S.events" : "[]"
            );
            console.log("[home] viewerUpcoming: base[0] sample =", base[0]);

            const upcoming = base
                .map(ev => {
                    const dt = parseYmd(ev.ymd || ev.date);
                    return { ev, dt };
                })
                .filter(x => x.dt && x.dt >= today)
                .sort((a,b) => a.dt - b.dt)
                .slice(0,5)
                .map(x => x.ev);

            if (!upcoming.length){
                box.innerHTML = '<div class="listEmpty">直近の予定はありません</div>';
                return;
            }

            box.innerHTML = `
                <div class="evList">
                ${upcoming.map(ev => viewerRowHtml(ev)).join("")}
                </div>
            `;
        }

            function getKindInfo(ev){
            // ★ 種別フィールドを推測して拾う（実データに合わせて調整OK）
            const raw =
                ev.kind ||
                ev.type ||
                ev.category ||
                ev.eventType ||
                ev.種別 ||
                ev.種目 ||
                "";
            const s = String(raw).trim();
            if (!s) return { label: "", cls: "" };

            const lower = s.toLowerCase();

            if (lower.includes("練") || lower.includes("practice")) {
                // ★ 今後の予定と同じクラス名を返す
                return { label: "練習", cls: "badge--practice" };
            }
            if (lower.includes("発") || lower.includes("本番") || lower.includes("stage")) {
                return { label: "発表", cls: "badge--announce" };
            }
            return { label: s, cls: "badge--other" };
        }

            function viewerRowHtml(ev){
                const rawYmd = ev.ymd || ev.date || "";
                const rawHm  = ev.hm || ev.time || ev.performAt || ev["時間"] || "";

                const place  = ev.place || ev.venue || ev.location || "";

                // ★ イベント名（なければ場所をタイトルに使う）
                const titleRaw =
                    ev.title ||
                    ev.eventTitle ||
                    ev.name ||
                    ev.eventName ||
                    "";
                const title = (titleRaw || "").trim() || place;

                const ymdDisp = fmtYmd(rawYmd);
                const hmDisp  = fmtTime(rawHm);

                const titleText = hmDisp
                    ? `${ymdDisp} ${hmDisp} ${title}`
                    : `${ymdDisp} ${title}`;

                const dateLineHtml = hmDisp
                    ? `${ymdDisp} <small>${hmDisp}</small>`
                    : `${ymdDisp}`;

                // 区分バッジ
                const segNorm  = normSeg(ev.segment || "");
                const segLbl   = dispSeg(segNorm);
                const segCls   = segNorm === "adult" ? "seg-adult"
                                : segNorm === "child" ? "seg-child"
                                : "seg-both";
                const segBadge = segLbl
                    ? `<span class="seg-badge ${segCls}">${segLbl}</span>`
                    : "";

                // 種別バッジ（発表 / 練習）
                const kindInfo  = getKindInfo(ev);
                const kindBadge = kindInfo.label
                    ? `<span class="kind-badge ${kindInfo.cls}">${kindInfo.label}</span>`
                    : "";

                return `
                    <div class="eventRow" data-evt="${ev.id}" data-seg="${segNorm || "both"}">
                        <div class="eventMeta">
                            <!-- 1行目：左=区分 / 右=種別 -->
                            <div class="eventHead">
                                <div class="eventHead-left">
                                    ${segBadge}
                                </div>
                                <div class="eventHead-right">
                                    ${kindBadge}
                                </div>
                            </div>

                            <!-- 2行目：日付 時刻 + イベント名 -->
                            <div class="eventTitle" title="${titleText}">
                                <span class="title-date">${dateLineHtml}</span>
                                <span class="title-place">${title}</span>
                            </div>
                        </div>
                    </div>
                `;
            }
    })();
</script>

<script>
/* ===== アプリ共通ステート（全画面で共有する状態） ===== */
    let state = {
    lineId: "",
    name: "",
    inputName: "",      // ★ 追加：LINE表示名とは別の「入力者氏名」
    isAdmin: false,
    members: [],       // [{lineId,inputName,performerName}]
    events:  [],       // [{eventId,date,time,place,deadline,initialAt,isNew}]
    answers: {},       // { eventId: [...] }
    schedules: [],     // 今後の予定
    report:   [],      // 管理レポート（attendanceReport）
    schedulesRaw: [],   // ← API生データを保持（ローカル再描画で使用）
    adminItemsRaw: [],  // ← 一覧の生データ
    submitting: false, 
    notify: true,        // ★ 追加：既定は ON
    reportMeta: [],          // 管理レポート用：軽量メタ一覧（meta=1）
    reportDetailMap: {},     // { [eventId]: 詳細レスポンス } のキャッシュ
    };

    let registerMode = "create"; // "create" | "edit"
    let adminMode = "create";    // "create" | "edit"（予定登録フォーム）
    let adminEditingId = "";     // 編集対象ID
    let adminItemsMap = {};      // 管理一覧の行データを保持するマップ（編集ボタンから参照）

/* ===== ドラフト（一時保存） ===== */
    /* 保存スコープは lineId 単位。localStorage に永続化します */
    let draft = { byEvent: {} }; // { [eventId]: { members: { [name]: "参加|欠席|未定|"" }, comment: "" } }

    function draftStorageKey(){
    return `attDraft:${state.lineId || 'guest'}`;
    }
    function draftLoad(){
    try {
        const raw = localStorage.getItem(draftStorageKey());
        draft = raw ? JSON.parse(raw) : { byEvent:{} };
    } catch(_){
        draft = { byEvent:{} };
    }
    }
    function draftSave(){
    try { localStorage.setItem(draftStorageKey(), JSON.stringify(draft)); } catch(_){}
    }
    function draftClear(){
    draft = { byEvent:{} };
    draftSave();
    }
    function draftEnsure(evId){
    if (!draft.byEvent[evId]) {
        draft.byEvent[evId] = { members:{}, comment:"", commentTouched:false };
    } else {
        // 旧データからのマイグレーション（プロパティが無い場合に補完）
        if (!('commentTouched' in draft.byEvent[evId])) {
        draft.byEvent[evId].commentTouched = false;
        }
    }
    return draft.byEvent[evId];
    }
    function draftSetAttend(evId, name, attend){
    const d = draftEnsure(String(evId));
    if (attend) d.members[name] = attend; else delete d.members[name];
    draftSave();
    }
    function draftSetComment(evId, comment){
    const d = draftEnsure(String(evId));
    d.comment = comment || "";
    d.commentTouched = true;   // ★ コメントを触った（削除含む）ことを記録
    draftSave();
    }
    function draftGetAttend(evId, name){
    const d = draft.byEvent[String(evId)];
    return d && d.members ? (d.members[name] || "") : "";
    }
    function draftGetComment(evId){
    const d = draft.byEvent[String(evId)];
    return d ? (d.comment || "") : "";
    }

    // 現在の state.events から「存在する eventId 集合」を作る
        function getOpenEventIdSet(){
        return new Set((state.events||[]).map(e => String(e.eventId ?? e.id ?? "")));
        }

    // 画面に存在しない（=終了/削除された）イベントのドラフトを掃除する
        function pruneDraftAgainstCurrentEvents(){
        const allow = getOpenEventIdSet();
        const byEv = draft.byEvent || {};
        let removed = 0;
        for (const k of Object.keys(byEv)){
            if (!allow.has(String(k))){
            delete byEv[k];
            removed++;
            }
        }
        if (removed > 0){
            draftSave();
            updateSubmitButton();
            console.info(`[draft] pruned ${removed} stale drafts`);
        }
        return removed;
        }
  
    // フロントのドラフト構造 → API に投げる形 に変換  
        function draftBuildPayloads(){
        // 送信直前に「今あるイベントID以外は送らない」二重安全策
        const allowed = getOpenEventIdSet();

        const result = [];
        for (const [eventId, block] of Object.entries(draft.byEvent || {})){
            if (!allowed.has(String(eventId))) continue;     // ← 終了/削除されたIDは破棄

            const names   = Object.keys(block.members || {});
            const touched = !!block.commentTouched;
            if (names.length === 0 && !touched) continue;    // 何も変更なしは送らない

            const com = block.comment || "";
            names.forEach((name, idx) => {
            const payload = { eventId, performerName: name, attend: block.members[name] || "" };
            if (touched && idx === 0) payload._eventComment = com; // コメントは先頭1件だけ
            result.push(payload);
            });
        }
        return result;
        }

/* ===== 送信用補助（未保存バッジ/送信ボタン活性） ===== */
    function hasAnyDraft(){
    const b = draft.byEvent || {};
    return Object.values(b).some(block =>
        (Object.keys(block.members || {}).length > 0) ||
        ((block.comment || "").trim() !== "")
    );
    }
    function markUnsavedBadge(eventId){
    const card = document.querySelector(`.fEvent[data-evt="${eventId}"]`);
    if (!card) return;
    const headRow = card.querySelector(".fTitleRow");
    if (!headRow) return;
    const cur = headRow.querySelector(".badge-unsaved");
    const dblock = draft.byEvent[String(eventId)];
    const need = !!dblock && (Object.keys(dblock.members||{}).length > 0 || (dblock.comment||"").trim() !== "");
    if (need && !cur){
        headRow.insertAdjacentHTML("beforeend", `<span class="badge-unsaved">未保存</span>`);
    }else if (!need && cur){
        cur.remove();
    }
    }
    function updateSubmitButton(){
    const btn = document.getElementById("btnSubmit");
    if (!btn) return;
    const has = hasAnyDraft();      // 何か1つでも未送信ドラフトがあるか
    btn.disabled = !has;            // ない場合は押せない（空送信防止）
    btn.textContent = "まとめて送信"; // ラベルは常に統一
    }

/* ===== 共通ユーティリティ（画面切替 / 日付 / 区分 / カレンダー / スナックバー） ===== */
  // --- DOM / ログ系 ---
    function h(s){
    return String(s==null?'':s).replace(/[&<>"']/g, c => (
        {"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c]
    ));
    }
    const $ = s => document.querySelector(s);
    
    /* ===== 区分(セグメント) 正規化 & 判定ヘルパー ===== */
    const INCLUDE_BOTH_FOR_ALL = true;
    
    // ↑②の仕様に合わせて false（＝常に『両方』は表示対象から除外）
    // 運用で方針変更する場合は true にすると、常に『両方』を表示に含められます。
    function show(id){ document.querySelectorAll("[data-view]").forEach(v=>v.classList.remove("show")); $(id).classList.add("show"); const lf = document.getElementById('legalFooter');
    if (lf) lf.style.display = (id === '#view-home') ? '' : 'none';}
    function logHome(t){ $("#homeLog").textContent = t||""; }
    function logForm(t){ $("#formLog").textContent = t||""; }
    function logReg(t){ $("#regLog").textContent = t||""; }
    function logAdmin(t){ $("#adminFormLog").textContent = t||""; }

  // --- 日付・時間フォーマット ---
    function z(n){ return String(n).padStart(2,"0"); }
    function ymdDow(d){
    if (!(d instanceof Date) || isNaN(d)) return "";
    const yo = "日月火水木金土"[d.getDay()];
    return `${d.getFullYear()}/${z(d.getMonth()+1)}/${z(d.getDate())}（${yo}）`;
    }
    function hmFromTimeCell(v){
    const s = String(v||"").trim();
    const tryDate = new Date(s);
    if (!isNaN(tryDate)) return `${z(tryDate.getHours())}:${z(tryDate.getMinutes())}`;
    const m = s.match(/^(\d{1,2}):(\d{2})$/); 
    if (m) return `${z(m[1])}:${m[2]}`;
    return "";
    }
    function parseYmdStrict(s){
    const m = String(s||"").match(/^(\d{4})[\/\-](\d{2})[\/\-](\d{2})$/);
    if (!m) {
        const d = new Date(s);
        return isNaN(d) ? null : d;
    }
    const y = Number(m[1]), mo = Number(m[2]), d = Number(m[3]);
    const dt = new Date(y, mo-1, d);
    return isNaN(dt) ? null : dt;
    }
    function esc(s){ return encodeURIComponent(String(s||"")); }
    function toYmdSlashFromDateInput(v){ // "yyyy-mm-dd" -> "yyyy/MM/dd"
    if (!v) return "";
    const m = v.match(/^(\d{4})-(\d{2})-(\d{2})$/);
    return m ? `${m[1]}/${m[2]}/${m[3]}` : "";
    }
    function toDateInputFromYmdSlash(v){ // "yyyy/MM/dd" -> "yyyy-mm-dd"
    const m = String(v||"").match(/^(\d{4})\/(\d{2})\/(\d{2})$/);
    return m ? `${m[1]}-${m[2]}-${m[3]}` : "";
    }

    // イベントセレクト用の表示ラベル生成
    function formatEventOptionLabel(ev){
    // D1 から来る raw 値
    const rawYmd = ev.ymd || ev.date || '';
    const rawHm  = ev.hm  || ev.time || '';
    const title  = ev.title || '';

    // 日付ラベル（yyyy/MM/dd（曜））
    let dateLabel = '';
    const d = parseYmdStrict(rawYmd);
    if (d instanceof Date && !isNaN(d)) {
        dateLabel = ymdDow(d);  // 2026/01/11（日）
    } else {
        dateLabel = String(rawYmd || '');
    }

    // 時刻ラベル（HH:mm）
    let timeLabel = '';
    if (rawHm) {
        timeLabel = hmFromTimeCell(rawHm); // "14:00" / "17:15" などに正規化
    }

    const head = [dateLabel, timeLabel].filter(Boolean).join(' ');

    // 「2026/01/11（日） 14:00　タイトル」のイメージ
    if (head && title) return `${head}　${title}`;
    if (head)          return head;
    return title || '';
    }
  // --- 区分（セグメント）関連 ---
    function normSeg(raw){
    const s = String(raw||"").trim().toLowerCase();
    if (!s) return "";
    if (s === "adult" || s.includes("大人")) return "adult";
    if (s === "child" || s.includes("子ども") || s.includes("子供")) return "child";
    if (s === "both"  || s.includes("両方")) return "both";
    return "";
    }
    function dispSeg(n){ // 表示用ラベル
    if (n==="adult") return "大人の部";
    if (n==="child") return "子どもの部";
    if (n==="both")  return "両方";
    return "";
    }
    // 名前の区分（adult/child/both/""）とイベントの区分を突き合わせる共通関数
    function matchSeg(nameSegRaw, eventSegRaw){
    const ns = normSeg(nameSegRaw);
    const es = normSeg(eventSegRaw);
    if (!es || es === 'both') return true;  // イベント=両方 → 全員対象
    if (!ns) return true;                   // 名前側が不明 → 除外しない
    return ns === es || ns === 'both';      // 名前=both → 子/大どちらにも合致
    }
    function getMemberSegSet(){
    const segs = new Set();
    (state.members||[]).forEach(m=>{
        const n = normSeg(m.segment || m.区分);
        if (n) segs.add(n);
    });
    return segs;
    }
    function userHasBoth(){
    const s = getMemberSegSet();
    return s.has("adult") && s.has("child");
    }
    /* --- 区分フィルタの表示/非表示を切り替える --- */
    function updateSegFilterUI(){
    // 「同じLINEアカウントで大人/子ども両方の名簿レコードがあるか？」
    const showIt = userHasBoth();
    const lab = document.getElementById('labSeg');
    const sel = document.getElementById('selSeg');
    if (!lab || !sel) return; // HTMLがまだない場合でも安全にスキップ

    lab.style.display = showIt ? '' : 'none';
    sel.style.display = showIt ? '' : 'none';

    // 非表示にしたときは値をクリア（＝全予定表示）
    if (!showIt) {
        sel.value = '';
        // Schedulesブロック内の関数はクロージャ内なので、グローバル経由で“あれば”呼ぶ
        if (typeof window.__schedSaveFilters === 'function') {
        window.__schedSaveFilters();
        }
    }
    }
    // 修正後：includeBoth で “両方” を含めるか選べるように
    function eventVisibleForUser(eventSegRaw, userSegSet, includeBoth=true){
    // ユーザー区分情報がない → 全表示
    if (!userSegSet || userSegSet.size === 0) return true;

    const e = normSeg(eventSegRaw);

    // 両方所属ユーザー
    if (userSegSet.has("adult") && userSegSet.has("child")){
        if (e === "adult" || e === "child") return true;
        if (includeBoth && e === "both")     return true;
        return false;
    }
    // 片側所属ユーザー
    if (userSegSet.has("adult")){
        return (e === "adult") || (includeBoth && e === "both");
    }
    if (userSegSet.has("child")){
        return (e === "child") || (includeBoth && e === "both");
    }
    return true;
    }
    function buildNameSegMap(){
    const map = {};
    (state.members||[]).forEach(m=>{
        const n = (m.performerName||"").trim();
        const s = normSeg(m.segment || m.区分);
        if (!n || !s) return;
        if (!map[n]) { map[n] = s; }
        else if (map[n] !== s) { map[n] = 'both'; } // 子と大が混在 → both
    });
    return map;
    }
  // --- ビュー種別 & Googleカレンダー連携 ---
    function hasPerformers(){
    return (state.members||[]).some(m => !!String(m.performerName||'').trim());
    }
    function isViewer(){
    // サーバが viewerOnly を返してくれる場合はそれを優先
    if (typeof state.viewerOnly === 'boolean') return state.viewerOnly;
    // それが無い場合は「演奏者ゼロ かつ 通知OFF」で推定
    return !hasPerformers() && state.notify === false;
    }
    /* Google Calendar 追加URL */
    const DFLT_MIN = { "発表":90, "練習":150, "その他":60 };
    function toDatesParam(ymdStr, hmStr, kind){
    const m = String(ymdStr||"").match(/^(\d{4})\/(\d{2})\/(\d{2})$/);
    if (!m) return "";
    const H = hmStr ? Number(hmStr.split(":")[0]) : 0;
    const M = hmStr ? Number(hmStr.split(":")[1]) : 0;
    const st = new Date(Number(m[1]), Number(m[2])-1, Number(m[3]), H, M, 0);
    const mins = DFLT_MIN[kind] || 60;
    const ed = new Date(st.getTime() + mins*60000);
    const fmt = (d)=>`${d.getFullYear()}${z(d.getMonth()+1)}${z(d.getDate())}T${z(d.getHours())}${z(d.getMinutes())}00`;
    return `${fmt(st)}/${fmt(ed)}`;
    }
    function makeGoogleCalUrl(title, ymd, hm, place, kind, memo){
    const base = "https://calendar.google.com/calendar/render?action=TEMPLATE";
    const dates = toDatesParam(ymd, hm, kind);
    const params = [
        `text=${esc(title)}`,
        dates ? `dates=${dates}` : "",
        place ? `location=${esc(place)}` : "",
        memo  ? `details=${esc(memo)}` : "",
        `ctz=${esc("Asia/Tokyo")}`
    ].filter(Boolean).join("&");
    return `${base}&${params}`;
    }
  /* ===== 共通スナックバー ===== */
        (function () {
        const SNACKBAR_ID = 'snackbar';

        window.showSnackbar = function (message, options = {}) {
            const el = document.getElementById(SNACKBAR_ID);
            if (!el) {
            console.warn('#snackbar not found, fallback to alert');
            alert(message);
            return;
            }

            const variant = options.variant || 'default'; // 'default' | 'loading' | 'success' | 'error'
            let duration  = options.duration;

            // loading のときデフォで「自動で消さない」
            if (duration == null) {
            duration = (variant === 'loading') ? 0 : 2500;
            }

            // メッセージ差し込み
            el.textContent = message;

            // 既存タイマーがあればクリア
            if (el._snackbarTimer) {
            clearTimeout(el._snackbarTimer);
            el._snackbarTimer = null;
            }

            // variant クラス付け替え
            el.classList.remove('loading', 'success', 'error');
            if (variant === 'loading') el.classList.add('loading');
            if (variant === 'success') el.classList.add('success');
            if (variant === 'error')   el.classList.add('error');

            // 表示
            el.classList.add('show');

            // duration > 0 のときだけ自動で消す
            if (duration > 0) {
            el._snackbarTimer = setTimeout(() => {
                el.classList.remove('show');
                el._snackbarTimer = null;
            }, duration);
            }
        };

        window.hideSnackbar = function () {
            const el = document.getElementById(SNACKBAR_ID);
            if (!el) return;

            if (el._snackbarTimer) {
            clearTimeout(el._snackbarTimer);
            el._snackbarTimer = null;
            }
            el.classList.remove('show');
        };

        // （お好み）クリックで即閉じる
        window.addEventListener('DOMContentLoaded', function () {
            const el = document.getElementById(SNACKBAR_ID);
            if (!el) return;
            el.addEventListener('click', function () {
            hideSnackbar();
            });
        });

        // （将来用）共通ラッパー
        window.withLoadingSnackbar = async function (doingMsg, doneMsg, fn) {
            showSnackbar(doingMsg, { variant: 'loading' });
            try {
            const result = await fn();
            hideSnackbar();
            if (doneMsg) {
                showSnackbar(doneMsg, { variant: 'success' });
            }
            return result;
            } catch (e) {
            hideSnackbar();
            showSnackbar('エラーが発生しました', { variant: 'error', duration: 4000 });
            throw e;
            }
        };
        })();

  /* ===== 共通: 保存中オーバーレイ ===== */
        (function () {
        const ID = 'savingOverlay';
        const MSG_ID = 'savingOverlayMsg';

        function getEl()     { return document.getElementById(ID); }
        function getMsgEl()  { return document.getElementById(MSG_ID); }

        window.showSavingOverlay = function (message) {
            const el = getEl();
            if (!el) return;
            const msgEl = getMsgEl();
            if (msgEl && message) msgEl.textContent = message;
            el.classList.add('show');
            el.removeAttribute('aria-hidden');
        };

        window.hideSavingOverlay = function () {
            const el = getEl();
            if (!el) return;
            el.classList.remove('show');
            el.setAttribute('aria-hidden', 'true');
        };
        })();

        function showSavingModal(message) {
        let ov = document.getElementById('adminSavingOverlay');
        if (!ov) {
            ov = document.createElement('div');
            ov.id = 'adminSavingOverlay';
            ov.style.position = 'fixed';
            ov.style.inset = '0';
            ov.style.background = 'rgba(0,0,0,0.35)';
            ov.style.display = 'flex';
            ov.style.alignItems = 'center';
            ov.style.justifyContent = 'center';
            ov.style.zIndex = '9999';
            ov.innerHTML = `
            <div style="
                background:#fff;
                padding:16px 24px;
                border-radius:12px;
                box-shadow:0 4px 16px rgba(0,0,0,.25);
                text-align:center;
                min-width:220px;
            ">
                <div class="spinner" style="
                width:28px;
                height:28px;
                border-radius:50%;
                border:3px solid #ccc;
                border-top-color:#555;
                margin:0 auto 8px;
                animation: adminSpin 0.8s linear infinite;
                "></div>
                <div id="adminSavingText" style="font-size:14px;">保存中…</div>
            </div>
            `;
            document.body.appendChild(ov);

            // 簡易アニメーション
            const style = document.createElement('style');
            style.textContent = `
            @keyframes adminSpin {
                to { transform: rotate(360deg); }
            }
            `;
            document.head.appendChild(style);
        }
        const label = ov.querySelector('#adminSavingText');
        if (label) label.textContent = message || '保存中…';
        ov.style.display = 'flex';
        }

        function hideSavingModal() {
        const ov = document.getElementById('adminSavingOverlay');
        if (ov) ov.style.display = 'none';
        }

  // ★ 登録画面用：保存中オーバーレイ ON/OFF
        function toggleRegOverlay(show) {
            const ov = document.getElementById("regOverlay");
            if (!ov) return;
            ov.style.display = show ? "flex" : "none"; // 出欠フォームの overlay に揃える
        }
/* ===== API ===== */
    async function api(path, { signal } = {}) {
    const url = API_ENDPOINT + path;
    console.debug('[api] request url =', url);

    // 呼び出し側から signal が来ていればそれを優先
    const ctrl = signal ? null : new AbortController();
    const usedSignal = signal || (ctrl && ctrl.signal);

    const timeoutMs = 15000;
    const timerId = ctrl
        ? setTimeout(() => ctrl.abort('timeout'), timeoutMs)
        : null;

    // 1回分のトライ（CORS モード）
    async function tryOnceCors() {
        const res = await fetch(url, { signal: usedSignal });

        // CORS が通っていて JSON が返ってくる場合はこちら
        try {
        return await res.json();
        } catch (e) {
        // JSON が読めない場合（opaque など）は「とりあえず OK 扱い」にする
        console.warn('[api] JSON parse failed, treat as opaque OK:', e);
        return { status: 'ok', note: 'opaque or non-JSON response' };
        }
    }

    try {
        const r = await tryOnceCors();
        if (timerId) clearTimeout(timerId);
        return r;
    } catch (e) {
        // ここに来るのは主に CORS ブロックやネットワークエラー
        if (timerId) clearTimeout(timerId);
        console.warn(
        '[api] first fetch failed, fallback to no-cors fire-and-forget:',
        e
        );

        try {
        // no-cors で「投げっぱなし」。結果は読めないが、サーバには届く前提で OK 扱い
        await fetch(url, { mode: 'no-cors' });
        return { status: 'ok', note: 'no-cors fallback' };
        } catch (e2) {
        console.error('[api] no-cors fallback also failed:', e2);
        throw e2; // 本当にダメなときだけ呼び出し元にエラーを投げる
        }
    }
    }
/* ===== 初期化 ===== */
    async function init(){
    try{
        $("#ver").textContent = FRONT_VERSION;

        try {
    await liff.init({ liffId: LIFF_ID });
    } catch (e) {
    console.error('[LIFF init failed]', e);
    const msg = (e && e.message) ? e.message : String(e);
    document.getElementById('eventsBox').innerHTML =
        `<span class="err">LIFF初期化エラー: ${msg}</span>`;
    return; // ここで中断
    }
        if (!liff.isLoggedIn()){ liff.login(); return; }

        if (liff.getFriendship){
        try{
            const fr = await liff.getFriendship();
            if (fr && fr.friendFlag===false) $("#friendAlert").style.display="";
        }catch(_){}
        }

        const idt = liff.getDecodedIDToken();
        state.lineId = idt ? idt.sub : "";
        state.name   = idt && idt.name ? idt.name : "";
        $("#hello").textContent = state.name ? `こんにちは、${state.name} さん` : "";

        /* ★ lineIdが確定したら、ドラフトを復元 */
        draftLoad();

        bindHandlers();
        resetRegisterForm();

        // 管理者判定は refreshData 内で D1 の結果を使う

        // こちらはすぐ実行してOK（D1は速い）
        await refreshData();
    }catch(err){
        $("#eventsBox").innerHTML = `<span class="err">初期化に失敗しました: ${err.message||err}</span>`;
    }
    }

/* ===== クリックバインド（ボタンにひたすら処理を結びつける配線コマンドたち） ===== */
    function bindHandlers(){
    $("#btnReload").onclick      = async ()=>{ logHome("再読み込み中…"); await refreshData(); logHome(""); };
    $("#btnPrimary").onclick     = onPrimary;
    $("#btnEditNames").onclick   = onEditNames;
    $("#btnBackFromForm").onclick = () => {
        if (state.submitting) return;       // 送信中は遷移させない
        show("#view-home");
    };
    $("#btnBackFromReg").onclick = ()=> show("#view-home");
    $("#btnSubmit").onclick      = onSubmit;
    $("#btnAddPerf").onclick     = ()=> addPerformerField("");
    $("#btnRegister").onclick    = onRegister;
    $("#btnSchedules").onclick   = ()=>{ 
        show("#view-schedules"); 
        updateSegFilterUI(); 
        window.__schedLoadFilters?.();   // ← 追加：前回の選択を復元
        window.renderSchedules(true); 
    };
    $("#btnBackFromSchedules").onclick = ()=> show("#view-home");
    $("#btnFetchSchedules").onclick    = ()=> window.renderSchedules(true);

    // 管理：セレクト変更で即ローカル描画
    document.getElementById('ad_days')?.addEventListener('change', adminListRenderLocal);
    document.getElementById('ad_seg_filter')?.addEventListener('change', adminListRenderLocal);
    
    // レポート
    $("#btnReportBack").onclick = ()=> show("#view-home");
    $("#btnReportReload").onclick = ()=> reportReload();
    $("#repAttend").addEventListener("change", renderReport);
    document.getElementById('repEvent')?.addEventListener('change', renderReport);
    
    // 管理メニュー（HOME）
    $("#btnAdminMenuSchedules").onclick = ()=>{
        if (!state.isAdmin){ alert("管理者のみアクセス可能です"); return; }
        show("#view-admin");
        window.setupAdminAccordion?.();
        enterAdminCreateMode();
        adminListFetch();
    };
    $("#btnAdminMenuReport").onclick = ()=>{
        if (!state.isAdmin){ alert("管理者のみアクセス可能です"); return; }
        show("#view-admin-report");
        reportReload();
    };
    
    // 管理メニュー：カスタム通知
    $("#btnAdminCustomPush").onclick = () => {
        if (!state.isAdmin){ alert("管理者のみアクセス可能です"); return; }
        show("#view-custom-push");                 // 画面表示
        window.initCustomPushPage?.();             // 初期化（イベント候補読込・参加のみONなど）
    };
    
    // 管理メニュー：サマリ
    document.getElementById('btnSummary')?.addEventListener('click', () => {
        if (!state.isAdmin) { alert('管理者のみアクセス可能です'); return; }
        show('#view-summary');                  // サマリ画面を表示（内部で hidden=false）
        const v = document.getElementById('view-summary');  
        window.loadSummaryFreeQuota?.();        // 無料枠の初期表示
    });
    
    // サマリ内ボタン
    document.getElementById('btnSummaryFreeQuota')
        ?.addEventListener('click', () => window.loadSummaryFreeQuota?.());
    document.getElementById('btnSummaryReload')
        ?.addEventListener('click', () => window.loadSummaryFreeQuota?.());
    document.getElementById('btnSummaryToTop')
    ?.addEventListener('click', ()=> show('#view-home'));
    
    // 管理メニュー：ご意見BOX
    document.getElementById('btnFeedback')?.addEventListener('click', async () => {
        if (!state.isAdmin){ alert('管理者のみアクセス可能です'); return; }
        show('#view-feedback');          // ← 既存と同じ切替
        await window.loadFeedbackList?.(); // ← 初回ロード（下で定義）
    });
    
    // 管理画面
    $("#btnAdminBack").onclick = ()=> show("#view-home");
    document.getElementById('btnAdminReload')
        ?.addEventListener('click', ()=> adminListFetch());
    $("#btnAdminFetch").onclick = ()=> adminListFetch();
    $("#btnAdminSubmit").onclick = ()=> adminSubmit();
    $("#btnAdminReset").onclick = ()=> enterAdminCreateMode();
    $("#ad_type").addEventListener("change", adminTypeChangeAdapt);
    
    // 管理アコーディオン（ヘッダーに直接：click/Enter/Space、キャプチャで確実に拾う）
    function setupAdminAccordion(){
        const acc  = document.getElementById('adminListAcc');
        if (!acc) return;
        if (acc.__bound) return;           // ★ もう結んでたら何もしない
        acc.__bound = true;
    
        const head = acc.querySelector('.fHead');
        const body = acc.querySelector('.fBody');
        if (!head || !body) return;
    
        const sync = () => {
        const open = acc.classList.contains('open');
        head.setAttribute('role', 'button');
        head.setAttribute('tabindex', '0');
        head.setAttribute('aria-expanded', open ? 'true' : 'false');
        body.style.display = open ? 'block' : 'none';
        };

        acc.__sync = sync; 
        
        const toggle = (e) => { acc.classList.toggle('open'); sync(); };
    
        head.addEventListener('click', toggle, { capture: true });
        head.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); toggle(e); }
        });
        sync();
    }
    
    // ★ 追加：どこからでも閉じられるユーティリティ
    window.closeAdminAccordion = function(){
    const acc  = document.getElementById('adminListAcc');
    if (!acc) return;
    acc.classList.remove('open');
    // inline style を確実に反映して閉じる
    const head = acc.querySelector('.fHead');
    const body = acc.querySelector('.fBody');
    if (head) head.setAttribute('aria-expanded', 'false');
    if (body) body.style.display = 'none';
    // 予備：公開された同期関数があれば呼ぶ
    if (typeof acc.__sync === 'function') acc.__sync();
    };
    
    // ★ これを追加（外から呼べるようにする）
    window.setupAdminAccordion = setupAdminAccordion;
    
    // 起動時に一度だけ（既存のこれも残す）
    setupAdminAccordion();
    }

/* ===== 体感高速化：キャッシュ ===== */
    /* --- 軽量ローカルキャッシュ（SWR用） --- */
    const CACHE_TTL_MS = 5 * 60 * 1000; // 5分
    function _cacheKey(k){ return `liff:${ENV_NS}:${k}`; }
    function cacheGet(k){
    try{
        const raw = localStorage.getItem(_cacheKey(k));
        if (!raw) return null;
        const obj = JSON.parse(raw);
        if (!obj || typeof obj.ts !== 'number') return null;
        if (Date.now() - obj.ts > CACHE_TTL_MS) return null;
        return obj.data;
    }catch(_){ return null; }
    }
    function cacheSet(k, data){
    try{
        localStorage.setItem(_cacheKey(k), JSON.stringify({ ts: Date.now(), data }));
    }catch(_){}
    }

    // ===== 管理レポート：メタ取得だけローカルキャッシュ対応（renderReportは触らない） =====
    const REP_META_KEY = "report:meta:v1";

    // #repEvent の <option> を描画（既存renderReportはそのまま）
    function renderRepEventOptions(meta){
    const sel = document.getElementById('repEvent');
    if (!sel) return;
    const cur = sel.value; // 現在選択を保持

    const toLabel = (x)=>{
        const seg   = dispSeg(normSeg(x.segment || x.segmentCode || x.targetSegment || x.attendSegment || ""));
        const d     = x.ymd || x.date || "";
        const hm    = x.hm || x.time || "";
        const place = x.place || x.venue || "";
        const title = x.title || x.name || "";
        const dt    = d && hm ? `${d} ${hm}` : (d || hm);
        const left  = [dt, place].filter(Boolean).join(" @ ");
        return [seg, left, title].filter(Boolean).join(" / ");
    };

    const opts = ['<option value="">（選択してください）</option>']
        .concat((meta||[]).map(m => {
        const id = String(m.eventId ?? m.id ?? "");
        return `<option value="${id}">${toLabel(m)}</option>`;
        }))
        .join("");

    sel.innerHTML = opts;

    // 以前の選択IDがまだ存在するなら維持
    if (cur && (meta || []).some(m => String(m.eventId ?? m.id ?? "") === cur)) {
        sel.value = cur;
    }
    }

    // 起動時/メニュー遷移時など、「まずキャッシュだけ即時反映」
    function loadReportMetaFromCache(){
    const meta = cacheGet(REP_META_KEY);
    if (Array.isArray(meta) && meta.length){
        state.reportMeta = meta;
        renderRepEventOptions(meta);
    }
    }

    // ネット再取得（成功したら上書き＆キャッシュ保存）
    async function fetchReportMetaFresh(){
    try{
        // サーバー側が lineId を要求する構成に備えて常に付与（不要なら無視されます）
        const q = `?attendanceReport=1&meta=1&id=${esc(state.lineId)}`;
        const j = await fetchJsonWithTimeout(q, 15000);
        const meta = j?.meta || j?.list || j?.data || [];
        if (j?.status === "ok" && Array.isArray(meta)){
        state.reportMeta = meta;
        renderRepEventOptions(meta);
        cacheSet(REP_META_KEY, meta);
        }
    }catch(_){}
    }

    // 既存バインドをそのまま活かすため、reportReload を“上書き定義”
    // - 先にキャッシュを即時表示
    // - 続けてネットで最新化
    window.reportReload = async function(){
    loadReportMetaFromCache();
    await fetchReportMetaFresh();
    };

    // フォーカス時にもキャッシュだけ先に見せる（初回体感をさらに改善）
    document.getElementById('repEvent')?.addEventListener('focus', loadReportMetaFromCache, { once:true });

    /* --- タイムアウト付きフェッチ（失敗時は1回だけリトライ） --- */
    async function fetchJsonWithTimeout(path, ms=15000){
    const ctrl = new AbortController();
    const timer = setTimeout(()=> ctrl.abort("timeout"), ms);
    try{
        const r = await fetch(API_ENDPOINT + path, { signal: ctrl.signal });
        clearTimeout(timer);
        return await r.json();
    }catch(_){
        clearTimeout(timer);
        // ワンモア（短め待機）
        await new Promise(res=> setTimeout(res, 300));
        const r2 = await fetch(API_ENDPOINT + path);
        return await r2.json();
    }
    }

    /* --- 先にイベントだけで描画（回答は空でOK） --- */
    function bootHomeQuickRender(){
    const userSegSet = getMemberSegSet();

    let filteredEvents = (state.events||[]).filter(e=>{
    const evSeg = e.segment || e.targetSegment || e.attendSegment || e.segmentRaw || e.segmentCode || "";
    return eventVisibleForUser(evSeg, userSegSet, INCLUDE_BOTH_FOR_ALL);
    });
    if (userSegSet.size === 0) filteredEvents = (state.events||[]).slice(); // 未登録＝全表示

    // performers（家族名）は会員情報がまだ無くても空配列でOK
    const performers = Array.from(
        new Set((state.members||[]).map(m=>m.performerName).filter(Boolean))
    );
    const nameSegMap = buildNameSegMap(); // 既存のヘルパーを利用

    const events = filteredEvents.map(x => ({
        id      : String(x.eventId ?? x.id ?? ''),
        ymd     : ymdDow(parseYmdStrict(x.date)) || String(x.date || x.ymd || ''),
        hm      : hmFromTimeCell(x.time ?? x.hm ?? x['時間'] ?? ''),
        place   : x.place ?? x.venue ?? x.location ?? '',
        deadline: String(x.deadline ?? x.limit ?? x.deadlineYmd ?? ''),
        isNew   : (x.isNew === true) || (x.is_new === 'Y') || (x.new === true),
        segment : x.segment || x.targetSegment || x.attendSegment || x.segmentCode || ""
    }));

    window.HomeEventsUI?.mount({ events, myAnswersMap: {}, performers, nameSegMap });
    // フォーム側でも使えるよう保持
    state._filteredEventsForViews = filteredEvents;
    }

    /* --- 回答が届いたら差し替え描画 --- */
    function mountHomeWithFilters(){
    const filteredEvents = (state._filteredEventsForViews && state._filteredEventsForViews.length)
    ? state._filteredEventsForViews : (state.events || []);
    const events = filteredEvents.map(x => ({
        id      : String(x.eventId ?? x.id ?? ''),
        ymd     : ymdDow(parseYmdStrict(x.date)) || String(x.date || x.ymd || ''),
        hm      : hmFromTimeCell(x.time ?? x.hm ?? x['時間'] ?? ''),
        place   : x.place ?? x.venue ?? x.location ?? '',
        deadline: String(x.deadline ?? x.limit ?? x.deadlineYmd ?? ''),
        isNew   : (x.isNew === true) || (x.is_new === 'Y') || (x.new === true),
        segment : x.segment || x.targetSegment || x.attendSegment || x.segmentCode || ""
    }));

    const myAnswersMap = {};
    for (const [eid, list] of Object.entries(state.answers || {})){
        myAnswersMap[String(eid)] = (list || []).map(r => ({
        name  : r.performerName,
        answer: (r.attend || '').trim() || '未回答'
        }));
    }

    const performers = Array.from(
        new Set((state.members||[]).map(m=>m.performerName).filter(Boolean))
    );
    const nameSegMap = buildNameSegMap();

    window.HomeEventsUI?.mount({ events, myAnswersMap, performers, nameSegMap });
    }

    /* ===== データ読み直し（D1直版＋isAdminもD1） ===== */
    async function refreshData(){
        const t0 = performance.now();
        console.log("[perf] refreshData start");

        // 1) まずスピナーを出す
        $("#eventsBox").innerHTML  = `読み込み中… <span class="spinner"></span>`;
        $("#answersBox").innerHTML = `会員情報照会中… <span class="spinner"></span>`;
        $("#btnPrimary").textContent = "読み込み中…";
        $("#btnPrimary").disabled = true;
        $("#btnEditNames").style.display = "none";

        const lineId = state.lineId || "";
        if (!lineId) {
            $("#eventsBox").innerHTML  = `<span class="em-red">LINE ID が取得できませんでした</span>`;
            $("#answersBox").innerHTML = "";
            console.log("[perf] refreshData abort: no lineId");
            return;
        }

        // 2) キャッシュがあれば“即表示”
        const cachedEvents  = cacheGet("events");
        const cachedMembers = cacheGet(`whoami:${lineId}`);
        const cachedAnswers = cacheGet(`answers:${lineId}`);
        const cachedIsAdmin = cacheGet(`isAdmin:${lineId}`);

        if (cachedEvents){
            const tQuick0 = performance.now();
            state.events = cachedEvents;
            if (cachedMembers) state.members = cachedMembers;
            if (cachedAnswers) state.answers = cachedAnswers;
            if (typeof cachedIsAdmin === "boolean") {
            state.isAdmin = cachedIsAdmin;
            }
            bootHomeQuickRender();
            updateSegFilterUI();
            console.log("[perf] quick render from cache", (performance.now() - tQuick0).toFixed(0), "ms");
        }

        // 3) D1 を直接叩いて homeInit 相当のデータを組み立てる
        let home = null;

        const d1Base = (typeof D1_API_BASE_URL === "string" ? D1_API_BASE_URL : "").replace(/\/+$/, "");

        try {
            if (!d1Base) {
            throw new Error("D1_API_BASE_URL が未設定です");
            }

            // --- 3-1) /line/home-summary で members + events を取得 ---
            const urlSummary = `${d1Base}/line/home-summary?lineId=${encodeURIComponent(lineId)}`;
            const ctl1 = new AbortController();
            const t1Timeout = setTimeout(() => ctl1.abort(), 15000);
            let res1;
            const tFetchSummary0 = performance.now();
            try {
            res1 = await fetch(urlSummary, { method: "GET", signal: ctl1.signal });
            } finally {
            clearTimeout(t1Timeout);
            }
            if (!res1.ok) {
            throw new Error("home-summary http error: " + res1.status);
            }
            const json1 = await res1.json();
            console.log("[perf] fetch home-summary", (performance.now() - tFetchSummary0).toFixed(0), "ms");

            if (!json1 || !json1.ok) {
            throw new Error("home-summary error: " + (json1 && json1.message || ""));
            }

            // ---- D1.members → 旧 whoami 形式に変換 ----
            const perfRows = (json1.member && Array.isArray(json1.member.performers))
            ? json1.member.performers
            : [];

            let whoami;
            if (perfRows.length === 0) {
                whoami = {
                    status: "new",
                    members: [],
                    notify: true,
                    viewerOnly: false,   // ★ 初回は viewerOnly=false にする
                    inputName: "",
                };
            } else {
            const members = perfRows
                .map(r => ({
                performerName: String(r.performerName || "").trim(),
                segment      : String(r.segment || "子どもの部").trim(),
                // inputName を performer 行ごとに持たせたい場合はここでも拾える
                inputName    : String(r.inputName || r.input_name || "").trim() || undefined,
                }))
                .filter(x => x.performerName !== "");

            const anyPerf = members.length > 0;

            let notify = true;
            for (const r of perfRows) {
                const v = String(r.notify || "").toUpperCase();
                if (v === "N" || v === "0" || v === "FALSE") {
                notify = false;
                break;
                }
            }

            const viewerOnly = !anyPerf;
            
            // ★ D1 側のどこかに inputName を持たせておく前提で、とれるだけ欲張って拾う
            const inputNameFromD1 = String(
                json1.member?.inputName
                || json1.member?.input_name
                || perfRows[0]?.inputName
                || perfRows[0]?.input_name
                || ""
            ).trim();
            
            whoami = {
                status    : "ok",
                members   : members,
                notify    : notify,
                viewerOnly: viewerOnly,
                inputName : inputNameFromD1,        // ★ 追加
            };
            }

            // ---- events: フロントが期待する形にマップ ----
            const rawEvents = Array.isArray(json1.events) ? json1.events : [];

            const filteredEvents = rawEvents.filter(ev => {
            const need = String(ev.need_attendance ?? ev.needAttendance ?? "").toUpperCase();
            const st   = String(ev.status ?? "").toLowerCase();
            const pub  = String(ev.publish_flag ?? ev.publishFlag ?? "").toLowerCase();

            if (need && need !== "Y") return false;
            if (st && st !== "active") return false;
            if (pub && pub !== "yes") return false;
            return true;
            });

            const events = filteredEvents.map(ev => ({
            eventId       : String(ev.event_key || ev.eventKey || ev.id || "").trim(),
            date          : ev.date || ev.ymd || "",
            time          : ev.time || ev.hm || "",
            place         : ev.place || "",
            deadline      : ev.deadline_date || ev.deadlineDate || "",
            segment       : ev.target_group || ev.targetGroup || ev.segment || "",
            title         : ev.name || ev.title || "",
            kind          : ev.kind || "",
            needAttendance: ev.need_attendance || ev.needAttendance || "",
            status        : ev.status || "",
            publishFlag   : ev.publish_flag || ev.publishFlag || "",
            }));

            // --- 3-2) /line/attendance/all から answers を取得 ---
            const eventIds = events.map(ev => ev.eventId).filter(id => !!id);

            let answersMap = {};
            if (eventIds.length > 0) {
            const ctl2 = new AbortController();
            const t2Timeout = setTimeout(() => ctl2.abort(), 15000);
            let res2;
            const tFetchAtt0 = performance.now();
            try {
                res2 = await fetch(`${d1Base}/line/attendance/all`, {
                method: "POST",
                signal: ctl2.signal,
                headers: { "content-type": "application/json; charset=utf-8" },
                body: JSON.stringify({ lineId: lineId, eventIds: eventIds }),
                });
            } finally {
                clearTimeout(t2Timeout);
            }
            if (!res2.ok) {
                throw new Error("attendance/all http error: " + res2.status);
            }

            const json2 = await res2.json();
            console.log("[perf] fetch attendance/all", (performance.now() - tFetchAtt0).toFixed(0), "ms");

            if (json2.status !== "ok" || !json2.map || typeof json2.map !== "object") {
                throw new Error("attendance/all bad response: " + (json2.message || ""));
            }
            answersMap = json2.map;
            } else {
            console.log("[perf] fetch attendance/all skipped (no events)");
            }

            home = {
                status : "ok",
                whoami : whoami,
                events : events,
                answers: answersMap,
                isAdmin: !!json1.isAdmin,
                };

        } catch (err) {
            console.error("refreshData D1 error:", err);
        }

        // 4) 取得できたら state に反映
        const tRenderState0 = performance.now();

                if (home && home.status === "ok"){
                    // events
                    if (Array.isArray(home.events)) {
                        state.events = home.events;
                        pruneDraftAgainstCurrentEvents();
                    }

                    // whoami
                    if (home.whoami && home.whoami.status === "ok"){
                        state.members = Array.isArray(home.whoami.members)
                            ? home.whoami.members
                            : [];

                        // ★ notify は normalizeNotifyFlag 経由で boolean に揃える
                        const rawNotify =
                            (home.whoami.notify !== undefined)
                                ? home.whoami.notify
                                : state.notify; // なければ以前の値を尊重
                        state.notify = normalizeNotifyFlag(rawNotify);

                        // viewerOnly はひとまず従来ロジックそのまま
                        state.viewerOnly = (typeof home.whoami.viewerOnly === "boolean")
                            ? home.whoami.viewerOnly
                            : !!state.viewerOnly;

                        // ★ inputName を state に反映
                        if (typeof home.whoami.inputName === "string" && home.whoami.inputName.trim()){
                            state.inputName = home.whoami.inputName.trim();
                        }
                    } else if (home.whoami && home.whoami.status === "new") {
                        state.members    = [];
                        state.viewerOnly = false;

                        // ★ new のときは「初回なのでチェックなし」に寄せる
                        state.notify     = normalizeNotifyFlag(undefined);

                        state.inputName  = "";
                    }

            // isAdmin（D1で取れた分）
            if (typeof home.isAdmin === "boolean"){
            state.isAdmin = home.isAdmin;
            }
            if ($("#adminMenu")) {
            $("#adminMenu").style.display = state.isAdmin ? "" : "none";
            }

            // answers
            if (home.answers && typeof home.answers === "object"){
            state.answers = home.answers;
            }

            updateSegFilterUI();

            const tBoot0 = performance.now();
            bootHomeQuickRender();
            console.log("[perf] bootHomeQuickRender", (performance.now() - tBoot0).toFixed(0), "ms");

            const tMount0 = performance.now();
            mountHomeWithFilters();
            console.log("[perf] mountHomeWithFilters", (performance.now() - tMount0).toFixed(0), "ms");
        }

        console.log("[perf] render+state part", (performance.now() - tRenderState0).toFixed(0), "ms");

        // 5) キャッシュ保存
        if (state.events && state.events.length){
            cacheSet("events", state.events);
        }
        if (state.members){
            cacheSet(`whoami:${lineId}`, state.members);
        }
        if (state.answers){
            cacheSet(`answers:${lineId}`, state.answers);
        }
        if (typeof state.isAdmin === "boolean") {
            cacheSet(`isAdmin:${lineId}`, state.isAdmin);
        }

        // 6) ボタンの復帰
        const hasPerf = hasPerformers();
        const viewer  = isViewer();
        $("#btnPrimary").textContent = viewer
            ? "登録氏名の編集"
            : (hasPerf ? "出欠を入力 / 変更する" : "初回登録に進む");
        $("#btnPrimary").disabled = false;

        const showEditSubBtn = hasPerf && !viewer;
        $("#btnEditNames").style.display = showEditSubBtn ? "" : "none";

        console.log("[perf] refreshData done", (performance.now() - t0).toFixed(0), "ms");
    }

/* ===== HOME画面に戻ってきたときのボタン表示とメッセージ調整 ===== */
    function renderHome(){
    const hasMembers = state.members.length > 0;
    $("#btnPrimary").textContent = hasMembers ? "出欠を入力 / 変更する" : "初回登録に進む";
    $("#btnPrimary").disabled = false;
    $("#btnEditNames").style.display = (hasMembers && !isViewer()) ? "" : "none";

    if (!hasMembers){
        $("#answersBox").innerHTML = `
        <div>まだ「初回登録」が済んでいません。</div>
        <div class="small">出欠の前に、入力者名と演奏者（家族分も可）の登録をしてください。</div>`;
        return;
    }
    if (state.events.length === 0){
        $("#answersBox").innerHTML = `<div class="muted">配信中の公演がありません</div>`;
        return;
    }
    // （ここは非表示カードなので最小限のままにしています）
    $("#answersBox").innerHTML = "";
    }

    /* ===== メインボタン ===== */
    function onPrimary(){
    if (isViewer() || !hasPerformers()){
        // 閲覧者 or 演奏者未登録 → 氏名登録/編集フォームへ
        registerMode = isViewer() ? "edit" : "create";
        if (registerMode === "edit") {
        buildRegisterFormFromMembers();
        $("#regTitle").textContent = "氏名編集（入力者 & 演奏者）";
        $("#btnRegister").textContent = "保存";
        } else {
        resetRegisterForm();
        $("#regTitle").textContent = "初回登録（入力者 & 演奏者）";
        $("#btnRegister").textContent = "登録する";
        }
        show("#view-register");
    } else {
        buildFormView();
        show("#view-form");
    }
    }
    function onEditNames(){
    registerMode = "edit";
    buildRegisterFormFromMembers();
    $("#regTitle").textContent = "氏名編集（入力者 & 演奏者）";
    $("#btnRegister").textContent = "保存";
    show("#view-register");
    }
/* ===== 出欠フォーム（アコーディオン＋ドラフト） ===== */
    (() => {
    if (window.__AttendBlockV__ && window.__AttendBlockV__ >= 3) return;
    window.__AttendBlockV__ = 3;

    // 1件分のフォームカードHTMLを返す（バッジは1段上に独立行で表示）
    window.renderAttendEvent = function(ev, ctx){
        // ctx: { uniqueNamesAll, ansMap, nameSegMap, userSegSet }

        const readOnly = !!ev.readOnly;

        // ★ D1/GAS 両対応で生値を拾う
        const rawDate = ev.date   || ev.ymd || "";
        const rawTime = ev.time   || ev.hm  || ev.performAt || ev["時間"] || "";
        const place   = ev.place  || "";

        // 表示用（yyyy/mm/dd（曜） と hh:mm）
        const dateDisp = fmtYmd(rawDate);      // 例: "2026/01/11（日）"
        const timeDisp = fmtTime(rawTime);     // 例: "14:00"

        // 締切（yyyy/mm/dd）
        const rawDeadline   = ev.deadline || ev.limit || ev.deadlineYmd || "";
        const deadlineDisp  = fmtYmdNoWeekday(rawDeadline);  // 例: "2026/01/11"
        const deadlineLabel = readOnly
            ? `締切：${deadlineDisp || "—"}（締切済み）`
            : `締切：${deadlineDisp || "—"}`;

        // タイトルを安全に取得（API差異の吸収）
        const titleStr = String(
            ev.title ?? ev.name ?? ev.eventName ?? ev.subject ?? ""
        ).trim();

        const titleAttr = `${titleStr}${place ? ` @ ${place}` : ""}`;

        const evSegNorm     = normSeg(ev.segment || ev.targetSegment || ev.attendSegment || "");
        const segBadgeLabel = dispSeg(evSegNorm);
        const segBadgeCls   =
            evSegNorm === "adult" ? "seg-adult" :
            evSegNorm === "child" ? "seg-child" :
            "seg-both";

        // 表示対象の演奏者を決定（ユーザー/名前側の区分が欠落していれば除外しない＝全表示）
        const performers = (ctx.uniqueNamesAll || []).filter(n => {
            if (!ctx.userSegSet || ctx.userSegSet.size === 0) return true;
            return matchSeg(ctx.nameSegMap[n], evSegNorm);
        });

        // 未保存バッジ判定（閲覧専用カードでは出さない）
        const dblock = (draft.byEvent || {})[String(ev.eventId)];
        const hasUnsaved = !readOnly && !!dblock && (
            Object.keys(dblock.members || {}).length > 0 ||
            (dblock.comment || "").trim() !== ""
        );

        // ステータス行（pill）表示のため、現在値（ドラフト優先）を取得
        const pills = performers.map(name => {
            const current =
                draftGetAttend(ev.eventId, name) ||
                (ctx.ansMap[name]?.attend || "");
            let cls = "stat-na", label = "未回答";
            if (current === "参加") cls = "stat-ok", label = "参加";
            else if (current === "欠席") cls = "stat-ng", label = "欠席";
            else if (current === "未定") cls = "stat-pd", label = "未定";
            return `<span class="pill sm ${cls}">${h(name)}:${label}</span>`;
        }).join(" ");

        // セレクト or 読み取り専用行
        const rows = performers.map(name => {
            const current =
                draftGetAttend(ev.eventId, name) ||
                (ctx.ansMap[name]?.attend || "");
            const placeholderOpt =
                current === ""
                    ? `<option value="" disabled hidden selected>（選択してください）</option>`
                    : "";

            if (readOnly) {
                // ★ 閲覧専用：ラベルだけ表示
                const label =
                    current === "参加" ? "参加" :
                    current === "欠席" ? "欠席" :
                    current === "未定" ? "未定" : "未回答";

                return `
                    <div class="row-att row-att-readonly"
                        style="border-top:1px dashed var(--c-border); padding-top:8px; margin-top:8px;">
                        <span class="nameLabel">${h(name)}</span>
                        <span class="attLabel">${label}</span>
                    </div>
                `;
            }

            // 通常モード：select
            return `
                <div class="row-att"
                    style="border-top:1px dashed var(--c-border); padding-top:8px; margin-top:8px;">
                    <span class="nameLabel">${h(name)}</span>
                    <select class="attSel selectBtn"
                            data-event="${ev.eventId}"
                            data-name="${name}">
                        ${placeholderOpt}
                        <option value="参加" ${current==="参加"?"selected":""}>参加</option>
                        <option value="欠席" ${current==="欠席"?"selected":""}>欠席</option>
                        <option value="未定" ${current==="未定"?"selected":""}>未定</option>
                    </select>
                </div>
            `;
        }).join("");

        const initComment = draftGetComment(ev.eventId)
            || ((ctx.ansList || []).find(x => (x.comment || "").trim())?.comment || "");

        const commentPartReadOnly = `
            <div class="line"></div>
            <div class="commentReadOnly">
                コメント：
                ${
                    initComment
                        ? `<span class="commentText">${h(initComment)}</span>`
                        : `<span class="muted">（コメントなし）</span>`
                }
            </div>
        `;

        const commentPartEditable = `
            <div class="line"></div>
            <label>コメント（任意・100文字まで）</label>
            <input type="text"
                maxlength="100"
                class="evComment"
                data-event="${ev.eventId}"
                value="${h(initComment)}">
        `;

        // ── ★ 閲覧専用カード（締切済み）レイアウト ──
        if (readOnly) {
            return `
                <div class="fEvent readonly"
                data-evt="${ev.eventId}"
                data-seg="${evSegNorm || "both"}">

                <div class="fHead">
                    <!-- 1行目：日付 + 時間 + 区分バッジ（場所はここから外す） -->
                    <div class="fRow1" title="${dateDisp} ${timeDisp}">
                    <span class="t-date">
                        ${dateDisp}${timeDisp ? ` <small>${timeDisp}</small>` : ``}
                    </span>
                    ${segBadgeLabel ? `<span class="seg-badge ${segBadgeCls}">${segBadgeLabel}</span>` : ``}
                    </div>

                    <!-- 2行目：イベント名 -->
                    <div class="fRow2" title="${h(titleAttr)}">
                    <span class="t-title">${h(titleStr || "（無題）")}</span>
                    </div>

                    <!-- 3行目：出欠バッジ -->
                    <div class="fStatusRow">
                    ${pills}
                    </div>
                </div>

                <!-- 展開時の中身 -->
                <div class="fBody">
                    <!-- ＠場所 をここに移動 -->
                    ${
                    place
                        ? `<div class="fPlaceDetail">＠ ${h(place)}</div>`
                        : ``
                    }

                    <!-- 締切表示 -->
                    <div class="fSub" style="margin-bottom:8px;">
                    ${deadlineLabel}
                    </div>

                    ${rows}
                    ${commentPartReadOnly}
                </div>
                </div>
            `;
        }

        // ── ★ 通常（受付中）カード：従来レイアウト ──
        return `
            <div class="fEvent"
                data-evt="${ev.eventId}"
                data-seg="${evSegNorm || "both"}">
                <div class="fHead">
                    <div class="fTitle">
                        <!-- 1行目：日付・時間・区分バッジなど -->
                        <div class="fRow1" title="${dateDisp} ${timeDisp}">
                            <span class="t-date">
                                ${dateDisp}${timeDisp ? ` <small>${timeDisp}</small>` : ``}
                            </span>
                            ${hasUnsaved ? `<span class="badge-unsaved" style="margin-left:8px;">未保存</span>` : ``}
                            ${segBadgeLabel ? `<span class="seg-badge ${segBadgeCls}">${segBadgeLabel}</span>` : ``}
                        </div>

                        <!-- 2行目：タイトル ＠場所 -->
                        <div class="fRow2" title="${h(titleAttr)}">
                            <span class="t-title">${h(titleStr || "（無題）")}</span>
                            ${place ? `<span class="t-place">@ ${h(place)}</span>` : ``}
                        </div>
                    </div>

                    <!-- 回答チップ行 -->
                    <div class="fStatusRow">${pills}</div>

                    <!-- 締切表示 -->
                    <div class="fSub">${deadlineLabel}</div>
                </div>

                <div class="fBody">
                    ${rows}
                    ${commentPartEditable}
                </div>
            </div>
        `;
    };

    // ===== 既存の buildFormView を置換（renderAttendEvent を使用） =====
    window.buildFormView = function(){
        pruneDraftAgainstCurrentEvents();

        const boxHeader = $("#formEventsBox");
        const box       = $("#formFields");

        // ★ 送信ボタンのテンプレートを確保（初回だけ id を差し替えて隠す）
        let btnTemplate = document.getElementById("btnSubmitTemplate");
        if (!btnTemplate) {
            const original = document.getElementById("btnSubmit");
            if (original) {
                original.id = "btnSubmitTemplate";  // テンプレ用 id
                original.style.display = "none";    // 画面には出さない
                btnTemplate = original;
            }
        }

        box.innerHTML = "";

        boxHeader.innerHTML = `
            <span class="muted">
                イベントをタップして出欠を入力後、
                <span class="em-red">送信ボタンを押してください。</span>
            </span>`;

        // ★ ここで「フォーム対象イベント」を取得
        const allEvents = state._filteredEventsForViews || [];

        // ★ 受付中 / 締切済み に分割
        const { editableEvents, readonlyEvents } = splitEventsForForm(allEvents);

        if (!editableEvents.length && !readonlyEvents.length){
            box.innerHTML = `<div class="muted">現在、あなたの区分向けの公演はありません</div>`;
            updateSubmitButton();
            return;
        }

        const nameSegMap     = buildNameSegMap();
        const uniqueNamesAll = Array.from(
            new Set((state.members || []).map(m => m.performerName))
        ).filter(Boolean);
        const userSegSet     = getMemberSegSet();

        // ① 編集可能なイベント
        const editableHtml = editableEvents.map(e => {
            const ansList = state.answers[e.eventId] || [];
            const ansMap  = {}; ansList.forEach(r => ansMap[r.performerName] = r);

            return window.renderAttendEvent({
                eventId : e.eventId,
                date    : e.date,
                time    : e.time,
                place   : e.place || "",
                deadline: e.deadline || "",
                segment : e.segment || e.targetSegment || e.attendSegment || "",
                title   : e.title || e.eventTitle || e.name || e.eventName || "",
                readOnly: false,
            }, {
                uniqueNamesAll, ansMap, ansList, nameSegMap, userSegSet,
            });
        }).join("");

        // ② 閲覧専用イベント（締切済みなど）
        const readonlyHtml = readonlyEvents.map(e => {
            const ansList = state.answers[e.eventId] || [];
            const ansMap  = {}; ansList.forEach(r => ansMap[r.performerName] = r);

            return window.renderAttendEvent({
                eventId : e.eventId,
                date    : e.date,
                time    : e.time,
                place   : e.place || "",
                deadline: e.deadline || "",
                segment : e.segment || e.targetSegment || e.attendSegment || "",
                title   : e.title || e.eventTitle || e.name || e.eventName || "",
                readOnly: true,
            }, {
                uniqueNamesAll, ansMap, ansList, nameSegMap, userSegSet,
            });
        }).join("");

        let html = "";

        // 編集可能なイベント部分
        html += `<div id="formEditableBlock">${editableHtml}</div>`;

                if (readonlyHtml) {
            html += `
                <!-- ボタンの直後に来る区切り線 -->
                <div id="formReadonlyDivider"
                     class="line"
                     style="margin:16px 0 8px;"></div>

                <div id="formReadonlyHeader">
                    <div class="formSectionTitle" style="margin-top:4px; margin-bottom:4px;">
                        締切済み（内容の確認のみ）
                    </div>
                    <div class="muted" style="font-size:12px; margin-bottom:8px;">
                        ※締切後に予定が変わる場合は、必ず運営まで個別にご連絡ください。
                    </div>
                </div>

                <div id="formReadonlyBlock">
                    ${readonlyHtml}
                </div>
            `;
        }

        box.innerHTML = html;

        // ★ 既存レイアウトの「下の線(.line)」を消す
        (function hideOldBottomLine() {
        // #formFields のすぐ次にある .line を探す
        const globalLine = box.nextElementSibling;
        if (globalLine && globalLine.classList.contains("line")) {
            globalLine.style.display = "none";
        }
        })();

        // ★ ここから送信ボタンの配置 --------------------------
        btnTemplate = document.getElementById("btnSubmitTemplate");

        if (btnTemplate) {
            const newBtn = btnTemplate.cloneNode(true);
            newBtn.id = "btnSubmit";
            newBtn.style.display = "";

            // ★ 追加：クローンしたボタンに onSubmit をバインド
            newBtn.addEventListener("click", onSubmit);

            // まずは「区切り線」の直前に差し込む
            const divider = document.getElementById("formReadonlyDivider");

            if (divider && divider.parentNode) {
                divider.parentNode.insertBefore(newBtn, divider);
            } else {
                // 締切済みイベントがない場合 or 何かで divider が無い場合のフォールバック
                const readonlyHeader = document.getElementById("formReadonlyHeader");
                if (readonlyHeader && readonlyHeader.parentNode) {
                    readonlyHeader.parentNode.insertBefore(newBtn, readonlyHeader);
                } else {
                    box.appendChild(newBtn);
                }
            }
        }
        // ★ ここまで ------------------------------------------


        // アコーディオン開閉
        box.querySelectorAll(".fEvent .fHead").forEach(h => {
            h.addEventListener("click", () =>
                h.closest(".fEvent")?.classList.toggle("open")
            );
        });

        // change / input ハンドラはそのままでOK
        if (!box.__bound) {
            box.__bound = true;

            box.addEventListener("change", (ev) => {
                const sel = ev.target.closest("select.attSel");
                if (!sel) return;
                const eid  = sel.dataset.event;
                const name = sel.dataset.name;
                const val  = sel.value;
                draftSetAttend(eid, name, val || "");
                markUnsavedBadge(eid);
                updateSubmitButton();
            });

            box.addEventListener("input", (ev) => {
                const c = ev.target.closest("input.evComment");
                if (!c) return;
                const eid = c.dataset.event;
                draftSetComment(eid, c.value);
                markUnsavedBadge(eid);
                updateSubmitButton();
            });
        }

        updateSubmitButton();
    };

    /* ===== 出欠送信（ドラフト一括送信） ===== */
    window.onSubmit = async function onSubmit(){
        if (state.submitting) return;
        state.submitting = true;

        const btn = $("#btnSubmit");
        const backBtn = $("#btnBackFromForm");

        btn.disabled = true;
        btn.textContent = "送信中…";
        logForm("");
        if (backBtn) backBtn.disabled = true;

        // ★ ここでオーバーレイ ON
        toggleSubmitOverlay(true);

        const navGuard = (e) => {
            if (state.submitting) {
            e.preventDefault();
            e.returnValue = "";
            }
        };
        window.addEventListener("beforeunload", navGuard);

        try{
            // ★ 念のためここでも古いドラフトは掃除
            pruneDraftAgainstCurrentEvents();
            
            let payloads = draftBuildPayloads();

            // ★ 追加：コメントだけ変更されているケースを拾う
            if (!payloads.length) {
            const extra = [];
            const draftByEvent = (draft && draft.byEvent) || {};

            for (const [eventId, block] of Object.entries(draftByEvent)) {
                const comment = String(block.comment || "").trim();
                if (!comment) continue;  // コメントが空なら関係ない

                // ① そのイベントの既存回答を探す
                const ansList = (state.answers && state.answers[eventId]) || [];
                let performerName = "";
                let attend = "";

                if (ansList.length) {
                // 既に回答がある人を1人代表にする
                const a0 = ansList[0];
                performerName = a0.performerName || a0.name || "";
                attend       = a0.attend || "未定";
                } else {
                // まだ誰も回答していない場合 → 自分の名簿から1人拾う
                const m0 = (state.members || [])[0];
                if (m0) {
                    performerName = m0.performerName || m0.name || "";
                    attend        = "未定";
                }
                }

                if (!performerName) continue; // どう頑張っても名前が拾えなかったら諦める

                extra.push({
                eventId,
                performerName,
                attend,
                _eventComment: comment,
                });
            }

            if (!extra.length) {
                alert("送信する内容がありません（出欠の選択やコメントの変更がありません）");
                return;
            }

            // これで comment だけでも payload が作られる
            payloads = extra;
            }

            // イベントIDでグループ化（＋コメント触ったかどうかを記録）
            const grouped = {};
            const eventCommentMap = {};          // eventId -> コメント文字列
            const touchedEventSet = new Set();   // コメントを触った eventId

            for (const p of payloads) {
            if (!grouped[p.eventId]) grouped[p.eventId] = [];
            grouped[p.eventId].push({ performerName: p.performerName, attend: p.attend });

            if (Object.prototype.hasOwnProperty.call(p, '_eventComment')) {
                // ★ コメントを「触った」イベントだけ拾う
                eventCommentMap[p.eventId] = (p._eventComment || "");
                touchedEventSet.add(p.eventId);
            }
            }
            
            // ★ 追加：集計用
            let closedCleaned = [];   // 受付終了で掃除した eventId
            let successCount  = 0;    // 正常送信できたイベント数
            
            // イベント単位で送信（merge=1 を付ける）
            for (const [eventId, list] of Object.entries(grouped)) {
            const eCom    = String(eventCommentMap[eventId] || "");
            const touched = touchedEventSet.has(eventId);           // コメント欄を触ったイベントだけ送る
            
            const bulk = list.map((it, idx) => {
                const row = { performerName: it.performerName, attend: it.attend };
                if (touched && idx === 0) row.comment = eCom;         // 先頭レコードだけ comment キーを付与
                return row;
            });
            
            const url = `${API_ENDPOINT}?submitBulk=1`
                        + `&eventId=${esc(eventId)}`
                        + `&lineId=${esc(state.lineId)}`
                        + `&merge=1`
                        + `&bulk=${esc(JSON.stringify(bulk))}`;
            
            const r = await fetch(url);
            const j = await r.json();
            if (j.status !== "ok") {
                // ★ ここで「受付終了」を検知して、そのイベントのドラフトだけ掃除して続行
                const msg = String(j.message || j.error || "");
                if (/受付.*終了|締切.*過ぎ|公開.*終了|closed/i.test(msg)) {
                if (draft.byEvent && draft.byEvent[eventId]) {
                    delete draft.byEvent[eventId];
                    closedCleaned.push(String(eventId));
                }
                // 次のイベントへ（throwしない）
                continue;
                }
                // それ以外の失敗は従来通りエラー扱い
                throw new Error(`送信失敗（${eventId}）: ${j.message || "unknown"}`);
            }
            successCount++;
            }
            
            if (closedCleaned.length){
                draftSave();           // ← 削除の永続化
                updateSubmitButton();  // ← 送信ボタンの活性/非活性を反映
                logForm(`締切済みの未保存データ（${closedCleaned.length}件）を自動削除しました。`);
            }
            
            // ★ 全件「受付終了」で送れなかった場合
            if (successCount === 0){
            alert("すべて受付終了のため送信できる内容がありませんでした。");
            buildFormView(); // 表示を最新化
            return;
            }

            alert("送信しました");
            draftClear(); // ★ 送信成功で下書きを破棄
            show("#view-home");
            logHome("更新中…");
            await refreshData();
            logHome("");

        } catch(err) {
            logForm(err.message || String(err));
        } finally {
            window.removeEventListener("beforeunload", navGuard);
            state.submitting = false;
            btn.disabled = false;
            btn.textContent = "まとめて送信";
            backBtn && (backBtn.disabled = false);
            updateSubmitButton();

            // ★ 送信処理が終わったら必ず OFF
            toggleSubmitOverlay(false);
        }
    }

    // ★ 出欠フォーム用のイベントを
    //   - 編集可能（受付中）
    //   - 閲覧専用（受付終了）
    //   に分けるヘルパー（state は書き換えない）
    function splitEventsForForm(allEvents){
        const editableEvents = [];
        const readonlyEvents = [];

        // ★ 今日をローカルタイムゾーンの「日付だけ」で判定する
            const today = new Date();
            today.setHours(0, 0, 0, 0);  // その日の 0:00 にそろえる

            const y = today.getFullYear();
            const m = String(today.getMonth() + 1).padStart(2, "0");
            const d = String(today.getDate()).padStart(2, "0");
            const todayYmd = `${y}${m}${d}`;

        (allEvents || []).forEach(ev => {
            // 1) まずは既存フラグを優先して解釈
            const rawFlag = String(
                ev.accepting ??
                ev.formOpen ??
                ev.status ??
                ""
            ).toLowerCase();

            let accepting; // true = 受付中, false = 締切, undefined = 不明

            if (rawFlag === "open" || rawFlag === "true" || rawFlag === "y") {
                accepting = true;
            } else if (
                rawFlag === "closed" ||
                rawFlag === "close"  ||
                rawFlag === "false" ||
                rawFlag === "n"
            ) {
                accepting = false;
            }

            // 2) フラグで判定できなかったときは締切日で判定
            if (typeof accepting === "undefined") {
                const rawDeadline =
                    ev.deadline ||
                    ev.limit ||
                    ev.deadlineYmd ||
                    "";

                const digits = String(rawDeadline || "").replace(/[^0-9]/g, "");

                if (digits.length === 8) {
                    // 例: 2026-01-11 → 20260111
                    // 締切日 < 今日 なら「締切済み」
                    const dlYmd = digits;
                    const isClosedByDeadline = dlYmd < todayYmd;
                    accepting = !isClosedByDeadline;
                } else {
                    // 締切日が取れない場合は「受付中」とみなす（従来挙動に近い）
                    accepting = true;
                }
            }

            if (accepting) {
                editableEvents.push(ev);
            } else {
                readonlyEvents.push(ev);
            }
        });

        return { editableEvents, readonlyEvents };
    }
    })();

/* ===== 初回登録 ===== */
    function isNotifyOn_(val) {
    // false, "N", "0" → OFF
    if (val === false) return false;
    const s = String(val || "").trim().toUpperCase();
    if (s === "N" || s === "0") return false;
    return true; // それ以外は ON
    }

    // ★ "Y" / "N" / true / false / 1 / 0 などを全部 boolean にそろえる
    function normalizeNotifyFlag(raw) {
        if (raw === undefined || raw === null || raw === "") {
            // 初回はチェックなし
            return false;
        }
        if (raw === true || raw === false) return raw;

        const s = String(raw).trim().toUpperCase();
        if (s === "Y" || s === "1" || s === "TRUE")  return true;
        if (s === "N" || s === "0" || s === "FALSE") return false;

        // よく分からない値は安全側で OFF
        return false;
    }
    function resetRegisterForm(){
        $("#regInputName").value =
            state.inputName
            || state.name
            || "";

        $("#perfList").innerHTML = "";
        addPerformerField("");

        // ★ D1 → state.notify をそのまま使う
        $("#regNotify").checked = normalizeNotifyFlag(state.notify);
    }

    function buildRegisterFormFromMembers(){
        const inputName = 
            state.inputName           // D1 からの保存値が最優先
            || state.members[0]?.inputName
            || state.name
            || "";

        $("#regInputName").value = inputName;
        $("#perfList").innerHTML = "";

        // 演奏者の展開
        const list = (state.members || []).map(m => ({
            name: (m.performerName || "").trim(),
            seg : (m.segment || m?.区分 || "子どもの部")
        })).filter(x => x.name);

        if (list.length === 0){
            addPerformerField("", "子どもの部");
        } else {
            list.forEach(x => addPerformerField(x.name, x.seg));
        }

        // ★ ポイント：members[0].notify からは取らない
        //   D1 → refreshData で決めた state.notify をそのまま使う
        const notifyFlag = normalizeNotifyFlag(state.notify);
        state.notify = notifyFlag;                   // 状態も更新
        $("#regNotify").checked = notifyFlag;        // チェックボックスに反映
    }
    function addPerformerField(value="", segValue="子どもの部"){
    const id = "perf_" + Math.random().toString(36).slice(2);
    const row = document.createElement("div");

    // ここを perfRow（Grid レイアウト）に変更
    row.className = "perfRow";

    row.innerHTML = `
        <label for="${id}" class="perfLabel">演奏者名</label>
        <input type="text" id="${id}" class="regPerf"
            value="${h(value || "")}"
            placeholder="例：藤塚 太郎">
        <select class="regPerfSeg selectBtn">
        <option value="子どもの部" ${segValue==="子どもの部"?"selected":""}>子どもの部</option>
        <option value="大人の部"   ${segValue==="大人の部"  ?"selected":""}>大人の部</option>
    </select>
        <button type="button" class="btn btn-remove btn-sm"
                onclick="this.closest('.perfRow').remove()"
                aria-label="この演奏者を削除">削除</button>
    `;
    document.getElementById("perfList").appendChild(row);
    }
    async function onRegister(){
        try{
            logReg("");
            const inputName = $("#regInputName").value.trim();
            if (!inputName) throw new Error("入力者氏名を入力してください");

            // ★ チェック状態をそのまま notify に
            const checked = !!$("#regNotify")?.checked;
            const notify = checked;        // チェックあり → 通知 Y
            const viewerOnly = !checked;   // チェックなし → 閲覧者 Y

            // {name, segment} の配列（空文字は除外）
            const items = Array.from(document.querySelectorAll(".perfRow")).map(row=>{
            const name = row.querySelector(".regPerf")?.value.trim();
            const seg  = row.querySelector(".regPerfSeg")?.value || "子どもの部";
            return name ? { name, segment: seg } : null;
            }).filter(Boolean);

            // ★ バリデーションはシンプルにこのままでもOK
            //   （閲覧者でも演奏者が入っていてもいい、という運用なら触らなくてOK）
            if (!viewerOnly && items.length === 0){
            throw new Error("演奏者を1名以上入力してください");
            }

            $("#btnRegister").disabled = true;
            $("#btnRegister").textContent =
            (registerMode==="edit" ? "保存中…" : "登録中…");

            toggleRegOverlay(true);

            const listJson = JSON.stringify(items);

            let url = "";
            if (registerMode === "edit") {
            url = `${API_ENDPOINT}?replaceMembers=1`
                + `&lineId=${esc(state.lineId)}`
                + `&inputName=${esc(inputName)}`
                + `&list2=${esc(listJson)}`
                + `&purge=0`
                + `&notify=${notify?1:0}`          // ← チェック状態そのまま
                + `&viewerOnly=${viewerOnly?1:0}`; // ← チェックの反転
            } else {
            url = `${API_ENDPOINT}?registerBulk=1`
                + `&lineId=${esc(state.lineId)}`
                + `&inputName=${esc(inputName)}`
                + `&list2=${esc(listJson)}`
                + `&notify=${notify?1:0}`
                + `&viewerOnly=${viewerOnly?1:0}`;
            }

            const r = await fetch(url);
            const j = await r.json();
            if (j.status !== "ok") throw new Error(j.message || "登録に失敗しました");

            state.notify    = notify;
            state.inputName = inputName;

            alert(
            registerMode==="edit"
                ? "氏名を保存しました"
                : (viewerOnly ? "閲覧者として登録しました" : "初回登録が完了しました")
            );

            show("#view-home");
            logHome("更新中…");
            await refreshData();
            logHome("");

        }catch(err){
            logReg(err.message || String(err));
        }finally{
            toggleRegOverlay(false);
            $("#btnRegister").disabled = false;
            $("#btnRegister").textContent =
            (registerMode==="edit" ? "保存" : "登録する");
        }
    }
/* ===== 今後の予定（Schedules） v5 ===== */
    (() => {
    // === 多重読み込みガード ===
    if (window.__SchedulesBlockV__ && window.__SchedulesBlockV__ >= 6) return;
    window.__SchedulesBlockV__ = 6;

    // === 定数・種別ごとのクラス定義 ===
    const KIND_CLASS = {
        '発表': 'badge--announce',
        '練習': 'badge--practice',
        'その他': 'badge--other',
    };

    // === フィルタ保存/復元（localStorage） ============================
    const FILTER_KEY = 'sched:filters:v1';

    function saveFilters() {
        try {
        const o = {
            days: document.getElementById('selDays')?.value || '60',
            kind: document.getElementById('selKind')?.value || '',
            seg : document.getElementById('selSeg') ?.value || '',
        };
        localStorage.setItem(FILTER_KEY, JSON.stringify(o));
        } catch (_) {}
    }

    function loadFilters() {
        try {
        const o = JSON.parse(localStorage.getItem(FILTER_KEY) || '{}');
        if (o.days && document.getElementById('selDays')) {
            document.getElementById('selDays').value = o.days;
        }
        if (o.kind && document.getElementById('selKind')) {
            document.getElementById('selKind').value = o.kind;
        }
        // seg は「両方所属ユーザー」のみ有効
        if (o.seg && document.getElementById('selSeg') && userHasBoth()) {
            document.getElementById('selSeg').value = o.seg;
        }
        } catch (_) {}
    }

    // 他スクリプトから安全に呼べるように公開
    window.__schedSaveFilters = saveFilters;
    window.__schedLoadFilters = loadFilters;

    // 旧コードが素の saveFilters()/loadFilters() を呼んでも落ちないようにするラッパ
    window.saveFilters = function () {
        return window.__schedSaveFilters.apply(null, arguments);
    };
    window.loadFilters = function () {
        return window.__schedLoadFilters.apply(null, arguments);
    };

    // === 日付・時間ユーティリティ ====================================
    function parseYmdStrictLocal(s) {
        const m = String(s || "").match(/^(\d{4})[\/\-](\d{2})[\/\-](\d{2})$/);
        if (!m) return null;
        const d = new Date(+m[1], +m[2] - 1, +m[3]);
        d.setHours(0, 0, 0, 0);
        return isNaN(d) ? null : d;
    }

    function addDays(d, n) {
        const x = new Date(d.getTime());
        x.setDate(x.getDate() + n);
        x.setHours(0, 0, 0, 0);
        return x;
    }

    // 「なんかよく分からない時間の値」を HH:MM に正規化
    function toHmFromAny(raw) {
        const s = String(raw || "").trim();
        if (!s) return "";
        // すでに "9:15" / "09:15" 形式ならそのまま正規化
        const m = s.match(/^(\d{1,2}):(\d{2})/);
        if (m) {
        return `${String(+m[1]).padStart(2, "0")}:${m[2]}`;
        }
        // "Sat Dec 30 1899 ..." など Date で解釈できるものは HH:MM に
        const d = new Date(s);
        if (isNaN(d)) return "";
        const z = n => String(n).padStart(2, "0");
        return `${z(d.getHours())}:${z(d.getMinutes())}`;
    }

    // === 1件分カード描画 ==============================================
    function renderScheduleCard(it) {
        const segNorm  = normSeg(it.segment || it.segmentCode || it.targetSegment || it.attendSegment || "");
        const segLabel = dispSeg(segNorm);

        const rawDateText = ymdDow(parseYmdStrictLocal(it.ymd || it.date)) || (it.date || "");
        const kindText    = String(it.kind || "").trim();
        const kindCls     = KIND_CLASS[kindText] || "";
        const memoText    = String(it.memo || "").trim();
        const titleText   = String(it.title || "").trim();
        const placeText   = String(it.place || "").trim();
        const meetPlace   = String(it.meetPlace || "").trim();

        // エスケープ済み文字列
        const dateSafe     = h(rawDateText);
        const kindSafe     = h(kindText);
        const memoSafe     = h(memoText);
        const titleSafe    = h(titleText);
        const placeSafe    = h(placeText);
        const segLabelSafe = h(segLabel || "");

        // 本番会場（@若竹苑 など）
        const placeTxt = placeText ? `@${placeSafe}` : "";

        // ★ 時刻はどんな形式でも HH:MM に揃える
        const hm        = toHmFromAny(it.performAt || it.time || it.hm || it["時間"] || "");
        const meetAtHHM = toHmFromAny(it.meetAt || "");

        // 集合 行きのテキスト：「集合 HH:MM 場所」
        const meetTxtRaw = [
        (meetAtHHM ? `集合 ${meetAtHHM}` : ""),
        meetPlace
        ].filter(Boolean).join(" ");
        const meetTxtSafe = h(meetTxtRaw);

        const timeForHeader = hm
        ? (kindText === "発表" ? `演奏開始 ${hm}` : hm)
        : "";

        // ここは HTML 断片を含むのでエスケープしない
        const timeForPanel = hm
        ? (kindText === "発表"
            ? `<span class="lbl">演奏開始</span> ${hm}`
            : `${hm}`)
        : "";

        // 折りたたみ内の中身（タイトルは出さない：演奏開始 / 集合 / @場所）
        const panelInner = `
        ${[hm, meetTxtRaw, placeTxt, memoText].filter(Boolean).length ? `
            <div class="scMeta">
            ${placeTxt   ? `<div class="scLine">${placeTxt}</div>` : ``}
            ${hm         ? `<div class="scLine">${timeForPanel}</div>` : ``}
            ${meetTxtRaw ? `<div class="scLine">${meetTxtSafe}</div>` : ``}
            ${memoText   ? `<div class="scLine scMemo">${memoSafe}</div>` : ``}
            </div>
        ` : ``}
        `;

        return `
        <div class="card scheduleCard" data-seg="${segNorm || 'both'}">
            <!-- 1行目：左=区分 / 右=種別 -->
            <div class="scTop">
            ${segLabel ? `<span class="seg-badge ${segNorm==='adult'?'seg-adult':segNorm==='child'?'seg-child':'seg-both'}">${segLabelSafe}</span>` : ``}
            ${kindText ? `<span class="scKind ${kindCls}">${kindSafe}</span>` : ``}
            </div>

            <!-- 2行目：日付 + タイトル（1行省略） -->
            <button type="button" class="scTitleBtn" aria-expanded="false">
            <span class="scDate">${dateSafe}</span>
            <span class="scTitle">${titleSafe}</span>
            <span class="scCaret" aria-hidden="true">∨</span>
            </button>

            <!-- 3行目以降：折りたたみ（フルタイトル/メモ/@場所・集合） -->
            <div class="scPanel" hidden>${panelInner}</div>
        </div>`;
    }

    // === 一覧描画ヘルパ ================================================
    window.renderSchedulesView = function (list) {
        if (!Array.isArray(list) || list.length === 0) {
        return `<div class="listEmpty">該当する予定はありません</div>`;
        }
        return list.map(renderScheduleCard).join("");
    };

    // 区分フィルタの表示/非表示を他ブロックから呼べるように
    function exposeSegFilterIfNeeded() {
        if (typeof updateSegFilterUI === "function") updateSegFilterUI();
    }

    // === ローカル再描画（UIの選択だけで即時フィルタ） ================
    function renderSchedulesLocal() {
        const box = $("#schedulesBox");

        // まだ初回取得前なら待機表示
        if (!Array.isArray(state.schedulesRaw) || state.schedulesRaw.length === 0) {
        box.innerHTML = `読み込み待機中（「再取得」を押すと読み込みます）`;
        return;
        }

        const base = state.schedulesRaw.slice();

        // 日数（セレクトの値を安全に取得）
        const selDaysEl = document.getElementById('selDays');
        const days = Number(selDaysEl && selDaysEl.value ? selDaysEl.value : 60) || 60;

        const kindSel = document.getElementById('selKind')?.value || "";

        // 1) 期間フィルタ
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const until = addDays(today, days);
        let arr = base.filter(it => {
        const d = parseYmdStrictLocal(it.ymd || it.date);
        return d && d >= today && d <= until;
        });

        // 2) 種別フィルタ
        if (kindSel) {
        arr = arr.filter(it => String(it.kind || "").trim() === kindSel);
        }

        // 3) ユーザー区分（アカウント所属で絞り込み）
        const segSet = getMemberSegSet();
        arr = arr.filter(it => {
        const evSeg = it.segment || it.segmentCode || it.targetSegment || it.attendSegment || "";
        return eventVisibleForUser(evSeg, segSet, /* includeBoth */ true);
        });

        // 4) 両方所属ユーザーのみ、UI区分フィルタ
        if (segSet && segSet.size > 0 && userHasBoth()) {
        const uiSeg = $("#selSeg")?.value || "";
        if (uiSeg) {
            arr = arr.filter(it => {
            const code = normSeg(it.segment || it.segmentCode || it.targetSegment || it.attendSegment || "");
            return code === uiSeg || code === "both";
            });
        }
        }

        state.schedules = arr;
        box.innerHTML = window.renderSchedulesView(state.schedules);
    }

    // === 初回 or 再取得時だけ API を叩く ================================
    window.renderSchedules = async function (initial = false) {
        const box = $("#schedulesBox");

        try {
        if (initial) {
            box.innerHTML = `読み込み中… <span class="spinner"></span>`;
            exposeSegFilterIfNeeded();
            loadFilters();

            // 初回は広めの日数で全件を取得（例: 180日）
            // ★ D1 が使えれば /line/schedules を叩く
            let r;
            if (D1_BASE) {
            const url  = `${D1_BASE}/line/schedules?days=180`;
            const resp = await fetch(url, { method: "GET" });
            if (!resp.ok) {
                throw new Error(`schedules http error: ${resp.status}`);
            }
            r = await resp.json();
            } else {
            // ★ 保険として従来の GAS API にフォールバック
            const url = `?schedules=1&days=180`;
            r = await api(url);
            }

            if (!r || r.status !== "ok" || !Array.isArray(r.schedules)) {
                box.innerHTML = `<span class="err">取得に失敗しました</span>`;
                return;
            }

            // ★ 生データを保持（以後はローカルでフィルタ）
            state.schedulesRaw = r.schedules.slice();

            // ★ Home の閲覧者カード用に、全予定をグローバルへも公開
            window.__ALL_SCHEDULES__ = state.schedulesRaw;
            console.log("[sched] window.__ALL_SCHEDULES__ length =", window.__ALL_SCHEDULES__.length);

            // ★ HomeEventsUI に「データ入ったよ」と知らせて再描画
            if (window.HomeEventsUI && typeof window.HomeEventsUI.render === "function") {
                console.log("[sched] call HomeEventsUI.render() after schedules load");
                window.HomeEventsUI.render();
            }
        }

        // 取得済みデータを UI 値でフィルタして描画
        renderSchedulesLocal();

        } catch (err) {
        box.innerHTML = `<span class="err">エラー: ${err.message || err}</span>`;
        }
    };

    // === 互換 API（外部からの呼び出し用） ==============================
    window.loadSchedules = function () {
        window.renderSchedules(false);
    };

    // === ICS フィード URL コピー =======================================
    window.copyIcsFeed = async function () {
        const ipt = $("#icsFeedUrl");
        if (!ipt) return;
        try {
        ipt.select();
        if (window.isSecureContext && navigator?.clipboard?.writeText) {
            await navigator.clipboard.writeText(ipt.value);
        } else {
            // 非HTTPSや古い環境向けフォールバック
            const ta = document.createElement('textarea');
            ta.value = ipt.value;
            document.body.appendChild(ta);
            ta.select();
            document.execCommand('copy');
            document.body.removeChild(ta);
        }
        alert("購読URLをコピーしました");
        } catch (e) {
        console.error(e);
        alert("コピーに失敗しました");
        }
    };

    // === DOM ロード後のイベントバインド ================================
    document.addEventListener('DOMContentLoaded', () => {
        document.getElementById('selDays')
        ?.addEventListener('change', () => { renderSchedulesLocal(); saveFilters(); });
        document.getElementById('selKind')
        ?.addEventListener('change', () => { renderSchedulesLocal(); saveFilters(); });
        document.getElementById('selSeg')
        ?.addEventListener('change', () => { renderSchedulesLocal(); saveFilters(); });

        // カード全体をタップで開閉（リンクは除外）
        document.getElementById('schedulesBox')
        ?.addEventListener('click', (e) => {
            // リンクをクリックしたときは開閉しない
            if (e.target.closest('a')) return;

            const card  = e.target.closest('.scheduleCard');
            if (!card) return;

            const btn   = card.querySelector('.scTitleBtn');
            const panel = card.querySelector('.scPanel');
            const caret = card.querySelector('.scCaret');
            if (!btn || !panel || !caret) return;

            const expanded = card.getAttribute('data-expanded') === 'true';
            // 切り替え
            card.setAttribute('data-expanded', String(!expanded));
            btn.setAttribute('aria-expanded', String(!expanded));
            panel.hidden = expanded;                  // true→隠す / false→表示
            caret.textContent = expanded ? '∨' : '∧'; // 矢印を文字で切り替え
        });
        // ★ ここを追加：閲覧者カード用にスケジュールを事前取得
            if (document.getElementById('viewerEventsBox')) {
                window.renderSchedules(true).catch(err => {
                    console.error("[sched] initial renderSchedules error", err);
                });
            }
    });
    })();

/* ===== 予定登録（管理者） ===== */
    /* ▼ 種別変更に応じてフォームの活性状態・自動入力を切り替える */
    function adminTypeChangeAdapt(){
        const t         = $("#ad_type").value;
        const meetAt    = $("#ad_meetAt");
        const meetPlace = $("#ad_meetPlace");
        const attend    = $("#ad_attendTarget");
        const deadline  = $("#ad_deadline");
        const hm        = $("#ad_hm");
        const place     = $("#ad_place");

        // ユーザーが手で触ったら「自動入力フラグ」を解除（初回のみバインド）
        if (hm && !hm.__autoBindAutoFlag) {
            hm.addEventListener('input', () => { hm.dataset.autofilled = "0"; }, { once:true });
            hm.__autoBindAutoFlag = true;
        }
        if (place && !place.__autoBindAutoFlag) {
            place.addEventListener('input', () => { place.dataset.autofilled = "0"; }, { once:true });
            place.__autoBindAutoFlag = true;
        }

        // 出欠対象プルダウンをユーザーが触ったかを記録（1回だけ）
        if (attend && !attend.__touchBound){
            attend.addEventListener('change', () => { attend.dataset.touched = "1"; }, { once:true });
            attend.__touchBound = true;
        }
        
        if (t === "練習"){
            // 無効化（色はCSSで統一）
            $("#ad_meetAt").value    = "";  meetAt.disabled    = true;
            $("#ad_meetPlace").value = "";  meetPlace.disabled = true;
            attend.value = "N";             attend.disabled    = true;
            $("#ad_deadline").value  = "";  deadline.disabled  = true;
            updateFlagOptions({ type:t, forceN:true, disable:true });

            // ★ デフォルト自動入力（未入力のときだけ）
            if (hm && !hm.value){
            hm.value = "17:15";
            hm.dataset.autofilled = "1";
            }
            if (place && !place.value){
            place.value = "藤塚小学校体育館";
            place.dataset.autofilled = "1";
            }

        } else if (t === "発表"){
            meetAt.disabled    = false;
            meetPlace.disabled = false;
            attend.disabled    = false;
            deadline.disabled  = false;
            updateFlagOptions({ type:t, forceN:false, disable:false });

            // 新規作成時のみ、かつ未タッチなら Y を既定セット
            if (typeof adminMode !== "undefined" && adminMode === "create" &&
                attend && attend.dataset.touched !== "1"){
            attend.value = "Y";
            }

            // 練習以外に戻したとき：自動入力だった分だけクリア
            if (hm?.dataset.autofilled === "1"){ hm.value = ""; }
            if (place?.dataset.autofilled === "1"){ place.value = ""; }
            if (hm) hm.dataset.autofilled = "0";
            if (place) place.dataset.autofilled = "0";

        } else { // その他
            meetAt.disabled    = false;
            meetPlace.disabled = false;
            attend.value       = "N";
            attend.disabled    = true;
            deadline.disabled  = false;
            updateFlagOptions({ type:t, forceN:true, disable:true });

            // 同上：自動入力だった分だけクリア
            if (hm?.dataset.autofilled === "1"){ hm.value = ""; }
            if (place?.dataset.autofilled === "1"){ place.value = ""; }
            if (hm) hm.dataset.autofilled = "0";
            if (place) place.dataset.autofilled = "0";
        }
    }

    /* ▼ 種別/モードに応じて「配信フラグ」プルダウンの候補を組み立てる */
    function updateFlagOptions({ type, forceN=false, disable=false }){
        const sel = $("#ad_flag");
        const cur = sel.value || "N";
        sel.innerHTML = ""; // いったん空に

        const opt = (v, label)=> {
            const o = document.createElement("option");
            o.value = v; o.textContent = label;
            sel.appendChild(o);
        };

        if (type === "発表" && !forceN){
            if (adminMode === "create"){
            opt("N","N");
            opt("Y","Y（初回配信対象）");
            }else{
            opt("N","N");
            opt("Y","Y（初回配信対象）");
            opt("S","S（初回配信済）");
            opt("D","D（締切超過/締切停止）");
            }
        }else{
            opt("N","N");
        }

        const allowed = Array.from(sel.options).map(o=>o.value);
        sel.value = allowed.includes(cur) ? cur : "N";
        sel.disabled = !!disable;
    }

    /* ▼ 「新規登録」モードにフォームを初期化する */
    function enterAdminCreateMode(){
        adminMode = "create";
        adminEditingId = "";
        $("#adminFormTitle").textContent = "新規登録";
        $("#adminEditingId").style.display = "none";
        $("#btnAdminSubmit").textContent = "新規登録";
        $("#ad_title").value = "";
        $("#ad_type").value = "";
        $("#ad_ymd").value = "";
        $("#ad_hm").value = "";
        $("#ad_place").value = "";
        $("#ad_meetAt").value = "";
        $("#ad_meetPlace").value = "藤塚小学校";
        $("#ad_attendTarget").value = "N";
        $("#ad_deadline").value = "";
        $("#ad_publish").value = "Yes";
        $("#ad_status").value = "active";
        $("#ad_status").disabled = true;  // ★ 追加：新規は編集不可に
        $("#ad_flag").innerHTML = `<option value="N" selected>N</option><option value="Y">Y（初回配信対象）</option>`;
        $("#ad_flag").value = "N";

        // 対象区分デフォルト＝子ども（明示）
        $("#ad_segment").value = "子ども";

        adminTypeChangeAdapt();
        logAdmin("");
    }

    function toDateInputFromAnyYmd(s){
    const str = String(s || "").trim();
    if (!str) return "";

    let y, m, d;

    // 1) 8桁 "20260111"
    const m8 = str.match(/^(\d{4})(\d{2})(\d{2})$/);
    if (m8) {
        y = m8[1]; m = m8[2]; d = m8[3];
    } else {
        // 2) "2026/01/11" or "2026-1-3" みたいなやつ
        const m2 = str.replace(/-/g, "/").match(/^(\d{4})\/(\d{1,2})\/(\d{1,2})$/);
        if (!m2) return ""; // 想定外フォーマットなら諦めて空
        y = m2[1]; m = m2[2]; d = m2[3];
    }

    const mm = String(m).padStart(2, "0");
    const dd = String(d).padStart(2, "0");
    return `${y}-${mm}-${dd}`;   // ← input[type=date] 用
    }

    /* ▼ 一覧から選んだ既存イベントを「編集」モードでフォームに展開する */
    function fillAdminFormFromItem(it){
        adminMode = "edit";
        adminEditingId = it.id || "";
        $("#adminFormTitle").textContent = `編集：${adminEditingId}`;
        $("#adminEditingId").style.display = "";
        $("#adminEditingId").textContent = `ID: ${adminEditingId}`;
        $("#btnAdminSubmit").textContent = "保存";

        $("#ad_title").value = it.title || "";
        $("#ad_type").value  = it.type || "";
        $("#ad_ymd").value   = toDateInputFromAnyYmd(it.ymd || "");
        $("#ad_hm").value    = it.hm || "";
        $("#ad_place").value = it.place || "";
        $("#ad_meetAt").value = it.meetAt || "";
        $("#ad_meetPlace").value = it.meetPlace || "";
        $("#ad_attendTarget").value = (it.attendTarget||"N");
        $("#ad_deadline").value = toDateInputFromYmdSlash(it.deadline || "");
        $("#ad_publish").value = it.publish || "Yes";
        $("#ad_status").value  = it.status  || "active";
        $("#ad_status").disabled = false; // ★ 追加：編集時はプルダウンを有効化
        $("#ad_segment").value = it.segment || "子ども";

        adminTypeChangeAdapt();
        $("#ad_flag").value = it.flag || "N";
        if (![...$("#ad_flag").options].map(o=>o.value).includes($("#ad_flag").value)){
            $("#ad_flag").value = "N";
        }
        logAdmin("");
    }

   /* ▼ 管理フォームの入力値を検証し、API に投げて新規登録/更新する */
    async function adminSubmit(){
        if (!state.isAdmin){
            alert("管理者のみ利用できます");
            return;
        }

        const isEdit      = (adminMode === "edit");
        const loadingMsg  = isEdit ? "保存中…" : "登録中…";
        const successMsg  = isEdit ? "保存しました" : "登録しました";

        // ★ ここでモーダルを出す（外側で try/finally）
        showSavingModal(loadingMsg);

        try {
            await withLoadingSnackbar(
            loadingMsg,
            successMsg,
            async () => {
                logAdmin("");

                const type  = $("#ad_type").value.trim();
                let   title = $("#ad_title").value.trim();
                const ymdIn = $("#ad_ymd").value.trim();   // yyyy-mm-dd
                const hm    = $("#ad_hm").value.trim();
                const place = $("#ad_place").value.trim();
                const meetAt= $("#ad_meetAt").value.trim();
                const meetPl= $("#ad_meetPlace").value.trim();
                const attT  = $("#ad_attendTarget").value.trim().toUpperCase();
                const dlIn  = $("#ad_deadline").value.trim();
                const pub   = $("#ad_publish").value.trim();
                const st    = (adminMode === "create")
                                ? "active"
                                : $("#ad_status").value.trim();
                const segRaw = $("#ad_segment").value.trim();

                let seg = segRaw;
                if (seg.includes("大人")) seg = "大人";
                else if (seg.includes("子ども") || seg.includes("子供")) seg = "子ども";
                else if (seg.includes("両方")) seg = "両方";

                if (!title || !type || !ymdIn){
                throw new Error("タイトル/種別/公演日は必須です");
                }

                if (type === "発表"){
                const flag    = $("#ad_flag").value.trim();
                const allowed = (adminMode==="create") ? ["Y","N"] : ["Y","S","D","N"];
                if (!flag || !allowed.includes(flag)){
                    throw new Error(
                    adminMode==="create"
                        ? "配信フラグは Y または N を選択してください（発表/新規）"
                        : "配信フラグは Y/S/D/N から選択してください（発表/編集）"
                    );
                }
                }

                let meetAtSend = meetAt;
                let meetPlSend = meetPl;
                let attSend    = attT;
                let dlSend     = dlIn;

                if (type==="練習"){
                meetAtSend = "";
                meetPlSend = "";
                attSend    = "N";
                dlSend     = "";
                }
                if (type!=="発表"){
                attSend = "N";
                }

                const ymd = toYmdSlashFromDateInput(ymdIn);
                const dl  = dlSend ? toYmdSlashFromDateInput(dlSend) : "";

                const btn = $("#btnAdminSubmit");
                if (btn) btn.disabled = true;

                try{
                let urlBase =
                    `?adminUpsertSchedule=1&lineId=${esc(state.lineId)}`
                    + `&type=${esc(type)}&title=${esc(title)}&ymd=${esc(ymd)}`
                    + (hm?        `&hm=${esc(hm)}`                     : "")
                    + (place?     `&place=${esc(place)}`               : "")
                    + (meetAtSend?`&meetAt=${esc(meetAtSend)}`         : "")
                    + (meetPlSend?`&meetPlace=${esc(meetPlSend)}`      : "")
                    + `&attendTarget=${esc(attSend)}`
                    + (dl?        `&deadline=${esc(dl)}`               : "")
                    + `&publish=${esc(pub)}&status=${esc(st)}`
                    + `&segment=${esc(seg)}`;

                $("#btnAdminSubmit").disabled = true;
                $("#btnAdminSubmit").textContent = isEdit ? "保存中…" : "登録中…";

                let res;
                if (adminMode === "create"){
                    if (type==="発表"){
                    const flag = $("#ad_flag").value.trim();
                    urlBase += `&flag=${esc(flag)}`;
                    } else {
                    urlBase += `&flag=N`;
                    }

                    res = await api(urlBase);

                    // CORS フォールバックで {status:'ok', note:'...'} が返るケースもある
                    if (res && res.status && res.status !== "ok"){
                    throw new Error(res.message || "登録に失敗しました");
                    }

                    // スプレッドシート保存後の UI 更新
                    enterAdminCreateMode();
                    await adminListFetch();

                } else {
                    if (!adminEditingId){
                    throw new Error("編集対象IDが不正です");
                    }

                    const url =
                    urlBase
                    + `&id=${esc(adminEditingId)}`
                    + (type==="発表"
                        ? `&flag=${esc($("#ad_flag").value.trim())}`
                        : `&flag=N`);

                    res = await api(url);
                    if (res && res.status && res.status !== "ok"){
                    throw new Error(res.message || "保存に失敗しました");
                    }

                    await adminListFetch();

                    // ★ ここでフォームを「新規モード」に戻す
                    enterAdminCreateMode();  
                }

                // ここまでエラーが出なければ withLoadingSnackbar が
                // successMsg（保存しました / 登録しました）を表示してくれる
                } finally {
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = isEdit ? "保存" : "新規登録";
                }
                }
            }
            );
        } finally {
            // ★ 成功・失敗に関わらずモーダルは閉じる
            hideSavingModal();
        }
    }

    /* ▼ 一覧タブの「予定一覧」を取得（D1 優先・ダメなら GAS フォールバック） */
    async function adminListFetch() {
    try {
        const top = document.getElementById("adminListBoxTop");
        if (top) {
        top.innerHTML = `読み込み中… <span class="spinner"></span>`;
        }

        const days = Number($("#ad_days").value || 60);
        let items = [];

        // 1) D1 から取得（速いルート）
        if (D1_BASE && state.lineId) {
        try {
            const u = new URL("/admin/events/list", D1_BASE);
            u.searchParams.set("lineId", state.lineId);
            u.searchParams.set("days", String(days)); // 将来サーバ側で使いたくなったとき用

            const res  = await fetch(u.toString());
            const json = await res.json();

            if (json && json.status === "ok" && Array.isArray(json.items)) {
            items = json.items;
            } else {
            console.warn("[adminListFetch] D1 bad response:", json);
            }
        } catch (e) {
            console.warn("[adminListFetch] D1 fetch failed, fallback to GAS:", e);
        }
        }

        // 2) D1 で取れなかったら GAS にフォールバック
        if (!items.length) {
        const r = await api(
            `?adminListSchedules=1&lineId=${esc(state.lineId)}&days=${esc(days)}`
        );
        if (r.status !== "ok" || !Array.isArray(r.items)) {
            if (top) top.innerHTML = `<span class="err">取得に失敗しました</span>`;
            return;
        }
        items = r.items;
        }

        if (!items.length) {
        if (top) {
            top.innerHTML = `<div class="listEmpty">該当する予定はありません</div>`;
        }
        state.adminItemsRaw = [];
        adminItemsMap = {};
        return;
        }

        // ★ D1 / GAS 両対応の正規化
        const raw = items
        .map(ev => ({
            id: String(
            ev.id ||
            ev.eventId ||
            ev.event_id ||
            ev.event_key ||
            ev.eventKey ||
            ""
            ).trim(),
            type : ev.type  || ev.kind  || "",
            title: ev.title || ev.name  || "",
            ymd  : ev.ymd   || ev.date  || "",
            hm   : ev.hm    || ev.time  || "",
            place: ev.place || "",
            meetAt:
            ev.meetAt     ||
            ev.meet_at    ||
            ev.callTime   ||
            ev.call_time  ||
            "",
            meetPlace:
            ev.meetPlace  ||
            ev.meet_place ||
            ev.callPlace  ||
            ev.call_place ||
            "",
            attendTarget:
            ev.attendTarget    ||
            ev.attend_target   ||
            ev.needAttendance  ||
            ev.need_attendance ||
            "N",
            deadline:
            ev.deadline      ||
            ev.deadlineDate  ||
            ev.deadline_date ||
            "",
            publish:
            ev.publish      ||
            ev.publishFlag  ||
            ev.publish_flag ||
            "",
            status: ev.status || "archived",
            flag:
            ev.flag             ||
            ev.distributeFlag   ||
            ev.distribute_flag  ||
            ev.pushFlag         ||
            ev.push_flag        ||
            "N",
            segment:
            ev.segment        ||
            ev.targetSegment  ||
            ev.target_segment ||
            ev.attendSegment  ||
            ev.targetGroup    ||
            ev.target_group   ||
            "",
        }))
        .filter(it => it.id); // id 無しは念のため除外

        // ★ 生配列を保存（ここから先はローカルフィルタだけ）
        state.adminItemsRaw = raw;

        // 編集用マップは全件から作成
        adminItemsMap = {};
        raw.forEach(it => {
        adminItemsMap[String(it.id)] = it;
        });

        // 既存のローカル描画（期間・区分フィルタ & status=active フィルタ）が走る
        adminListRenderLocal();
    } catch (err) {
        const topEl = document.getElementById("adminListBoxTop");
        if (topEl) {
        topEl.innerHTML = `<span class="err">エラー：${h(err.message || String(err))}</span>`;
        }
    }
    }

    /* ▼ 取得済みの adminItemsRaw を期間/区分でローカルフィルタして一覧に描画 */
    function adminListRenderLocal(){
        const top = document.getElementById('adminListBoxTop');
        if (!top) return;

        // まだfetchしてない場合のガード
        const base = Array.isArray(state.adminItemsRaw) ? state.adminItemsRaw.slice() : [];
        if (base.length === 0){
            top.innerHTML = `<div class="listEmpty">読み込み待機中（「一覧を取得」を押してください）</div>`;
            return;
        }

        const days = Number($("#ad_days").value || 60);
        const segFilter = $("#ad_seg_filter")?.value || "";

        // 期間フィルタ（今日〜days）
        const today = new Date(); today.setHours(0,0,0,0);
        const until = new Date(today.getTime()); until.setDate(until.getDate()+days);

            const ymdToDate = (s) => {
            const str = String(s || "").trim();
            if (!str) return null;

            let y, m, d;

            // 1) 8桁数字 20260111
            const m8 = str.match(/^(\d{4})(\d{2})(\d{2})$/);
            if (m8) {
            y = +m8[1];
            m = +m8[2];
            d = +m8[3];
            } else {
            // 2) 2026-01-11 / 2026/01/11
            const m2 = str.replace(/-/g, "/").match(/^(\d{4})\/(\d{2})\/(\d{2})$/);
            if (!m2) return null;
            y = +m2[1];
            m = +m2[2];
            d = +m2[3];
            }

            const dt = new Date(y, m - 1, d);
            dt.setHours(0, 0, 0, 0);
            return isNaN(dt) ? null : dt;
        };

          // ★ base を元にローカル絞り込み
            let viewItems = base.filter(it=>{
                // ① アーカイブは除外
                const status = String(it.status || "").toLowerCase();
                if (status === "archived") return false;

                // ② 期間フィルタ（今日〜days）
                const d = ymdToDate(it.ymd);
                return d && d >= today && d <= until;
            });

        if (segFilter){
            viewItems = viewItems.filter(it => normSeg(it.segment) === segFilter);
        }

        // 並び順（現行と同じキー）
            const ymdKey = (s) => {
            const d = ymdToDate(s);
            if (!d) return "99999999";
            const z = n => String(n).padStart(2, "0");
            return `${d.getFullYear()}${z(d.getMonth()+1)}${z(d.getDate())}`;
        };

        const hmKey = (s) => {
            // D1 が変な Date 文字列を返しても fmtTime 経由で HH:MM に揃える
            const hhmm = fmtTime(s);
            const m = hhmm.match(/^(\d{1,2}):(\d{2})$/);
            return m ? `${String(m[1]).padStart(2, "0")}${m[2]}` : "9999";
        };
        viewItems.sort((a,b)=>
            ymdKey(a.ymd).localeCompare(ymdKey(b.ymd)) ||
            hmKey(a.hm).localeCompare(hmKey(b.hm)) ||
            String(a.title||"").localeCompare(String(b.title||"")) ||
            String(a.id||"").localeCompare(String(b.id||""))
        );

        // HTML（adminItemsMap は全件分が入っているのでそのまま使える）
        const html = viewItems.length
            ? viewItems.map(it => {
                const ymdDisp      = fmtYmd(it.ymd);
                const hmDisp       = fmtTime(it.hm);
                const deadlineDisp = it.deadline ? fmtYmd(it.deadline) : "(なし)";
                const segNorm      = normSeg(it.segment || "");
                
                // ★ エスケープしてから埋め込む
                const ymdSafe      = h(ymdDisp);
                const hmSafe       = h(hmDisp);
                const placeSafe    = h(it.place || "");
                const segLabelSafe = h(dispSeg(segNorm) || "");
                const typeSafe     = h(it.type || "");
                const titleSafe    = h(it.title || "");
                const deadlineSafe = h(deadlineDisp);
                const publishSafe  = h(it.publish || "No");
                const statusSafe   = h(it.status || "archived");
                const flagSafe     = h(it.flag || "N");

                // onclick 用 id（シングルクォートだけエスケープ）
                const idKey = String(it.id).replace(/'/g, "\\'");

                return `
                <div class="card" data-seg="${segNorm || "both"}">
                    <div><b>${ymdSafe}${hmSafe ? ` ${hmSafe}` : ""}</b> @ ${placeSafe}</div>
                    <div class="small">${segLabelSafe}｜${typeSafe}：${titleSafe}</div>
                    <div class="small muted">
                    出欠対象:${h(it.attendTarget || "N")}
                    / 期限:${deadlineSafe}
                    / 公開:${publishSafe}
                    / 状態:${statusSafe}
                    / 配信:${flagSafe}
                    </div>
                    <div class="row" style="margin-top:8px; justify-content:flex-end;">
                    <button class="btn btn-ghost btn-sm btn-compact btn-edit" type="button"
                            onclick="adminEdit(adminItemsMap['${idKey}'])">編集</button>
                    </div>
                </div>
                `;
            }).join("")
            : `<div class="listEmpty">該当する予定はありません</div>`;

        top.innerHTML = html;
    }

    /* ▼ 一覧カードの「編集」ボタン押下時：フォームへ反映＆スクロール */
    function adminEdit(obj){
        // まずアコーディオンを確実に閉じる
        window.closeAdminAccordion?.();

        // フォームへ反映
        fillAdminFormFromItem(obj);

        // ページ先頭ではなく編集フォームの見出しへスクロール
        document.getElementById('adminFormTitle')
            ?.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }

/* ===== 管理レポート（軽量メタ → 詳細取得） ===== */
  // 追加の状態
  state.reportMeta = [];          // 軽量一覧（rows無し）
  state.reportCache = {};         // id -> 詳細キャッシュ
  state.reportDetailMap = {};     // 既存 renderReport() 互換キャッシュ
  
  const adminReport = {
    mounted: false,

    // ① メタを取得してセレクトに流し込む（D1 直版）
    async loadMeta(){
        const sel = document.querySelector("#repEvent");
        const box = document.querySelector("#repBox");
        if (!sel) return;

        sel.disabled = true;
        sel.innerHTML = `<option value="">（読み込み中…）</option>`;

        try {
            let list = [];

            if (D1_BASE) {
            // ★ D1 の今後の予定 API を利用（365日分）
            const url  = `${D1_BASE}/line/schedules?days=365`;
            const resp = await fetch(url, { method: "GET" });
            if (!resp.ok) {
                throw new Error("schedules http error: " + resp.status);
            }
            const json = await resp.json();
            if (json.status !== "ok" || !Array.isArray(json.schedules)) {
                throw new Error("schedules bad response");
            }

            // 必要な項目だけ軽量化して保持（★ segment も持たせる）
            list = json.schedules
                .map(ev => {
                const id = String(
                    ev.id ||
                    ev.eventId ||
                    ev.event_id ||
                    ev.eventKey ||
                    ev.event_key ||
                    ""
                ).trim();
                if (!id) return null;

                const segRaw =
                    ev.segment ||
                    ev.targetSegment ||
                    ev.target_segment ||
                    ev.target_group ||    // D1 events のカラム名
                    ev.targetGroup ||
                    ev.attendSegment ||
                    "";

                return {
                    id,
                    ymd   : ev.ymd  || ev.date || "",
                    time  : ev.time || ev.hm   || "",
                    title : ev.title || ev.name || "",
                    // 出欠対象フラグ
                    needAttendance:
                    ev.need_attendance ??
                    ev.needAttendance ??
                    "",
                    // ★ 対象区分
                    segment: segRaw,

                    // ★ 締切日（YYYYMMDD 相当）をメタ情報として保持しておく
                    deadlineYmd:
                        ev.deadlineYmd ??
                        ev.deadline_date ??
                        ev.deadlineDate ??
                        ev.deadline ??
                        ev.limit ?? 
                        "",
                };
                })
                .filter(e => e && e.id);

            } else {
            // ★ 保険：D1_BASE 未設定なら従来の GAS API にフォールバック
            const r = await api(`?attendanceReport=1&meta=1&lineId=${esc(state.lineId)}&admin=1`);
            if (r?.status !== "ok" || !Array.isArray(r.list)) {
                const msg = r?.message || "サーバーがエラーを返しました";
                console.error("meta error:", r);
                sel.innerHTML = `<option value="">取得エラー</option>`;
                if (box) box.textContent = `エラー: ${msg}`;
                sel.disabled = false;
                return;
            }
            // GAS 側の戻り値にも segment があればそのまま乗る
            list = r.list.map(ev => ({
                ...ev,
                segment:
                ev.segment ||
                ev.targetSegment ||
                ev.target_group ||
                ev.targetGroup ||
                ev.attendSegment ||
                ev.segmentLabel ||
                "",
            }));
            }

            // ▼ 出欠対象フラグ Y のイベントだけに絞る
            console.log("[rep] raw list length =", list.length);
            console.log("[rep] sample item =", list[0]);

            const filtered = list.filter(ev => {
            const flagRaw = (
                ev.needAttendance ??
                ev.need_attendance ??
                ""
            ).toString().trim().toUpperCase();

            // "Y" / "1" / "TRUE" を全部 OK とみなす
            return flagRaw === "Y" || flagRaw === "1" || flagRaw === "TRUE";
            });
            console.log("[rep] filtered length =", filtered.length);

            // 一覧としても絞り込んだものを保存
            state.reportMeta = filtered;

            // ★ イベント区分フィルタ用にグローバルにも残しておく
            window.__adminReportEventList = filtered;
            console.log("[rep] normalized sample =", filtered[0]);

            // ▼ セレクト用ラベル生成（fmtYmd / fmtTime を利用）
            const opts = filtered
            .map(e => {
                const rawDate  = e.ymd || e.date || "";
                const rawTime  = e.time || e.hm  || "";
                const dateDisp = fmtYmd(rawDate);   // 例: 2026/01/11（日）
                const timeDisp = fmtTime(rawTime);  // 例: 14:00

                const title = (e.title || e.name || "").trim() || "（無題）";

                const label = `${dateDisp}${timeDisp ? ` ${timeDisp}` : ""}　${title}`;

                const value = String(
                e.id ??
                e.eventId ??
                e.event_key ??
                e.eventKey ??
                ""
                ).trim();

                if (!value) return "";
                return `<option value="${value}">${label}</option>`;
            })
            .filter(Boolean)
            .join("");

            sel.innerHTML =
            `<option value="">（選択してください）</option>` +
            (opts || `<option value="" disabled>（出欠対象の公演がありません）</option>`);

            if (box && !sel.value) {
            box.textContent = "公演を選択してください";
            }
        } catch (e) {
            console.error(e);
            sel.innerHTML = `<option value="">取得エラー</option>`;
            if (box) box.textContent = `通信エラー: ${e.message || e}`;
        } finally {
            sel.disabled = false;
        }
        },
       
        // ② セレクト変更→その1件だけ詳細取得→renderReport を呼ぶ（D1 版）
        onChange(){
          // ここでは何も取らずに、単純に renderReport に任せる
          renderReport();
        },

        // 初期配線
        mount(){
        if (this.mounted) return;
        this.mounted = true;
        document.querySelector("#repEvent")?.addEventListener("change", ()=>this.onChange());
        // ← 実HTMLは #btnReportReload なのでこちらに合わせます
        document.querySelector("#btnReportReload")?.addEventListener("click", ()=>this.loadMeta());
        }
    };

    // 管理レポート初期化（公演メタ一覧の取得＆セレクト更新）
    async function initAdminReportPage(){
        if (!state.isAdmin){
        const box = document.getElementById('repBox');
        if (box) box.textContent = '権限がありません';
        return;
        }

        const repBox = document.getElementById('repBox');
        if (repBox) repBox.textContent = '公演一覧を取得中…';

        // イベントリスナーがまだなら張る
        adminReport.mount();

        // ★ D1 版 loadMeta を使用
        await adminReport.loadMeta();

        const sel = document.getElementById('repEvent');
        if (repBox) {
        repBox.textContent = sel && sel.value
            ? '読み込み中…'
            : '公演を選択してください';
        }
    }
  
    // ===== 管理レポート再読込（互換エイリアス） =====
    // 旧コードから呼ばれても D1 版 initAdminReportPage に流すためのエイリアス
    window.reportReload = function(){ initAdminReportPage(); };
  
    // --- ヘルパー：state.report からセレクトを全面再描画 ---
    // （旧実装互換。今後使う場合に備えて残しておく）
    function drawEventSelectFromReport(){
        if (!selMode) return;
        selMode.innerHTML = `<option value="">（選択してください）</option>`;

        const items = (state.report || []).slice().sort((a,b)=>
        String(a.ymd||"").localeCompare(String(b.ymd||"")) ||
        String(a.time||"").localeCompare(String(b.time||"")) ||
        String(a.title||"").localeCompare(String(b.title||""))
        );

        for (const e of items){
        const opt = document.createElement("option");
        // ★ id / eventId のどちらでもOKに
        opt.value = String(e.id ?? e.eventId ?? "");
        opt.textContent = `${e.ymd || ""}${e.time ? " " + e.time : ""}  ${e.title || ""}`;
        selMode.appendChild(opt);
        }
        selMode.disabled = false;
    }

/* ===== 出欠結果一覧（管理者） 共通フォーマッタ群 ===== */
    // 共通ゼロ埋め
    function pad2(n){
        return String(n).padStart(2, "0");
        }

        // 共通: 日付文字列 → Date or null
        // 対応：20260111 / 2026-01-11 / 2026/01/11
        function parseYmdFlexible(s){
        const str = String(s || "").trim();
        if (!str) return null;

        let y, m, d;

        // 8桁数字 20260111
        const m8 = str.match(/^(\d{4})(\d{2})(\d{2})$/);
        if (m8) {
            y = +m8[1]; m = +m8[2]; d = +m8[3];
        } else {
            // 2026-01-11 / 2026/01/11
            const m2 = str.replace(/-/g, "/").match(/^(\d{4})\/(\d{2})\/(\d{2})$/);
            if (!m2) return null;
            y = +m2[1]; m = +m2[2]; d = +m2[3];
        }

        const dt = new Date(y, m - 1, d);
        return isNaN(dt) ? null : dt;
    }

    // 日付文字列（20260111 / 2026-01-11 / 2026/01/11）→ "YYYY/MM/DD（曜）"
    function fmtYmd(s){
        const str = String(s || "").trim();
        if (!str) return "";

        const dt = parseYmdFlexible(str);
        if (!dt) return str;   // 既存仕様：パースできなければ元文字を返す

        const yo = "日月火水木金土"[dt.getDay()];
        return `${dt.getFullYear()}/${pad2(dt.getMonth()+1)}/${pad2(dt.getDate())}（${yo}）`;
    }

    // 時刻文字列／Date 文字列 → "HH:MM"
    function fmtTime(s){
        const m = String(s||"").match(/^(\d{1,2}):(\d{2})/);
        if (m) return `${pad2(+m[1])}:${m[2]}`;

        const d = new Date(s||"");
        return isNaN(d)
            ? ""
            : `${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
    }

    // dt オブジェクト（updatedAt などを含む）→ "YYYY/MM/DD HH:MM:SS"
    function fmtDateTime(dt){
        if (!dt) return "";
        // 期待されるキーに広く対応
        const v = (dt.updatedAt || dt.answeredAt || dt.timestamp || dt.at || "").toString();
        if (v && !isNaN(new Date(v))) {
            const d = new Date(v);
            return `${d.getFullYear()}/${pad2(d.getMonth()+1)}/${pad2(d.getDate())} `
                + `${pad2(d.getHours())}:${pad2(d.getMinutes())}:${pad2(d.getSeconds())}`;
        }
        return String(v || "");
    }

    // "YYYY/MM/DD（曜）" → "YYYY/MM/DD" （曜日なし）
    function fmtYmdNoWeekday(s){
        const full = fmtYmd(s);   // 例: "2026/01/11（日）"
        if (!full) return "";
        // 末尾の （…） を削る
        return full.replace(/（[^）]*）$/, "");
    }

    // 区分文字列 → CSSクラス / ラベル
    function mapSeg(raw){
        const s = String(raw||"");
        if (s.includes("大人")) return { cls:"seg-adult", label:"大人の部" };
        if (s.includes("子"))   return { cls:"seg-child", label:"子どもの部" };
        if (s.includes("両"))   return { cls:"seg-both",  label:"両方" };
        return { cls:"", label:"" };
    }

    // APIから返る受付状態 accepting → バッジHTML
    function acceptingBadge(accepting){
        const v = String(accepting||"").toLowerCase();
        if (v === "open"   || v === "受付中")   return `<span class="badge-status open">受付中</span>`;
        if (v === "closed" || v === "締切" || v === "締め切り" || v === "締切済"){
            return `<span class="badge-status closed">締切</span>`;
        }
        return "";
    }

    // 出欠ラベルの共通マップ
    const ATTEND_LABEL = {
    yes  : "参加",
    no   : "欠席",
    maybe: "未定",
    na   : "未回答",
    };

    // グループキー → 日本語ラベル
    function labelFor(k){
        return ATTEND_LABEL[k] || ATTEND_LABEL.na;
    }

    // detail オブジェクト → 出欠別グループ {yes,no,maybe,na}
    function groupByAttend(detail){
        const groups = { yes:[], no:[], maybe:[], na:[] };
        const push = (k, it) => { if (it) groups[k].push(it); };

        // detail が変な値なら空グループを返す
        if (!detail || typeof detail !== "object") return groups;

        // 1) すでに yes/no/maybe/na プロパティがある場合
        if (Array.isArray(detail.yes) || Array.isArray(detail.no)
            || Array.isArray(detail.maybe) || Array.isArray(detail.na)){
            ["yes","no","maybe","na"].forEach(k => (detail[k]||[]).forEach(x=>push(k,x)));
            return groups;
        }

        // 2) flat list の場合（list / members / rows など）
        const list = detail.list || detail.members || detail.rows || [];

        // 日本語 → キー の逆マップ
        const REV_ATTEND = {
            [ATTEND_LABEL.yes]  : "yes",
            [ATTEND_LABEL.no]   : "no",
            [ATTEND_LABEL.maybe]: "maybe",
            [ATTEND_LABEL.na]   : "na",
        };

        list.forEach(it=>{
            const raw = (it.attend || it.answer || "").trim();
            const key = REV_ATTEND[raw] || "na";
            push(key, it);
        });

        return groups;
    }

/* ===== 管理レポート：メタ取得 → 1件詳細 → 描画（堅牢版） ===== */
    (function(){
    if (window.__AdminReportV__ >= 2) return;
    window.__AdminReportV__ = 2;

    // ▼ payload から rows/list/answers/data/... のどれか最初の配列を拾う
    function pickRows(p){
        if (!p) return [];
        const cands = [
        p.rows, p.list, p.answers, p.data, p.members, p.records,
        (Array.isArray(p.detail) ? p.detail : null),
        (p.report && Array.isArray(p.report.rows) ? p.report.rows : null),
        (p.report && Array.isArray(p.report.list) ? p.report.list : null),
        ];
        for (const c of cands) if (Array.isArray(c)) return c;
        return [];
    }

    // ▼ 出欠1行を内部標準形 {name, attend, at, seg, comment} に変換
    function mapRow(x){
        const name   = x.displayName ?? x.name ?? x.member ?? x.performerName ?? x.performer ?? "";
        const raw    = x.answer ?? x.attend ?? x.attendStatus ?? x.status ?? "";
        const label  = String(raw || "").trim();
        const attend = ["参加","欠席","未定","未回答"].includes(label)
        ? label
        : (label || "未回答");
        const at     = x.updatedAt ?? x.updated ?? x.time ?? x.ts ?? "";
        const seg    = x.segment ?? x.seg ?? x.category ?? "";
        // ▼ コメント候補（サーバ差異を広めに吸収）
        const comment =
        x.comment ??
        x.eventComment ??
        x.memo ??
        x.note ??
        x.remarks ??
        x.remark ??
        x.Comment ??
        x["コメント"] ??
        "";

        return { name, attend, at, seg, comment };
    }

    // ▼ 回答日時の表示用整形 "回答：YYYY/MM/DD HH:MM:SS"
    function repFormatAt(at){
        if (!at) return "";
        const d = new Date(at);
        if (isNaN(d)) return `回答：${String(at)}`;
        return (
        "回答：" +
        d.getFullYear() + "/" +
        pad2(d.getMonth()+1) + "/" +
        pad2(d.getDate()) + " " +
        pad2(d.getHours()) + ":" +
        pad2(d.getMinutes()) + ":" +
        pad2(d.getSeconds())
        );
    }

    // ▼ 出欠ラベル → CSSクラス
    function badgeCls(att){
        return att === "参加" ? "yes"
            : att === "欠席" ? "no"
            : att === "未定" ? "maybe"
            : "na";
    }

    // ▼ 名前の正規化（全角空白→半角、余分な空白・先頭ラベル除去）
    function canonName(s){
        return String(s || "")
        .replace(/\u3000/g, " ")       // 全角空白→半角
        .replace(/^\s+|\s+$/g, "")     // 前後空白
        .replace(/\s+/g, " ")          // 連続空白
        .replace(/^【[^】]+】\s*/, ""); // 接頭の【大人の部】等を除去
    }

    // ▼ members から「正規化名前 → 区分」索引を作成
    function buildSegIndex(payload){
        const idx = {};
        if (Array.isArray(payload?.members)) {
        payload.members.forEach(m => {
            const nm = canonName(
            m?.displayName ?? m?.name ?? m?.member ?? m?.performerName ?? ""
            );
            if (!nm) return;
            idx[nm] = String(m?.seg || m?.segment || m?.attendSegment || "");
        });
        }
        return idx;
    }

    // ▼ 候補名リスト（roster / members / candidates）の統一取得
    function buildCandidates(payload, segIndex){
        let candidates = [];

        if (Array.isArray(payload?.roster)) {
        // roster: ["氏名", ...]
        candidates = payload.roster
            .map(n => ({
            name: String(n || "").trim(),
            seg : segIndex[canonName(n)] || "",
            }))
            .filter(x => x.name);

        } else if (Array.isArray(payload?.members)) {
        candidates = payload.members
            .map(m => {
            const raw =
                m?.displayName ?? m?.name ?? m?.member ?? m?.performerName ?? "";
            return {
                name: String(raw || "").trim(),
                seg : String(m?.seg || m?.segment || m?.attendSegment || ""),
            };
            })
            .filter(x => x.name);

        } else if (Array.isArray(payload?.candidates)) {
        candidates = payload.candidates
            .map(m => {
            const raw =
                m?.displayName ?? m?.name ?? m?.member ?? m?.performerName ?? "";
            return {
                name: String(raw || "").trim(),
                seg : String(m?.seg || m?.segment || m?.attendSegment || ""),
            };
            })
            .filter(x => x.name);
        }

        return candidates;
    }

    // ▼ 未回答行の生成（候補 − 回答済み）
    function buildNaRows(candidates, answeredCanon, segIndex, eventSegNorm){
        return candidates
            .filter(c => {
            const nmKey = canonName(c.name);
            if (answeredCanon.has(nmKey)) return false; // すでに回答済みなら除外

            const rawSeg  = c.seg || segIndex[nmKey] || "";
            const segNorm = normalizeSegmentLabel(rawSeg);

            // イベント区分が未指定 or 両方 → 全員対象
            if (!eventSegNorm || eventSegNorm === "両方") {
                return true;
            }

            // 区分が取れない場合 → このイベントでは対象外にする
            if (!segNorm) return false;

            // メンバー側が両方 → 両方に出る想定なら true
            if (segNorm === "両方") return true;

            // それ以外は「イベントの区分と一致するメンバーだけ残す」
            return segNorm === eventSegNorm;
            })
            .map(c => {
            const nmKey = canonName(c.name);
            const segRaw = c.seg || segIndex[nmKey] || "";
            const seg    = segRaw;

            return {
                name  : nameWithSegPrefix({ name: c.name, seg }),
                attend: "未回答",
                at    : "",
                seg   : seg,
            };
            });
    } 

    // ▼ 名前 → 並び順情報（sortGroup / birthYear）インデックス
    function buildMemberSortIndex(payload){
        const idx = {};
        if (!payload || !Array.isArray(payload.members)) return idx;

        payload.members.forEach(m => {
        const nm = canonName(
            m.displayName ??
            m.name ??
            m.member ??
            m.performerName ??
            ""
        );
        if (!nm) return;

        const sortGroupRaw =
            m.sortGroup ??
            m.sort_group ??
            null;

        const birthYearRaw =
            m.birthYear ??
            m.birth_year ??
            null;

        idx[nm] = {
            seg      : m.seg || m.segment || "",
            sortGroup: sortGroupRaw,
            birthYear: birthYearRaw,
        };
        });

        return idx;
    }

    // ▼ 出欠行配列を「グループ → 生年 → 名前」でソート
    function sortRowsByPriority(rows, payload){
        const membersIdx = buildMemberSortIndex(payload);

        function infoFor(name){
        const key = canonName(name);
        const m   = membersIdx[key] || {};

        let g = m.sortGroup;
        let gNum = (g === null || g === undefined || g === "") ? 5 : Number(g);
        if (Number.isNaN(gNum)) gNum = 5; // デフォルトは真ん中くらい

        let by = m.birthYear;
        let byNum = (by === null || by === undefined || by === "") ? null : Number(by);
        if (Number.isNaN(byNum)) byNum = null;

        return { key, group: gNum, birthYear: byNum };
        }

        const arr = rows.slice(); // 元配列は壊さない

        arr.sort((a, b) => {
        const ia = infoFor(a.name);
        const ib = infoFor(b.name);

        // ① sortGroup 昇順（0 → 1 → 2 → ... → 9）
        if (ia.group !== ib.group) {
            return ia.group - ib.group;
        }

        // ② 生年が両方あれば昇順（古い年 = 年上 が先）
        if (ia.birthYear !== null && ib.birthYear !== null && ia.birthYear !== ib.birthYear) {
            return ia.birthYear - ib.birthYear;
        }

        // ③ 片方だけ生年がある場合：生年ありを優先
        if (ia.birthYear !== null && ib.birthYear === null) return -1;
        if (ia.birthYear === null && ib.birthYear !== null) return 1;

        // ④ 最後に名前（正規化済み）でソート
        return ia.key.localeCompare(ib.key, "ja");
        });

        return arr;
    }

    // ▼ 出欠結果の描画（#repEvent の value を eventId とみなして取得→描画）
    async function renderReport(){
        const sel = document.getElementById("repEvent");
        const box = document.getElementById("repBox");
        const id  = sel?.value || "";

        if (!id){
            if (box) box.textContent = "公演を選択してください";
            return;
        }

        // --- lineId を取得（state → getLineId の順）---
        let lidRaw = (window.state && window.state.lineId) || "";

        if (!lidRaw && typeof window.getLineId === "function") {
            try {
            lidRaw = await window.getLineId();
            if (lidRaw) {
                // ついでに共通 state にキャッシュ
                window.state = window.state || {};
                window.state.lineId = lidRaw;
            }
            } catch (e) {
            console.warn("getLineId failed in renderReport:", e);
            }
        }

        if (!lidRaw) {
            if (box) {
            box.textContent = "管理者の LINE ID を取得できませんでした。LINE から開き直して再度お試しください。";
            }
            console.warn("renderReport: lineId is empty");
            return;
        }

        const lidEnc = encodeURIComponent(lidRaw);

        if (box) {
            box.innerHTML = '結果を取得中… <span class="spinner"></span>';
        }

        let payload = null;
        let list    = [];
        let used    = "none";   // ★ どのルートを使ったか記録

        // ---- 0) まず D1 の /line/attendance/report を叩く（爆速ルート） ----
        if (D1_BASE && lidRaw) {
            try {
            const url =
                `${D1_BASE}/line/attendance/report` +
                `?eventKey=${encodeURIComponent(id)}` +
                `&lineId=${encodeURIComponent(lidRaw)}`;

            const res = await fetch(url, { method: "GET" });
            if (res.ok) {
                const json = await res.json();
                if (json && json.status === "ok") {
                payload = json;
                list    = pickRows(payload);
                used    = list.length ? "D1" : "D1-empty";
                } else {
                console.warn("D1 report bad response:", json);
                }
            } else {
                console.warn("D1 report http error:", res.status);
            }
            } catch (e) {
            console.warn("D1 report fetch failed:", e);
            }
        }

        // ---- 1) D1 で「エラーのときだけ」従来の GAS API にフォールバック ----
        if (!payload) {
            let resp;
            try{
                resp = await api(
                `?attendanceReport=1&eventId=${encodeURIComponent(id)}&detail=1&admin=1&lineId=${lidEnc}`
                );
            }catch(e){
                console.error("fetch error(eventId):", e);
            }

            payload = resp && (resp.detail || resp);
            list    = pickRows(payload);

            if (resp?.status === "ok" && list.length){
                used = "GAS-eventId";
            }

            // 2) うまく取れなければ id フォールバック
            if (!(resp?.status === "ok") || list.length === 0){
                try{
                const r2 = await api(
                    `?attendanceReport=1&id=${encodeURIComponent(id)}&detail=1&admin=1&lineId=${lidEnc}`
                );
                const p2 = r2 && (r2.detail || r2);
                const l2 = pickRows(p2);
                if (r2?.status === "ok" && l2.length){
                    payload = p2;
                    list    = l2;
                    used    = "GAS-fallback-id";
                }
                }catch(e){
                console.error("fallback fetch error(id):", e);
                }
            }
        }

        console.debug("[report] source for", id, "=", used, "(rows:", list.length, ")");

        // どのルートでもダメだったとき
        if (!payload || !(payload.status === "ok")){
            if (box) {
            box.textContent = payload?.message || "取得に失敗しました";
            }
            console.warn("report payload:", payload);
            return;
        }

        // ★ 家族フィルタは一切しない（= 全員ベースで扱う）
        const rows = list.map(mapRow);

        // --- 比較用：名前の正規化（全員ぶん） ---
        // → 未回答生成のときには「大人だけど間違って子ども公演に回答した人」も
        //   きちんと「回答済み」として扱いたいので、ここは *フィルタ前* の rows を見る
        const answeredCanon = new Set(
        rows.map(r => canonName(r.name)).filter(Boolean)
        );

        // members から「名前→区分」索引（未回答表示で接頭辞付与に使う）
        const segIndex   = buildSegIndex(payload);
        const candidates = buildCandidates(payload, segIndex);

        // ▼ イベント自体の対象区分を取得（D1/GAS + フロントのマスターからも検索）
        const eventSegNorm = getEventSegmentNorm(payload, id);

        // ▼ 回答済み rows にも seg を補完しておく（members 情報から）
        rows.forEach(r => {
        if (!r.seg) {
            const nmKey = canonName(r.name);
            const segFromIdx = segIndex[nmKey];
            if (segFromIdx) r.seg = segFromIdx;
        }
        });

        // ▼ イベントの対象区分で「回答済み rows」をフィルタ
        let rowsFiltered = rows;
        if (eventSegNorm && eventSegNorm !== "両方") {
            rowsFiltered = rows.filter(r => {
                const segNorm = normalizeSegmentLabel(r.seg);

                // 区分が取れない場合 → このイベントでは対象外にする
                if (!segNorm) return false;

                // 両方 → どちらのイベントにも出て良い
                if (segNorm === "両方") return true;

                // それ以外はイベント区分と一致するかどうか
                return segNorm === eventSegNorm;
            });
        }

        // ▼ 未回答も同じくイベント区分でフィルタ
        const naRows = buildNaRows(candidates, answeredCanon, segIndex, eventSegNorm);

        // rows を未回答で拡張（ここから先は元の処理と同じ）
        const rowsAll = rowsFiltered.concat(naRows);

        // ★ 並び替え（sortGroup → birthYear → 名前）
        const rowsAllSorted = sortRowsByPriority(rowsAll, payload);

        // フィルタ
        const f = document.getElementById("repAttend")?.value || "";
        const view = rowsAllSorted.filter(r =>
            !f ? true : (f === "未回答" ? r.attend === "未回答" : r.attend === f)
        );

        // 集計（カウントもソート後の配列を使えば OK）
        const cnt = {
            yes  : rowsAllSorted.filter(r => r.attend === "参加").length,
            no   : rowsAllSorted.filter(r => r.attend === "欠席").length,
            maybe: rowsAllSorted.filter(r => r.attend === "未定").length,
            na   : rowsAllSorted.filter(r => r.attend === "未回答").length,
            all  : rowsAllSorted.length,
        };
        // console.log("report counts:", cnt);

        // ヘッダ情報
        const title = payload.title || payload.eventTitle || payload.name || "";
        const date  = fmtYmd(payload.ymd   || payload.date || "");
        const time  = fmtTime(payload.hm   || payload.time || "");
        const place = payload.place || payload.venue || "";

        // === 受付状態（ヘッダ右側の「受付中 / 締切」バッジ）を決定 ===

        // 今日（JST）を YYYYMMDD
        const now = new Date();
        const jst = new Date(now.getTime() + 9 * 60 * 60 * 1000);
        const ty  = jst.getFullYear();
        const tm  = String(jst.getMonth() + 1).padStart(2, "0");
        const td  = String(jst.getDate()).padStart(2, "0");
        const todayYmd = `${ty}${tm}${td}`;

        // 0-A) meta側（/line/schedules）から該当イベント
        let metaHit = null;
        if (Array.isArray(state.reportMeta) && id) {
            metaHit = state.reportMeta.find(e => String(e.id) === String(id)) || null;
        }

        // 0-B) 管理一覧（adminItemsRaw）から該当イベント
        let adminHit = null;
        if (Array.isArray(state.adminItemsRaw) && id) {
            adminHit = state.adminItemsRaw.find(e => String(e.id) === String(id)) || null;
        }

        // 1) payload 内から締切日っぽい値を拾う
        let rawDeadline =
            payload.deadline ||
            payload.limit ||
            payload.deadlineYmd ||
            payload.deadline_ymd ||
            payload.deadlineDate ||
            payload.deadline_date ||
            (payload.event && (
                payload.event.deadline ||
                payload.event.limit ||
                payload.event.deadlineYmd ||
                payload.event.deadline_ymd ||
                payload.event.deadlineDate ||
                payload.event.deadline_date
            )) ||
            "";

        // 2) 無ければ metaHit / adminHit から拾う
        if (!rawDeadline && metaHit) {
            rawDeadline =
                metaHit.deadline ||
                metaHit.deadlineYmd ||
                metaHit.deadline_ymd ||
                metaHit.deadlineDate ||
                metaHit.deadline_date ||
                "";
        }

        if (!rawDeadline && adminHit) {
            // ★ adminListFetch で正規化した deadline を最優先で使う
            rawDeadline =
                adminHit.deadline ||
                adminHit.deadlineYmd ||
                adminHit.deadline_ymd ||
                adminHit.deadlineDate ||
                adminHit.deadline_date ||
                "";
        }

        // 3) 数字だけ抜く
        let deadlineDigits = String(rawDeadline || "").replace(/[^0-9]/g, "");

        // 3.5) 公演日（締切が取れなかった場合のフォールバック用）
        let dateDigits = "";
        {
            const rawDate =
                payload.ymd ||
                payload.date ||
                (payload.event && (payload.event.ymd || payload.event.date)) ||
                (metaHit  && (metaHit.ymd  || metaHit.date)) ||
                (adminHit && (adminHit.ymd || adminHit.date)) ||
                "";
            const d = String(rawDate || "").replace(/[^0-9]/g, "");
            if (d.length >= 8) {
                dateDigits = d.slice(0, 8);
            }
        }

        // 4) 実際の open 判定
        let open;

        // 4-1) まずは締切日で判定（締切日 < 今日 → 締切）
        if (deadlineDigits.length >= 8) {
            const dlYmd = deadlineDigits.slice(0, 8); // 先頭8桁 yyyyMMdd
            const isClosedByDeadline = dlYmd < todayYmd;
            open = !isClosedByDeadline;
        }
        // 4-2) 締切が取れない場合は「公演日」で判定（公演日 < 今日 → 締切）
        else if (dateDigits.length === 8) {
            const isPastEvent = dateDigits < todayYmd;
            open = !isPastEvent;
        }
        // 4-3) それでも判断できない場合だけ accepting / status でフォールバック
        else if (typeof payload.accepting !== "undefined") {
            const v = String(payload.accepting).toLowerCase();
            open = !(
                v === "closed" ||
                v === "close"  ||
                v === "false"  ||
                v === "n"
            );
        } else {
            const flag =
                payload.isOpen ??
                payload.open ??
                (payload.status &&
                    String(payload.status).toLowerCase() === "open");
            open = !!flag;
        }

        // ★ここからヘッダーHTML
        const head = `
        <div class="repHeader">
            <!-- 1行目：タイトルだけ -->
            <div class="repLine">
            <div class="repLeft">
                <span class="repTitle">${title || "(無題)"}</span>
            </div>
            </div>

            <!-- 2行目：日時・場所（左）／受付バッジ（右） -->
            <div class="repLine repHeadRow">
            <div class="repLeft">
                <span class="repMeta">
                ${date}${time ? ` ${time}` : ""}
                ${place ? `<span class="repPlace"> @${place}</span>` : ""}
                </span>
            </div>
            <div class="repRight">
                <span class="badge-status ${open ? "open" : "closed"}">
                ${open ? "受付中" : "締切"}
                </span>
            </div>
            </div>
        </div>`;

        // 出欠ごとにグルーピング（画面フィルタを反映した view を対象に）
        const by = { "参加": [], "未定": [], "欠席": [], "未回答": [] };
        view.forEach(r => (by[r.attend] ? by[r.attend] : by["未回答"]).push(r));

        // 表示順。フィルタがかかっている時はそのグループだけ出す
        const order = f ? [f] : ["参加", "未定", "欠席", "未回答"];

        const body =
            order
            .map(k => {
                const arr = by[k] || [];
                if (!arr.length) return "";
                return `
                <div class="repGroup">
                    <div class="repGroupHead">
                    <span class="badge-att ${badgeCls(k)}">${k}</span>
                    <span class="repCount">${arr.length}名</span>
                    </div>
                    ${arr
                    .map(p => {
                        const commentText = String(p.comment || "").trim();
                        return `
                        <div class="repPersonRow">
                            <div class="repName">${h(p.name)}</div>
                            <div class="repAt">${
                            commentText
                                ? `<span class="repComment">${h(commentText)}</span>`
                                : ""
                            }</div>
                        </div>`;
                    }).join("")}
                </div>`;
            })
            .join("") || `<div class="repNA">該当者がいません</div>`;

        if (box) {
            box.innerHTML = `<div class="repCard">${head}${body}</div>`;
        }
    }

    // ▼ 対象区分の正規化（"子ども" / "大人" / "両方"）
    function normalizeSegmentLabel(raw){
        const s = String(raw || "").trim();
        if (!s) return "";
        if (s.includes("大人")) return "大人";
        if (s.includes("子ども") || s.includes("子供")) return "子ども";
        if (s.includes("両方") || s.includes("両部") || s.includes("両")) return "両方";
        return "";
        }

        // ▼ payload + フロント側マスターから「イベントの対象区分」を探して正規化
        function getEventSegmentNorm(payload, eventId){
        if (!payload) payload = {};

        // 1) まずは payload 内を総当たり（従来ロジック）
        let raw =
            payload.segment ||
            payload.targetSegment ||
            payload.target_group ||
            payload.targetGroup ||
            payload.eventSegment ||
            // event オブジェクト配下
            (payload.event && (
            payload.event.segment ||
            payload.event.targetSegment ||
            payload.event.target_group ||
            payload.event.targetGroup
            )) ||
            // meta 的な場所
            (payload.meta && (
            payload.meta.segment ||
            payload.meta.targetSegment ||
            payload.meta.target_group ||
            payload.meta.targetGroup
            )) ||
            "";

        let norm = normalizeSegmentLabel(raw);
        if (norm) {
            console.debug("[report] event segment raw=", raw, "norm=", norm);
            return norm;
        }

        // 2) フロント側の「イベント一覧」から fallback で探す
        let raw2 = "";

        // state.adminItemsRaw を優先（D1 から取った最新の一覧）
        if (Array.isArray(window.state?.adminItemsRaw) && eventId) {
            const hit = window.state.adminItemsRaw.find(ev => String(ev.id) === String(eventId));
            if (hit && hit.segment) {
            raw2 = hit.segment;
            }
        }

        // それでも見つからず、adminItemsMap があればそちらも一応見る
        if (!raw2 && window.adminItemsMap && eventId && window.adminItemsMap[eventId]) {
            raw2 = window.adminItemsMap[eventId].segment || "";
        }

        norm = normalizeSegmentLabel(raw2);
        console.debug("[report] event segment raw=", raw, "norm=", norm,
                        "/ fallback raw=", raw2, "norm2=", norm);

        return norm;
    }
    
    // ▼ 名前 + 区分から表示名を組み立て（大人の部の接頭辞を付ける）
    function nameWithSegPrefix(p){
        const nm = String(p?.name || "");
        if (nm.startsWith("【大人の部】")) return nm; // 既に付いていればそのまま
        const s  = String(p?.seg || "");
        return s.includes("大人") ? `【大人の部】${nm}` : nm;
    }

    // 既存ハンドラとつながるように公開
    window.renderReport = renderReport;
    })();

/* ===== 共通：lineId の取得／キャッシュ ===== */
    // liff / state / 独自ヘルパーを総動員して lineId を取得する
    async function getLineId(timeoutMs = 4000){
    // すでにどこかで getLineId が定義されていればそちらを優先
    if (window.getLineId && window.getLineId !== getLineId) {
        return window.getLineId(timeoutMs);
    }

    // 1回だけの取得ロジック
    const tryOnce = () => {
        // どこかで事前に埋めているケース
        if (window.__ME__?.lineId) return window.__ME__.lineId;
        if (window.state?.lineId)  return window.state.lineId;

        // LIFF の ID トークンから取得
        if (window.liff?.getDecodedIDToken) {
        try {
            const idt = window.liff.getDecodedIDToken();
            const sub = idt?.sub || "";
            if (sub) {
            (window.state ||= {}).lineId = sub; // ついでにキャッシュ
            return sub;
            }
        } catch (_) {}
        }
        return "";
    };

    // まず一度だけ即試す
    const first = tryOnce();
    if (first) return first;

    // 見つからなければ、タイムアウトまでポーリング
    const deadline = Date.now() + timeoutMs;
    while (Date.now() < deadline){
        const lid = tryOnce();
        if (lid) return lid;
        await new Promise(r => setTimeout(r, 120));
    }
    return "";
    }

    // 他ブロックからは window.getLineId() を呼ぶ前提にする
    window.getLineId = window.getLineId || getLineId;

/* ===== 共通ユーティリティ（$ / show / 戻るボタンなど） ===== */
  (function(){
    // --- フォールバック（あれば既存の $ / show をそのまま使用） ---
    window.$ = window.$ || (sel => document.querySelector(sel));
    window.show = window.show || function(sel){
      document.querySelectorAll('[data-view]').forEach(sec=>{
        if (sec.matches(sel)) sec.removeAttribute('hidden');
        else sec.setAttribute('hidden','');
      });
      window.scrollTo({top:0, behavior:'instant'});
    };
  
    // トップへ戻る（カスタム通知 → ホーム）
    const btn = document.getElementById('btnCustomBack');
    if (btn) btn.addEventListener('click', ()=> show('#view-home'));
  
    // （念のため）ホームセクションが data-view を持っているかチェック
    // <section id="view-home" data-view> ... </section> の形が必須です
  })();

    // ===== カスタム通知ユーティリティ：チェックされたステータス取得 =====
    window.getCheckedStats = window.getCheckedStats || function () {
    const sec = document.getElementById('view-custom-push');
    if (!sec) return [];
    return Array.from(sec.querySelectorAll('.cp_stat:checked'))
        .map(el => (el.value || '').trim())
        .filter(Boolean);
    };

    // ===== 共通ミニヘルパー（テキスト書き換えなど） =====
    function setText(el, s) {
    if (el) el.textContent = s;
    }

    function toggleSubmitOverlay(on) {
    const el = document.getElementById("submitOverlay");
    if (!el) return;
    el.style.display = on ? "flex" : "none";
    }

/* ===== カスタム一斉通知：画面初期化 & イベント結線 ===== */
    (function(){
      document.addEventListener('DOMContentLoaded', init);
    
      async function init(){
        // ====== 要素参照 ======
        const sec          = document.getElementById('view-custom-push');
        if (!sec) return;
    
        const selMode      = document.getElementById('cp_event');          // 「宛先の選び方」プルダウン（= イベント選択を兼ねる）
        const statWrap     = document.getElementById('cp_stat_wrap');      // 対象ステータス（枠）
        const statLockTag  = document.getElementById('cp_stat_lock');      // 「手動モード（選択不可）」タグ
        const statChecks   = Array.from(sec.querySelectorAll('.cp_stat')); // 参加/未定/未回答/欠席
    
        const selExtra     = document.getElementById('cp_extra');          // 宛先追加（手動）
        const hintExtra    = document.getElementById('cp_extra_hint');     // （読み込み中…）ラベル
    
        const boxAuto   = sec.querySelector('#cp_auto_targets, #cp_auto');   // 宛先（自動選択）
        const boxManual = sec.querySelector('#cp_manual_targets, #cp_manual'); // 宛先（手動選択）
    
        // 画面内キャッシュ
        sec.__rows   = [];   // 出欠 rows（event選択時）
    
        // ===== 小物ユーティリティ =====
        const setDisabled = (els, on)=> els.forEach(el=>{ if(el) el.disabled = !!on; });
    
        function loadingOnExtra(on){
          if (hintExtra) hintExtra.hidden = !on;
          if (selExtra){
            selExtra.disabled = !!on;
            if (on) selExtra.innerHTML = '<option value="" disabled>読み込み中…</option>';
          }
        }
    
        // ===== 見た目ロック（手動モード） =====
        function applyModeLock(){
          const manual = (selMode?.value === 'manual');
          setDisabled(statChecks, manual);
          statWrap?.classList.toggle('is-locked', manual);
          if (statLockTag) statLockTag.hidden = !manual;
          setText(boxAuto, manual ? '（手動モード：自動選択は使いません）' : '（読込中…）');
        }
    
        // ===== イベント一覧をプルダウンへ（先頭は「手動で選ぶ」） =====
        async function fillEventOptions(){
            if (!selMode) return;

            // 一旦ローディング
            selMode.innerHTML = '<option value="" disabled>読み込み中…</option>';
            selMode.disabled = true;

            let resp;
            try {
                const url = new URL('/line/schedules', D1_ORIGIN);
                url.searchParams.set('days', '365');     // 1年分くらい
                url.searchParams.set('kind', '発表');    // 発表のみ
                const res = await fetch(url.toString());
                resp = await res.json();
            } catch (e) {
                console.error('fillEventOptions error:', e);
                resp = null;
            }

            const list = Array.isArray(resp?.schedules) ? resp.schedules : [];

            const opts = [
                `<option value="manual">手動のみで選ぶ</option>`,
                ...list.map(e => {
                const id    = String(e.id || e.eventKey || '');
                const label = formatEventOptionLabel(e);
                return `<option value="${id}">${h(label)}</option>`;
                })
            ].join('');

            selMode.innerHTML = opts || `<option value="manual">手動のみで選ぶ</option>`;
            selMode.disabled = false;
            selMode.value = 'manual';       // 既定＝手動
            applyModeLock();

            // 手動の候補を初回取得
            await populateManualList();
            }
    
        // ===== 手動モード：通知Yの名簿を取得 → selExtra に入れる =====
        async function populateManualList() {
            if (!selExtra) return;
            loadingOnExtra(true);

            let r = { status: 'error' };
            try {
                // ★ lineId は付けず、全入力者を取得
                const url = new URL('/line/admin/members/notify-list', D1_ORIGIN);
                const res = await fetch(url.toString());
                r = await res.json();
            } catch (e) {
                console.error('populateManualList error:', e);
            }

            const list = Array.isArray(r.list) ? r.list : [];

            selExtra.innerHTML =
                list
                .map(x => `<option value="${x.lineId}">${x.label}</option>`)
                .join('') || `<option value="" disabled>オプションなし</option>`;

            selExtra.disabled = (list.length === 0);
            loadingOnExtra(false);
            renderManualBox();
        }
    
        // ===== 手動の選択を表示枠に反映 =====
        function renderManualBox(){
          if (!selExtra || !boxManual) return;
          const names = Array.from(selExtra.selectedOptions)
            .map(o => o.textContent.trim())
            .filter(Boolean);
          setText(boxManual, names.length ? names.join('\n') : '（未選択）');
        }

        // === CustomPush: globals bootstrap ===
        window.cpSec   = window.cpSec   || sec;
        window.selMode = window.selMode || selMode;
        window.boxAuto = window.boxAuto || boxAuto;

        if (typeof cpSec.__loadingAuto === "undefined") cpSec.__loadingAuto = false;
        if (!Array.isArray(cpSec.__autoTargets))        cpSec.__autoTargets = [];
        // getCheckedStats / setText はグローバル関数を利用するのでここでは触らない

        // ===== 結線（置換）=====
        (function(){
          const sec      = window.cpSec;
          const selMode  = window.selMode || document.getElementById('cp_event');
          const boxAuto  = window.boxAuto || document.querySelector('#cp_auto_targets, #cp_auto');
          const statWrap = document.getElementById('cp_stat_wrap');
          const selExtra = document.getElementById('cp_extra');
        
          if (!sec || !selMode) return;
        
          // 「宛先の選び方」変更
          selMode.addEventListener('change', async ()=>{
            if (typeof applyModeLock === 'function') applyModeLock();
            if (selMode.value === 'manual'){
              sec.__loadingAuto = false; // 読込フラグ解除（任意）
              setText(boxAuto, '（手動モード：自動選択は使いません）');
              if (typeof populateManualList === 'function') await populateManualList();
            } else {
              if (typeof refreshAutoByPreview === 'function') await refreshAutoByPreview();
            }
          });
        
          // 対象ステータス変更 → イベントモード時のみプレビュー更新
          statWrap?.addEventListener('change', (e)=>{
            if (!e.target?.classList?.contains('cp_stat')) return;
            if (selMode.value !== 'manual' && typeof refreshAutoByPreview === 'function'){
              refreshAutoByPreview();
            }
          });
        
          // 手動追加の選択内容を表示枠に反映
          selExtra?.addEventListener('input',  ()=> typeof renderManualBox==='function' && renderManualBox());
          selExtra?.addEventListener('change', ()=> typeof renderManualBox==='function' && renderManualBox());
        })();

        // ===== 初期化 =====
        if (boxAuto)   setText(boxAuto,  '（初期化中…）');
        if (boxManual) setText(boxManual,'（未選択）');
        await fillEventOptions();
        applyModeLock();
        renderManualBox();
      }
    })();

/* ===== カスタム通知：イベント一覧 + 宛先ステータス制御 ===== */
    (function(){
    // 1) getLineId は必ずグローバルに一度だけ
    window.getLineId = window.getLineId || (async function(){
        try{
        if (typeof window.getMyLineId_ === 'function'){
            const id = await window.getMyLineId_();
            if (id){
            (window.state ||= {}).lineId = id;
            return id;
            }
        }
        }catch(_){}

        const tryOnce = () => {
        if (window.__ME__?.lineId) return window.__ME__.lineId;
        if (window.state?.lineId)  return window.state.lineId;
        try{
            return window.liff?.getDecodedIDToken?.()?.sub || '';
        }catch(_){
            return '';
        }
        };

        for (let i = 0; i < 40; i++){
        const id = tryOnce();
        if (id){
            (window.state ||= {}).lineId = id;
            return id;
        }
        await new Promise(r => setTimeout(r, 100));
        }
        return '';
    });

    const sec      = document.getElementById('view-custom-push');
    const selMode  = document.getElementById('cp_event');
    const optGroup = document.getElementById('opt-events');

    function applyModeUI(){
        const statWrap = document.getElementById('cp_stat_wrap');
        const statLock = document.getElementById('cp_stat_lock');
        const manual   = (selMode.value === 'manual' || !selMode.value);

        sec.querySelectorAll('.cp_stat').forEach(cb => {
        cb.disabled = manual;
        });

        if (statWrap){
        statWrap.classList.toggle('is-disabled', manual);
        statWrap.setAttribute('aria-disabled', manual ? 'true' : 'false');
        }
        if (statLock){
        statLock.hidden = !manual;
        }
    }

    async function fillEventChoices(){
        if (optGroup){
            optGroup.innerHTML = '<option value="" disabled>読み込み中…</option>';
        }

        let resp;
        try {
            const url = new URL('/line/schedules', D1_ORIGIN);
            url.searchParams.set('days', '365');
            url.searchParams.set('kind', '発表');
            const res = await fetch(url.toString());
            resp = await res.json();
        } catch (e) {
            console.error('fillEventChoices error:', e);
            resp = null;
        }

        const list = Array.isArray(resp?.schedules) ? resp.schedules : [];

        // イベントIndex（テンプレ置換用）
        const idx = {};
        list.forEach(e => {
        const id      = String(e.id || e.eventKey || '');
        const rawYmd  = e.ymd || e.date || '';
        const rawHm   = e.hm  || e.time || '';
        const rawMeet = e.meetAt || e.meet_time || '';

        // 日付：2026/01/11（日） 形式に
        let dateLabel = '';
        const d = parseYmdStrict(rawYmd);
        if (d instanceof Date && !isNaN(d)) {
            dateLabel = ymdDow(d);           // ex) 2026/01/11（日）
        } else {
            dateLabel = String(rawYmd || '');
        }

        // 開始時間：HH:mm に正規化
        let timeLabel = '';
        if (rawHm) {
            timeLabel = hmFromTimeCell(rawHm);  // ex) 17:15
        }

        // 集合時間：あれば同じく HH:mm
        let meetLabel = '';
        if (rawMeet) {
            meetLabel = hmFromTimeCell(rawMeet);
        }

        idx[id] = {
            id,
            title    : e.title || '',
            date     : dateLabel,                               // ← フォーマット済み
            time     : timeLabel,                               // ← フォーマット済み
            datetime : [dateLabel, timeLabel].filter(Boolean).join(' '),
            place    : e.place || '',
            meet     : meetLabel,                               // ← フォーマット済み
            meetPoint: e.meetPlace || e.place || '',
        };
        });

        window.__EVENT_INDEX__ = idx;

        const opts = list.map(e => {
            const id    = String(e.id || e.eventKey || '');
            const label = formatEventOptionLabel(e);
            return `<option value="${id}">${h(label)}</option>`;
            }).join('') || '<option value="" disabled>（該当イベントなし）</option>';

            if (optGroup){
            optGroup.innerHTML = opts;
            }
                    applyModeUI();
        }

    document.addEventListener('DOMContentLoaded', () => {
        fillEventChoices();
        applyModeUI();

        if (selMode){
        selMode.addEventListener('change', applyModeUI);
        }
    });
    })();

    /* ===== カスタム通知：テンプレート適用 & 文字数カウント ===== */
    (function(){
    function boot(){
        const selTpl  = document.getElementById('cp_tpl');
        const selMode = document.getElementById('cp_event');
        const bodyEl  = document.getElementById('cp_body');
        const cntEl   = document.getElementById('cp_count');
        if (!selTpl || !selMode || !bodyEl) return;

        function pickEventCtx(){
            const eid = selMode.value;

            // イベント未選択 or 手動モード → イベント情報なし
            if (!eid || eid === 'manual') {
                return null;
            }

            const ev = window.__EVENT_INDEX__?.[eid] || null;
            return ev;
            }

        function applyTemplate(){
            const kind = selTpl.value;
            const ctx  = pickEventCtx();

            // イベントが選ばれていないときはテンプレ適用しない
            if (!ctx) {
                // 好みでアラート or スナックバー
                if (typeof showSnackbar === 'function') {
                showSnackbar('テンプレートを使うには、先にイベントを選んでください', {
                    type: 'info',
                    duration: 2500,
                });
                } else {
                alert('テンプレートを使うには、先にイベントを選んでください。');
                }
                return;
            }

            let text = '';

            // 安全側：datetime が空なら date + time で補完
            const datetimeLabel =
                ctx.datetime ||
                [ctx.date, ctx.time].filter(Boolean).join(' ');

            if (kind === '雨天中止'){
                text =
            `【雨天中止のお知らせ】
            ${datetimeLabel} 開催予定の「${ctx.title}」は、雨天のため中止となりました。
            楽しみにしてくださっていた皆さまには申し訳ありません。

            どうぞよろしくお願いいたします。`;
            } else if (kind === '時間変更'){
                text =
            `【集合時間変更のお知らせ】
            ${ctx.date} の「${ctx.title}」は、集合時間を ${ctx.meet || '{MEET_OLD}'} → {MEET_NEW} に変更します。
            集合場所：${ctx.meetPoint || '{MEET_POINT}'}
            開始時間：${ctx.time || '{TIME}'}
            場所：${ctx.place || '{PLACE}'}

            ご不便をおかけしますが、どうぞよろしくお願いいたします。`;
            }

            bodyEl.value = text;
            bodyEl.dispatchEvent(new Event('input'));

            if (cntEl){
                cntEl.textContent = `${bodyEl.value.length} / ${bodyEl.maxLength || 2000}`;
            }
            }

        selTpl.addEventListener('change', applyTemplate);
        selMode.addEventListener('change', () => {
        if (selTpl.value) applyTemplate();
        });

        // 文字数カウンタ
        if (cntEl){
        const upd = () => {
            cntEl.textContent = `${bodyEl.value.length} / ${bodyEl.maxLength || 2000}`;
        };
        bodyEl.addEventListener('input', upd);
        upd();
        }

        bodyEl.style.whiteSpace = 'pre-wrap';
        bodyEl.style.lineHeight = '1.6';
    }

    if (document.readyState === 'loading'){
        document.addEventListener('DOMContentLoaded', boot);
    }else{
        boot();
    }
    })();

    /* ===== カスタム一斉通知：自動宛先プレビュー API 呼び出し（D1版） ===== */
    async function refreshAutoByPreview(){
    const sec     = window.cpSec;
    const selMode = window.selMode;
    const boxAuto = window.boxAuto;

    // 初期化前や手動モードなら何もしない
    if (!sec || !selMode || !boxAuto) return;
    if (selMode.value === 'manual') return;

    const statuses = getCheckedStats();         // ["参加","未定",...]
    if (!statuses.length){
        setText(boxAuto, '（対象ステータスを選択してください）');
        return;
    }

    const wantsUnanswered      = statuses.includes('未回答');
    const answeredStatusFilter = statuses.filter(s => s !== '未回答');

    sec.__loadingAuto = true;
    setText(boxAuto, '（読込中…）');

    let data = null;
    try {
        const lid = await getLineId();
        const url = new URL('/line/attendance/report', D1_ORIGIN);
        url.searchParams.set('lineId',   lid || '');
        url.searchParams.set('eventKey', selMode.value);

        const res = await fetch(url.toString());
        data = await res.json();
    } catch(e){
        console.error('refreshAutoByPreview error:', e);
    } finally {
        sec.__loadingAuto = false;
    }

    if (!data || data.status !== 'ok'){
        setText(boxAuto, '（取得エラー）');
        sec.__autoTargets = [];
        return;
    }

    const rows    = Array.isArray(data.list)    ? data.list    : [];
    const members = Array.isArray(data.members) ? data.members : [];

    // 1) members を line_id 単位にまとめて「入力者情報」を作る
    const membersByLine = new Map();

    for (const m of members) {
        const lid = m.lineId || m.line_id;
        if (!lid) continue;

        const inputName     = (m.inputName || m.input_name || '').trim();
        const performerName = (m.performerName || m.performer_name || '').trim();
        const notifyRaw     = String(m.notify || '').trim().toUpperCase();
        const viewerRaw     = String(m.viewerOnly || m.viewer_only || '').trim().toUpperCase();

        let mem = membersByLine.get(lid);
        if (!mem) {
        mem = {
            lineId          : lid,
            inputName       : '',
            primaryPerformer: '',
            anyNotifyY      : false,
            hasNonViewer    : false,
        };
        }

        if (!mem.inputName && inputName) {
        mem.inputName = inputName;
        }
        if (!mem.primaryPerformer && performerName) {
        mem.primaryPerformer = performerName;
        }

        if (notifyRaw === 'Y' || notifyRaw === '1' || notifyRaw === 'TRUE') {
        mem.anyNotifyY = true;
        }

        const isViewerOnly = (viewerRaw === '1' || viewerRaw === 'Y' || viewerRaw === 'TRUE');
        if (!isViewerOnly) {
        mem.hasNonViewer = true;
        }

        membersByLine.set(lid, mem);
    }

    function isDeliverable(mem){
        if (!mem) return false;
        // 少なくとも1人は viewer_only ではなく、かつ notify=Y な人がいる
        if (!mem.hasNonViewer) return false;
        if (!mem.anyNotifyY)   return false;
        return true;
    }

    // 2) attendance rows を line_id → Set(status) にまとめる
    const attStatusesByLine = new Map();

    for (const r of rows) {
        const lid = r.lineId || r.line_id;
        if (!lid) continue;

        const st = (r.attend || '').trim();
        if (!st) continue;

        let set = attStatusesByLine.get(lid);
        if (!set) {
        set = new Set();
        attStatusesByLine.set(lid, set);
        }
        set.add(st);
    }

    // 3) line_id 単位で「今回の条件にマッチする household」を決める
    const targetsMap = new Map();

    for (const [lid, mem] of membersByLine.entries()) {
        if (!isDeliverable(mem)) continue;

        const set      = attStatusesByLine.get(lid) || new Set();
        const hasAnswer = set.size > 0;

        let hit = false;

        // (a) 回答済み ＆ チェックされたステータスと一致するものがあるか
        if (answeredStatusFilter.length > 0) {
        hit = [...set].some(st => answeredStatusFilter.includes(st));
        } else if (hasAnswer) {
        // フィルタが空で回答だけある場合は「全部対象」とみなす
        hit = true;
        }

        // (b) 「未回答」が含まれていて、この household が未回答なら対象
        if (!hit && !hasAnswer && wantsUnanswered) {
        hit = true;
        }

        if (!hit) continue;

        const label =
        mem.inputName ||
        mem.primaryPerformer ||
        lid;

        targetsMap.set(lid, { lineId: lid, label });
    }

    const autoTargets = Array.from(targetsMap.values())
        .sort((a, b) => a.label.localeCompare(b.label, 'ja'));

    sec.__autoTargets = autoTargets;

    const labels = autoTargets.map(x => x.label).filter(Boolean);
    setText(boxAuto, labels.length ? labels.join('\n') : '（該当なし）');
    }

/* ===== カスタム一斉通知：送信UI（リセット・プレビュー・送信） ===== */
    (function(){
        const root = window.cpSec || document.getElementById('view-custom-push');
        if (!root) return;

        // グローバルに寄せたハンドルを優先的に使う
        const selMode = window.selMode || document.getElementById('cp_event');
        const selTpl  = document.getElementById('cp_tpl');
        const bodyEl  = document.getElementById('cp_body');
        const cntEl   = document.getElementById('cp_count');
        const boxAuto = window.boxAuto || document.getElementById('cp_auto');   // 表示用（自動）
        const boxMan  = document.getElementById('cp_manual');                   // 表示用（手動）
        const selExtra= document.getElementById('cp_extra');

        // 状態キャッシュ（既存があれば流用）
        root.__autoTargets = Array.isArray(root.__autoTargets) ? root.__autoTargets : [];

        // --- いま選べている自動宛先が未取得なら、preview API で埋める ---
        async function ensureAutoTargets(){
            if (!selMode || !selMode.value || selMode.value === 'manual') return [];
            if (Array.isArray(root.__autoTargets) && root.__autoTargets.length) {
            return root.__autoTargets;
            }

            // 画面側のプレビュー処理に委譲（UI更新 + __autoTargets 更新）
            if (typeof refreshAutoByPreview === 'function') {
            await refreshAutoByPreview();
            }

            return Array.isArray(root.__autoTargets) ? root.__autoTargets : [];
        }

        // --- 手動宛先（プルダウン選択分）を集める ---
        function collectManualTargets(){
            if (!selExtra) return [];
            return Array.from(selExtra.selectedOptions || [])
            .map(o => ({ lineId: o.value, label: o.textContent.trim() }))
            .filter(x => x.lineId);
        }

        // --- 自動＋手動の宛先をマージ（lineId で重複排除） ---
        async function collectAllTargets(){
            const auto = await ensureAutoTargets(); // [{lineId,label}]
            const man  = collectManualTargets();
            const uniq = new Map();

            [...auto, ...man].forEach(x => {
            if (x && x.lineId){
                uniq.set(x.lineId, {
                lineId: x.lineId,
                label : x.label || x.name || x.lineId
                });
            }
            });

            return Array.from(uniq.values());
        }

        // --- リセット ---
        function doReset(){
            // イベント＝手動
            if (selMode){
            selMode.value = 'manual';
            selMode.dispatchEvent(new Event('change'));
            }

            // ステータス未選択
            document.querySelectorAll('#cp_stat_wrap .cp_stat')
            .forEach(cb => { cb.checked = false; });

            // 自動宛先表示とキャッシュをクリア
            root.__autoTargets = [];
            if (boxAuto) setText(boxAuto, '（手動モード：自動選択は使いません）');

            // 手動宛先の選択を解除
            if (selExtra){
            Array.from(selExtra.options).forEach(o => { o.selected = false; });
            }
            if (boxMan) setText(boxMan, '（未選択）');

            // テンプレ＆本文クリア
            if (selTpl){ selTpl.value = ''; }
            if (bodyEl){
            bodyEl.value = '';
            bodyEl.dispatchEvent(new Event('input'));
            }
            if (cntEl) {
            const max = bodyEl?.maxLength || 2000;
            cntEl.textContent = `0 / ${max}`;
            }
        }

        // --- プレビューUI表示用モーダル生成 ---
        function openPreview({body, count, sampleList, onConfirm}){
            const ov = document.createElement('div');
            ov.className = 'cpModalOverlay';
            ov.innerHTML = `
            <div class="cpModal" role="dialog" aria-modal="true">
                <h3>送信プレビュー</h3>
                <div class="meta">宛先 <b>${count}</b> 人に送信します。</div>
                <pre>${body.replace(/[<>&]/g, m => ({'<':'&lt;','>':'&gt;','&':'&amp;'}[m]))}</pre>
                <div class="muted" style="margin-top:6px;">
                宛先例：${sampleList.slice(0,3).map(s=>`<span class="pill sm" style="margin-right:6px;">${s}</span>`).join('')}
                ${sampleList.length>3 ? `ほか ${sampleList.length-3} 名` : ''}
                </div>
                <div class="actions">
                <button type="button" class="btn btn-ghost btn-sm">キャンセル</button>
                <button type="button" class="btn btn-primary btn-sm" id="cp_do_send">OK（送信）</button>
                </div>
            </div>`;
            document.body.appendChild(ov);

            const btns  = ov.querySelectorAll('.btn');
            const close = () => { ov.remove(); };

            btns[0].addEventListener('click', close);
            btns[1].addEventListener('click', async ()=>{
            btns[0].disabled = true;
            btns[1].disabled = true;
            try { await onConfirm(); } finally { close(); }
            });
        }

        // --- 実送信：customPushSend API 呼び出し（CORS → no-cors フォールバック） ---
        async function sendNow({ body, targets, eventId }){
            const sender = (typeof window.getLineId === 'function')
            ? await window.getLineId()
            : '';

            const form = new URLSearchParams();
            form.set('customPushSend', '1');
            if (sender) form.set('senderLineId', sender);
            if (eventId && eventId !== 'manual') form.set('eventId', eventId);
            form.set('body', body);
            form.set('targets', JSON.stringify(targets.map(t => t.lineId)));

            // まず通常の CORS で試す
            try{
            const res = await fetch(API_ENDPOINT, { method:'POST', body: form });
            let data = null;
            try { data = await res.json(); } catch(_){}
            if (res.ok) return data || { status:'ok' };
            throw new Error('HTTP '+res.status);
            }catch(e){
            console.warn('CORS failed, fallback to no-cors:', e);
            // フォールバック：投げっぱなし（成功可否は読めない）
            try{
                await fetch(API_ENDPOINT, { method:'POST', body: form, mode:'no-cors' });
                return { status:'ok', note:'no-cors fallback' };
            }catch(err){
                return { status:'error', message:String(err) };
            }
            }
        }

        // --- 本文バリデーション（空/プレースホルダ残り検知） ---
        function validateBody(text){
            if (!text || !text.trim()) return '本文が空です。';
            const remains = [];
            ['{MEET_NEW}','{MEET_POINT}','{TIME}','{PLACE}','{MEET_OLD}','{TITLE}','{DATE}','{DATETIME}'].forEach(ph=>{
            if (text.includes(ph)) remains.push(ph);
            });
            if (remains.length) return `本文に未置換の項目があります：${remains.join('、')}`;
            return '';
        }

        // === イベント結線 ===
        const btnReset = document.getElementById('cp_reset');
        const btnSend  = document.getElementById('cp_send');

        btnReset?.addEventListener('click', (e)=>{
            e.preventDefault();
            doReset();
        });

        btnSend?.addEventListener('click', async (e)=>{
            e.preventDefault();

            const body = bodyEl?.value || '';
            const err  = validateBody(body);
            if (err){
            alert(err);
            return;
            }

            // 宛先収集（必要なら preview API を叩いて最新化）
            const targets = await collectAllTargets();
            if (!targets.length){
            alert('宛先がありません。イベントと対象ステータス、または手動宛先を選択してください。');
            return;
            }

            // プレビュー → OKで送信
            openPreview({
            body,
            count: targets.length,
            sampleList: targets.map(t => t.label || t.lineId),
            onConfirm: async ()=>{
                btnSend.disabled = true;  // 連打防止

                const res = await sendNow({ body, targets, eventId: selMode?.value });
                if (res?.status === 'ok'){
                alert('送信しました。');
                // 必要ならここで doReset();
                }else{
                alert(`送信に失敗しました：${res?.message || 'unknown error'}`);
                }

                btnSend.disabled = false;
            }
            });
        });
    })();

/* ===== サマリ ===== */
    // ========= サマリ：無料枠カードの描画 =========
    window.renderFreeQuotaCard = function (data) {
      // data: { status:'ok', kind:'freeQuota', used, limit, remain, followers, followersEffective }
      const used      = Number(data.used ?? 0);
      const limit     = Number(data.limit ?? 0);
      const remain    = Number(data.remain ?? Math.max(0, limit - used));
      const followers = Number(data.followers ?? data.followersEffective ?? 0);
    
      const perBlast  = followers > 0 ? Math.floor(remain / followers) : 0;
    
      return `
        <div class="card" style="margin-top:6px;">
          <div class="sectionTitle">無料枠 確認</div>
          <div class="list">
            <div>当月送信：<b>${used}</b> / <b>${limit}</b>（残り：<b>${remain}</b>通）</div>
            <div>フォロワー：<b>${followers}</b> 人</div>
            <div>全体配信あと：<b>${perBlast}</b> 回</div>
          </div>
        </div>`;
    };
    
   // ========= サマリ：無料枠の取得＆描画 =========
    window.loadSummaryFreeQuota = async function () {
    const box = document.getElementById('summaryFreeQuotaBox');
    if (!box) {
        console.warn('#summaryFreeQuotaBox が見つかりません');
        return;
    }
    box.innerHTML = '読み込み中… <span class="spinner"></span>';

    try {
        // ★ D1_ORIGIN を使って Worker 側の新エンドポイントを叩く
        const url = new URL('/line/summary/free-quota', D1_ORIGIN);
        const res = await fetch(url.toString());
        const r = await res.json();
        console.log('freeQuota resp (worker):', r);

        if (!r || r.status !== 'ok') {
        box.innerHTML = `<div class="err">取得に失敗しました：${r?.message || 'unknown'}</div>`;
        return;
        }

        box.innerHTML = window.renderFreeQuotaCard(r);
    } catch (e) {
        console.error(e);
        box.innerHTML = `<div class="err">エラー：${e.message || e}</div>`;
    }
    };
    
    // ===== サマリ：タブ切替共通 =====
      (function(){
        const btnFree = document.getElementById('btnSummaryFreeQuota');
        const btnPush = document.getElementById('btnSummaryPushStats');
        const boxFree = document.getElementById('summaryFreeQuotaBox');
        const boxPush = document.getElementById('summaryPushStatsBox');
      
        function setActive(tab){ // 'free' | 'push'
          if (!btnFree || !btnPush || !boxFree || !boxPush) return;
          const on  = (el)=>{ el.classList.remove('btn-outline'); el.classList.add('btn-primary'); };
          const off = (el)=>{ el.classList.remove('btn-primary'); el.classList.add('btn-outline'); };
          if (tab === 'free'){
            on(btnFree);  off(btnPush);
            boxFree.style.display = '';
            boxPush.style.display = 'none';
          } else {
            on(btnPush);  off(btnFree);
            boxFree.style.display = 'none';
            boxPush.style.display = '';
          }
        }
      
        window.showSummaryFreeTab = function(){ setActive('free'); };
        window.showSummaryPushTab = function(){ setActive('push'); };
      
        // 画面遷移時（サマリボタン）
        document.getElementById('btnSummary')?.addEventListener('click', ()=>{
          if (!state.isAdmin){ alert('管理者のみアクセス可能です'); return; }
          show('#view-summary');
          showSummaryFreeTab();           // デフォルトは無料枠タブ
          window.loadSummaryFreeQuota?.();
        });
      
        // タブクリック
        btnFree?.addEventListener('click', ()=>{
          showSummaryFreeTab();
          window.loadSummaryFreeQuota?.();
        });
        btnPush?.addEventListener('click', ()=>{
          showSummaryPushTab();
          window.loadSummaryPushStats?.();
        });
      
        // 再取得（アクティブタブに合わせて）
        document.getElementById('btnSummaryReload')?.addEventListener('click', ()=>{
          if (boxPush?.style.display !== 'none') {
            window.loadSummaryPushStats?.();
          } else {
            window.loadSummaryFreeQuota?.();
          }
        });
      })();
      
    // ===== サマリ：配信履歴（当月） =====
    window.loadSummaryPushStats = async function(){
        const box = document.getElementById('summaryPushStatsBox');
        if (!box) return;
        box.innerHTML = `取得中… <span class="spinner"></span>`;

        try {
            // D1 Worker 直叩き
            const url = new URL("/summary/push-stats", D1_BASE);
            const res = await fetch(url.toString());
            const r = await res.json();

            if (r?.status !== 'ok'){
            box.innerHTML = `<div class="err">エラー: ${h(r?.message||'取得に失敗しました')}</div>`;
            return;
            }
            if (r.empty){
            box.innerHTML = `<div class="small muted">データがありません</div>`;
            return;
            }

            const fmtNum = n => (typeof n==='number' ? n.toLocaleString() : String(n||'0'));
            const month  = h(r.month || '');
            const logs   = r.logs || {count:0,totalTargets:0,totalSuccess:0,totalFail:0};

            const kpis = `
            <div class="summaryKpis">
                <div class="kpi"><div class="kpiLabel">ログ件数</div><div class="kpiValue">${fmtNum(logs.count)}</div></div>
                <div class="kpi"><div class="kpiLabel">対象件数</div><div class="kpiValue">${fmtNum(logs.totalTargets)}</div></div>
                <div class="kpi"><div class="kpiLabel">成功数</div><div class="kpiValue">${fmtNum(logs.totalSuccess)}</div></div>
                <div class="kpi"><div class="kpiLabel">失敗数</div><div class="kpiValue">${fmtNum(logs.totalFail)}</div></div>
            </div>`;

            const recent = r.recent || [];
            const recentRows = recent.map(x=>{
            const isFail = Number(x.fail) > 0;
            const resultLabel = isFail
                ? `<span class="ng">失敗</span>`
                : `<span class="ok">成功</span>`;
            return `<tr>
                <td class="nowrap">${h(x.at||'')}</td>
                <td>${h(x.type||'')}</td>
                <td class="mono">${h(x.eventId||'')}</td>
                <td class="num">${resultLabel}</td>
            </tr>`;
            }).join('') || `<tr><td colspan="4" class="muted">直近20件なし</td></tr>`;

            box.innerHTML = `
            <div class="summaryBlock">
                <div class="summaryHeader">当月配信サマリ（${month}）</div>
                <div class="small muted" style="margin: -4px 0 8px;">
                ※ 本サマリの数値は「このシステム経由の送信」のみを対象としています。
                </div>
                ${kpis}
            </div>

            <div class="summaryBlock historyBlock">
                <div class="summarySubHeader">履歴（直近20件）</div>
                <table class="table compact verysmall history">
                <thead>
                    <tr><th>日時</th><th>種別</th><th>公演ID</th><th>結果</th></tr>
                </thead>
                <tbody>${recentRows}</tbody>
                </table>
            </div>
            `;
        } catch(err){
            console.error(err);
            box.innerHTML = `<div class="err">通信エラー: ${h(err?.message||err)}</div>`;
        }
        };
</script>
 
<script>
/* ===== フィードバック FAB ＆送信モーダル ===== */
    document.addEventListener('DOMContentLoaded', () => {
    (function(){
        const ENDPOINT      = window.GAS_ENDPOINT || window.API_BASE || '';
        const LIMIT         = 300;
        const COOLDOWN_SEC  = 10;
        const LS_KEY        = 'fbCooldownAt';

        async function getCurrentLineId(){
        return window.STATE?.lineId || window.state?.lineId || '';
        }
        async function getCurrentDisplayName(){
        return window.STATE?.displayName || window.state?.displayName || '';
        }

        const $        = s => document.querySelector(s);
        const modal    = $('#feedbackModal');
        const fab      = $('#feedbackFab');
        const textarea = $('#fbMessage');
        const counter  = $('#fbCount');
        const sendBtn  = $('#fbSendBtn');
        const snackbar = $('#snackbar');

        function openModal(){
        if (!modal) return;
        modal.hidden = false;
        if (textarea){
            textarea.focus();
            updateCount();
        }
        }
        function closeModal(){
        if (!modal) return;
        modal.hidden = true;
        }
        function showSnack(message){
        if (!snackbar) return;
        snackbar.textContent = message;
        snackbar.classList.add('show');
        setTimeout(()=> snackbar.classList.remove('show'), 2600);
        }
        function updateCount(){
        if (!counter || !textarea) return;
        counter.textContent = String(textarea.value.length);
        }
        function nowTs(){ return Math.floor(Date.now()/1000); }

        function cooldownLeft(){
        const at = Number(localStorage.getItem(LS_KEY) || '0');
        return Math.max(0, COOLDOWN_SEC - (nowTs() - at));
        }

        function startCooldown(){
        localStorage.setItem(LS_KEY, String(nowTs()));
        }

        fab   ?.addEventListener('click', openModal);
        modal ?.addEventListener('click', (e)=>{ if (e.target.dataset.close) closeModal(); });
        textarea?.addEventListener('input', updateCount);

        let sending = false;
        sendBtn?.addEventListener('click', async ()=>{
        if (sending) return;
        const cd = cooldownLeft();
        if (cd > 0){
            showSnack(`連続送信はできません。${cd}秒後に再度お試しください`);
            return;
        }

        const message  = (textarea.value || '').replace(/\s+/g,' ').trim();
        const category = (document.getElementById('fbCategory')?.value || 'その他').trim();
        if (!message){
            showSnack('メッセージを入力してください');
            textarea.focus();
            return;
        }
        if (message.length > LIMIT){
            showSnack('文字数上限を超えています');
            return;
        }

        try{
            sending = true;
            sendBtn.disabled = true;
            sendBtn.textContent = '送信中…';

            const lineId = await getCurrentLineId();
            const name   = await getCurrentDisplayName();

            console.debug('fb endpoint', ENDPOINT);

            const esc = encodeURIComponent;
            const j = await api(
            `?feedbackSubmit=1` +
            `&lineId=${esc(lineId || '')}` +
            `&name=${esc(name || '')}` +
            `&category=${esc(category || 'その他')}` +
            `&message=${esc(message || '')}`
            );
            console.debug('fb response', j);

            const ok = j && (j.status === 'ok' || j.inserted === true);
            if (ok){
            showSnack('送信しました。ご協力ありがとうございます！');
            textarea.value = '';
            updateCount();
            startCooldown();
            closeModal();
            }else{
            showSnack(j?.message || '送信に失敗しました');
            }
        }catch(err){
            console.error(err);
            showSnack('通信エラーが発生しました');
        }finally{
            sending = false;
            sendBtn.disabled = false;
            sendBtn.textContent = '送信';
        }
        });

        window.__fbDebug = {
        getCurrentLineId,
        getCurrentDisplayName,
        hasFab: !!fab,
        hasModal: !!modal
        };
    })();
    });
</script>

<script>
/* ===== 更新履歴モーダル（CHANGELOG） ===== */
    (function () {
      // --- 1. エントリ一覧（共通設定にあればそれを使う） ---
      const ENTRIES =
        window.CHANGELOG_ENTRIES ||   // 共通設定側で定義している場合
        window.__CHANGELOG_ENTRIES__ || // 名前違いの保険
        [];                            // どれも無ければ空
  
      const LS_KEY = "changelogLastSeen"; // 既読管理キー
  
      const modal = document.querySelector("#changelogModal");
      const list  = document.querySelector("#changelogList");
      const verEl = document.getElementById("ver");   // ヘッダーのバージョン表示
  
      // --- 2. HTMLエスケープ ---
      function escapeHtml(s) {
        return String(s == null ? "" : s).replace(/[&<>"']/g, c => (
            { "&": "&amp;", "<": "&lt;", ">": "&gt;", "\"": "&quot;", "'": "&#39;" }[c] || c
        ));
    }
  
      // --- 3. 更新履歴の描画 ---
      function render() {
        if (!list) return;
        list.innerHTML = ENTRIES.map(e => `
          <div class="cg-item">
            <div class="cg-head">
              <div class="cg-title">${escapeHtml(e.title)}</div>
              <div class="cg-tags">
                ${(e.tags || []).map(t =>
                  `<span class="cg-tag">${escapeHtml(t)}</span>`
                ).join("")}
              </div>
            </div>
            <div class="cg-date">${escapeHtml(e.date || "")}</div>
            <div class="cg-body">${escapeHtml(e.body || "")}</div>
          </div>
        `).join("");
      }
  
      // --- 4. 未読管理 ---
      function latestDate() {
        return ENTRIES.map(e => e.date).sort().slice(-1)[0] || "";
      }
  
      function refreshBadge() {
        const lastSeen = localStorage.getItem(LS_KEY) || "";
        const latest   = latestDate();
        const unread   = latest && (!lastSeen || lastSeen < latest);
  
        if (verEl) {
          verEl.classList.toggle("has-unread", !!unread);
        }
      }
  
      function markAsRead() {
        const latest = latestDate();
        if (latest) {
          localStorage.setItem(LS_KEY, latest);
        }
        refreshBadge();
      }
  
      // --- 5. モーダル開閉 ---
      function openModal() {
        if (!modal) return;
        render();         // ← ここで毎回描画する（これが抜けていると中身が空になる）
        modal.hidden = false;
        markAsRead();     // 開いたタイミングで既読扱い
      }
  
      function closeModal() {
        if (!modal) return;
        modal.hidden = true;
      }
  
      // --- 6. イベント設定 ---
  
      // ヘッダのバージョン文字をボタンとして扱う
      if (verEl) {
        verEl.setAttribute("role", "button");
        verEl.setAttribute("tabindex", "0");
        verEl.style.cursor = "pointer";
  
        const openHandler = () => openModal();
  
        verEl.addEventListener("click", openHandler);
        verEl.addEventListener("keydown", e => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            openHandler();
          }
        });
  
        // 外からも呼べるようにしておく（既存コード用）
        window.openChangelogModal = openHandler;
      }
  
      // モーダル内の×ボタン／背景クリック
      modal?.addEventListener("click", e => {
        if (e.target.dataset.close) {
          closeModal();
        }
      });
  
      // Escキーで閉じる
      document.addEventListener("keydown", e => {
        if (e.key === "Escape" && !modal.hidden) {
          closeModal();
        }
      });
  
      // --- 7. 初期バッジ更新 ---
      refreshBadge();
    })();
</script>

<script>
/* ===== バージョンラベル表示（FRONT_VERSION） ===== */
    (function(){
      function attachVersionLabel() {
        const el = document.getElementById('ver');
        if (!el) return;

        // バージョン文字列が未表示なら FRONT_VERSION を反映
        if (!el.textContent && typeof FRONT_VERSION === 'string') {
        el.textContent = FRONT_VERSION;
        }
        // クリック挙動は changelog スクリプトが担当するのでここでは何もしない
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', attachVersionLabel);
        } else {
            attachVersionLabel();
        }
    })();
</script>

<script>
/* ===== フィードバック一覧ビュー（管理） ===== */
    (function () {
    // 戻る / 再読込ボタン
    document.getElementById('btnFeedbackBack')
        ?.addEventListener('click', () => show('#view-home'));
    document.getElementById('fbReload')
        ?.addEventListener('click', () => window.loadFeedbackList?.());

    // 「どこまで読んだか」を保存するキー（Noベース）
    const FB_LS_KEY = 'feedbackLastSeenNo';

    // ステータス → CSS クラス
    function statusClass(value) {
        switch (value) {
        case '完了':   return 'is-完了';
        case '却下':   return 'is-却下';
        case '保留':   return 'is-保留';
        case '対応中': return 'is-対応中';
        default:       return 'is-未対応';
        }
    }
    function applyStatusColor(sel) {
        sel.classList.remove('is-未対応','is-対応中','is-保留','is-完了','is-却下');
        sel.classList.add(statusClass(sel.value));
    }

    // エスケープ & 日付整形
    const esc = s => String(s ?? '').replace(/[&<>"']/g, c =>
        ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", "\"": "&quot;", "'": "&#39;" }[c])
    );
    const pad = n => String(n).padStart(2, '0');
    const fmtDate = (s) => {
        if (!s) return '';
        if (/^\d{4}\/\d{2}\/\d{2}\s+\d{2}:\d{2}/.test(s)) return s.slice(0, 16);
        const d = new Date(s);
        if (isNaN(d.getTime())) return String(s);
        return `${d.getFullYear()}/${pad(d.getMonth() + 1)}/${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
    };

    // ご意見一覧（カテゴリ別表示・D1直叩き）
    window.loadFeedbackList = async function () {
        console.debug('[fb] loadFeedbackList invoked');

        // 念のためビューを可視化
        document.querySelector('#view-feedback')?.removeAttribute('hidden');

        const box = document.getElementById('feedbackListBox');
        if (!box) return;
        box.innerHTML = '読み込み中… <span class="spinner"></span>';

        try {
        // 1) まず state から lineId を試す
        let lineId = (window.state?.lineId || window.STATE?.lineId || '');
        console.debug('[fb] lineId from state:', JSON.stringify(lineId));

        // 2) state に無ければ profile.userId を試す
        if (!lineId) {
            const fromProfile =
            window.state?.profile?.userId ||
            window.STATE?.profile?.userId ||
            '';
            console.debug('[fb] lineId from profile.userId:', JSON.stringify(fromProfile));
            lineId = fromProfile;
        }

        // 3) それでも無ければ LIFF から直接取得
        if (!lineId && window.liff && typeof liff.getProfile === 'function') {
            try {
            const prof = await liff.getProfile();
            lineId = prof.userId || '';
            console.debug('[fb] lineId from liff.getProfile:', JSON.stringify(lineId));
            } catch (e) {
            console.warn('[fb] liff.getProfile fallback failed', e);
            }
        }

        console.debug('[fb] final lineId used =', JSON.stringify(lineId));

        if (!lineId) {
            box.innerHTML = '<div class="err">lineId が取得できませんでした</div>';
            return;
        }

        // 共通 state に書き戻す（更新側も同じ値を使えるように）
        window.state = window.state || {};
        window.state.lineId = lineId;

        // ★ Worker (D1) を直接叩く
        const workerUrl = new URL(
            `/line/admin/feedback/list?lineId=${encodeURIComponent(lineId)}`,
            D1_ORIGIN
        );
        console.debug('[fb] request workerUrl =', workerUrl.toString());

        const res = await fetch(workerUrl.toString());
        const j = await res.json();
        console.debug('[fb] worker api response –', j);

        if (j?.status !== 'ok' || !Array.isArray(j.items)) {
            box.innerHTML = '<div class="err">取得に失敗しました</div>';
            return;
        }

        // ==== items 正規化 ====
        const items = j.items.map(it => ({
            no:       it.no ?? it.No ?? '',
            name:     it.name ?? it.名前 ?? '',
            at:       it.at ?? it.date ?? it.送信日時 ?? '',
            category: it.category ?? it.カテゴリ ?? 'その他',
            message:  it.message ?? it.メッセージ ?? '',
            status:   it.status ?? it.ステータス ?? '未対応',
        }));

        // カテゴリごとにグルーピング
        const byCat = {};
        for (const it of items) {
            const c = it.category || 'その他';
            (byCat[c] ||= []).push(it);
        }

        // カテゴリの表示順
        const CAT_ORDER = ['要望', '不具合', 'デザイン', 'その他'];
        const orderKey = (c) => {
            const i = CAT_ORDER.indexOf(c);
            return i >= 0 ? i : 999;
        };

        const lastSeen = Number(localStorage.getItem(FB_LS_KEY) || '0');

        const row = it => `
            <div class="fb-row">
            <div class="fb-row-head">
                <span class="mono">#${esc(it.no)}</span>
                <span class="name">${esc(it.name || '（名無し）')}</span>
                <span class="date">${esc(fmtDate(it.at))}</span>
            </div>
            <div class="fb-row-body">
                <div class="fb-msg">${esc(it.message)}</div>
                <div class="fb-status-wrap">
                <select class="fb-status" data-no="${esc(it.no)}" data-cur="${esc(it.status)}">
                    ${['未対応','対応中','保留','完了','却下'].map(s =>
                    `<option value="${s}" ${s === it.status ? 'selected' : ''}>${s}</option>`
                    ).join('')}
                </select>
                </div>
            </div>
            </div>
        `;

        const html = Object.keys(byCat)
            .sort((a, b) => orderKey(a) - orderKey(b) || a.localeCompare(b))
            .map(cat => {
            const arr = byCat[cat];
            const maxNo = Math.max(...arr.map(it => Number(it.no) || 0));
            const hasUnread = maxNo > lastSeen;
            return `
                <details class="fb-cat card${hasUnread ? ' has-unread' : ''}" data-maxno="${maxNo}">
                <summary class="fb-cat-head">
                    <span class="sectionTitle">${esc(cat)}</span>
                    <span class="fb-count">${arr.length}件</span>
                </summary>
                <div class="fb-list">
                    ${arr.map(row).join('') || '<div class="small muted">なし</div>'}
                </div>
                </details>
            `;
            })
            .join('') || '<div class="small muted">データがありません</div>';

        box.innerHTML = html;

        // ステータス色
        box.querySelectorAll('.fb-status').forEach(sel => applyStatusColor(sel));

        // カテゴリを開いたら既読更新
        box.querySelectorAll('details.fb-cat').forEach(det => {
            det.addEventListener('toggle', () => {
            if (!det.open) return;
            if (!det.classList.contains('has-unread')) return;

            const catMax = Number(det.dataset.maxno || '0');
            const cur = Number(localStorage.getItem(FB_LS_KEY) || '0');
            const next = Math.max(cur, catMax);
            localStorage.setItem(FB_LS_KEY, String(next));
            det.classList.remove('has-unread');
            });
        });

        } catch (err) {
        console.error(err);
        box.innerHTML = `<div class="err">通信エラー: ${esc(err?.message || err)}</div>`;
        }
    };

    // ステータス変更イベント（イベント委任）: 変更フラグだけ立てる
    (function () {
        const box = document.getElementById('feedbackListBox');
        if (!box) return;

        box.addEventListener('change', (e) => {
        const sel = e.target;
        if (!sel.classList || !sel.classList.contains('fb-status')) return;

        const cur = sel.dataset.cur || sel.getAttribute('data-cur') || '';
        const now = sel.value;

        const row = sel.closest('.fb-row');
        if (cur !== now) {
            sel.classList.add('is-dirty');
            row?.classList.add('is-dirty');
        } else {
            sel.classList.remove('is-dirty');
            row?.classList.remove('is-dirty');
        }
        });
    })();
    })();

    // 「変更を保存」ボタンでまとめて更新
        (function () {
        const btn = document.getElementById('fbSave');
        const box = document.getElementById('feedbackListBox');
        if (!btn || !box) return;

        btn.addEventListener('click', async () => {
            const sels = Array.from(box.querySelectorAll('.fb-status'));

            const targets = sels.filter(sel => {
            const cur = sel.dataset.cur || sel.getAttribute('data-cur') || '';
            return cur !== sel.value;
            });

            if (targets.length === 0) {
            showSnackbar('変更された項目はありません。', { variant: 'default' });
            return;
            }

            // lineId を共通で取得
            let lid = (window.state?.lineId || window.STATE?.lineId || '');
            if (!lid) {
            const fromProfile =
                window.state?.profile?.userId ||
                window.STATE?.profile?.userId ||
                '';
            if (fromProfile) {
                lid = fromProfile;
                window.state = window.state || {};
                window.state.lineId = lid;
            }
            }

            if (!lid) {
            showSnackbar('LINE ID が取得できず、保存できませんでした。', {
                variant: 'error',
                duration: 4000,
            });
            return;
            }

            btn.disabled = true;
            showSnackbar('ステータスを保存中…', { variant: 'loading' });

            let hasError = false;

            try {
            for (const sel of targets) {
                const no   = sel.dataset.no;
                const to   = sel.value;
                const prev = sel.dataset.cur || sel.getAttribute('data-cur') || '';

                const q = `?feedbackSetStatus=1&lineId=${encodeURIComponent(lid)}&no=${encodeURIComponent(no)}&status=${encodeURIComponent(to)}`;
                console.debug('[fb] bulk save – request path:', q);

                try {
                const r = await api(q);
                console.debug('[fb] bulk save – response:', r);

                if (r?.status === 'ok') {
                    sel.dataset.cur = to;
                    sel.classList.remove('is-dirty');
                    sel.closest('.fb-row')?.classList.remove('is-dirty');
                } else {
                    hasError = true;
                    sel.value = prev;
                    showSnackbar(`No.${no} の更新に失敗しました: ${r?.message || 'error'}`, {
                    variant: 'error',
                    duration: 4000,
                    });
                }
                } catch (err) {
                hasError = true;
                sel.value = prev;
                showSnackbar(`No.${no} の通信エラー: ${err?.message || err}`, {
                    variant: 'error',
                    duration: 4000,
                });
                }
            }

            // 🔁 D1 から最新を再読み込み
            if (typeof window.loadFeedbackList === 'function') {
                await window.loadFeedbackList();
            }

            hideSnackbar();

            if (!hasError) {
                showSnackbar('ステータスを保存しました', { variant: 'success' });
            } else {
                showSnackbar('一部の更新でエラーが発生しました（最新状態を再読込しました）', {
                variant: 'error',
                duration: 4000,
                });
            }
            } finally {
            btn.disabled = false;
            }
        });
        })();

    // ===== 共通スナックバー =====
        window.showSnackbar = function (message, options = {}) {
        const el = document.getElementById('snackbar');
        if (!el) return;

        const variant = options.variant || 'default'; // 'default' | 'loading' | 'success' | 'error'
        let duration  = options.duration;

        // loading のときデフォで「自動で消さない」
        if (duration == null) {
            duration = (variant === 'loading') ? 0 : 2500;
        }

        // メッセージ差し込み
        el.textContent = message;

        // 既存タイマーがあればクリア
        if (el._snackbarTimer) {
            clearTimeout(el._snackbarTimer);
            el._snackbarTimer = null;
        }

        // variant クラス付け替え
        el.classList.remove('loading', 'success', 'error');
        if (variant === 'loading')   el.classList.add('loading');
        if (variant === 'success')   el.classList.add('success');
        if (variant === 'error')     el.classList.add('error');

        // 表示
        el.classList.add('show');

        // duration > 0 のときだけ自動で消す
        if (duration > 0) {
            el._snackbarTimer = setTimeout(() => {
            el.classList.remove('show');
            el._snackbarTimer = null;
            }, duration);
        }
        };

        window.hideSnackbar = function () {
        const el = document.getElementById('snackbar');
        if (!el) return;

        if (el._snackbarTimer) {
            clearTimeout(el._snackbarTimer);
            el._snackbarTimer = null;
        }
        el.classList.remove('show');
        };
</script>

<script>
// ===== 起動 =====
document.addEventListener('DOMContentLoaded', () => {
  try { init(); } catch (e) { console.error(e); }
});
</script>

